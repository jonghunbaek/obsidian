---
플랫폼: 프로그래머스
알고리즘: 구현, 배열, 완전탐색
tags:
  - 구현
  - 배열
  - 완전탐색
date: 2025-12-22
복습 풀이: 251222(X)
---
# 1차 풀이
```java
// 배열, 완탐 문제
// 지도를 탐색하며, "-1"을 발견하면 큰 돗자리부터 사용 가능 여부 검증
import java.util.*;

class Solution {
    public int solution(int[] mats, String[][] park) {
        mats = Arrays.stream(mats).boxed()
            .sorted((o1, o2) -> o2 - o1)
            .mapToInt(Integer::intValue)
            .toArray();
  
        int max = 0;
        for (int i = 0; i < park.length; i++) {
            for (int j = 0; j < park[i].length; j++) {
                if (!park[i][j].equals("-1")) continue;
                
                
                int idx = 0;
                while (idx < mats.length) {
                    boolean enable = true;
                    for (int n = i; n < i + mats[idx]; n++) {
                        for (int m = j; m < j + mats[idx]; m++) {
                            if ((n >= park.length || m >= park[i].length) || !park[n][m].equals("-1")) {
                                enable = false;
                                break;
                            }
                        }
                    }
                
                    if (enable) {
                        max = Math.max(max, mats[idx]);
                        idx = 0;
                        break;
                    }

                    idx++;    
                }
            }
        }
        
        return max;
    }
}
```

`Arrays.sort(mats, (o1, o2) -> o2 - o1);`
IDE가 없는 경우 이런 문법에서 계속 틀림

### 1. 기본 타입 배열(`int[]`)은 Comparator를 쓸 수 없습니다
`Arrays.sort(배열, Comparator)` 문법을 사용하려면 배열의 요소가 **객체(Object)**여야 합니다.
- `int[]`는 기본 타입(Primitive Type) 배열입니다. 자바에서 `int`는 객체가 아니기 때문에 `Comparator`를 적용할 수 없습니다.
- 내림차순 정렬을 위해 람다식 `(o1, o2) -> o2 - o1`을 쓰려면, 배열이 `Integer[]`와 같은 **래퍼 클래스(Wrapper Class)** 타입이어야 합니다.
### 2. 타입 추론의 문제
코드에서 `(o1, o2)`라고 작성하면, 자바는 이 `o1`, `o2`가 어떤 타입인지 배열을 보고 추론합니다.
- 만약 `mats`가 `int[]`라면, 자바는 `o1`, `o2`를 객체로 취급할 수 없어 에러가 발생합니다.
- 만약 `mats`가 `String[]`이나 `Integer[]`라면 이 문법은 정상 작동합니다.

엣지 케이스 2개를 못찾아서 틀림
-> 문제를 꼼꼼히 읽었다면 충분히 해결할 수 있던 케이스