---
플랫폼: 프로그래머스
문제 이름: 가장 큰 수
알고리즘: 정렬
tags:
  - 정렬
date: 2025-08-07
aliases:
  - 정렬
복습 풀이: 250807(X), 250817(X), 250823(O), 251027(X), 251101(O)
---
# 1차 풀이
```java
import java.util.*;

class Solution {
    public String solution(int[] numbers) {
        String[] values = new String[numbers.length];
        for (int i = 0; i < values.length; i++) {
            values[i] = String.valueOf(numbers[i]);
        }

        List<String> results = new ArrayList<>();
        List<String> target = new ArrayList<>();
        boolean[] visited = new boolean[numbers.length];
        createNumberStrings(values, visited, target, results);

        long[] array = results.stream()
                .mapToLong(Long::valueOf)
                .sorted()
                .toArray();

        return array[array.length - 1] + "";
    }

    private void createNumberStrings(String[] values, boolean[] visited, List<String> target, List<String> results) {
        if (target.size() == values.length) {
            String result = String.join("", target);
            results.add(result);
//            results.clear();
            return;
        }

        for (int i = 0; i < values.length; i++) {
            if (visited[i]) {
                continue;
            }

            visited[i] = true;
            target.add(values[i]);
            createNumberStrings(values, visited, target, results);
            target.remove(target.size() - 1);
            visited[i] = false;
        }
    }
}
```
위 풀이는 시간 초과 발생하는 풀이이며, 종료 조건에서 results를 초기화해서 틀렸던 코드
왜 시간초과가 났는지에 대한 원인 분석이 필요함
```java
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public String solution(int[] numbers) {
        return Arrays.stream(numbers)
            .mapToObj(number -> String.valueOf(number))
            .sorted((s1, s2) -> {
                int origin = Integer.parseInt(s1 + s2);
                int reversed = Integer.parseInt(s2 + s1);
                
                return reversed - origin;
            })
            .collect(Collectors.joining())
            .replaceAll("^0+", "0");
    }
}
```
이 코드가 정답 코드인데, 정렬 기준이 아직 이해가 잘안됨.
```text
**문제점:** 단순히 `Integer.parseInt(s2) - Integer.parseInt(s1)`로 하면 숫자 크기로만 정렬되어서 "가장 큰 수"를 만들 수 없습니다.

**예시로 확인:** 배열 `[3, 30, 34, 5, 9]`가 있다고 할 때

**잘못된 방법 (단순 숫자 크기 정렬):**

- 내림차순 정렬: `[9, 5, 34, 30, 3]`
- 결과: "9534303"

**올바른 방법 (문자열 연결 후 비교):**

- "3"과 "30" 비교: "330" vs "303" → "3"이 앞
- "34"와 "30" 비교: "3430" vs "3034" → "34"가 앞
- "3"과 "34" 비교: "334" vs "343" → "34"가 앞
- 최종 정렬: `[9, 5, 34, 3, 30]`
- 결과: "9534330"

**왜 다른가?**

- 30이 3보다 숫자로는 크지만, 이어붙였을 때는 "330"이 "303"보다 큽니다
- 따라서 "가장 큰 수"를 만들려면 3이 30보다 앞에 와야 합니다

이 문제의 핵심은 **이어붙였을 때의 크기**를 비교하는 것이므로, 반드시 문자열 연결 후 비교해야 합니다.
```

# 2차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers) {
        String result = Arrays.stream(numbers)
            .mapToObj(number -> String.valueOf(number))
            .sorted((s1, s2) -> {
                int first = Integer.parseInt(s1 + s2);
                int second = Integer.parseInt(s2 + s1);
                
                return second - first;
            })
            .collect(Collectors.joining());
        
        return result.startsWith("0") ? "0" : result;
    }
}
```
값이 0으로 시작하는 예외 케이스를 찾지 못해서 틀림

# 3차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers) {
        return Arrays.stream(numbers)
            .mapToObj(number -> String.valueOf(number))
            .sorted((s1, s2) -> {
                int first = Integer.parseInt(s1 + s2);
                int second = Integer.parseInt(s2 + s1);
                
                return second - first;
            })
            .collect(Collectors.joining())
            .replaceAll("^0+", "0");
    }
}
```
0으로 시작하는 예외 케이스에서 헤맸지만 해결함

# 4차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers) {
        return Arrays.stream(numbers)
            .mapToObj(number -> String.valueOf(number))
            .sorted((n1, n2) -> {
                int result1 = Integer.parseInt(n1 + n2);
                int result2 = Integer.parseInt(n2 + n1);
                
                return result2 - result1;
            })
            .collect(Collectors.joining())
            .replaceAll("^0+", "0");
    }
}
```
0이 여러 개의 원소로 들어 있는 엣지 케이스를 찾지 못해 틀림

# 5차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers) {
        return Arrays.stream(numbers)
            .mapToObj(number -> String.valueOf(number))
            .sorted((s1, s2) -> {
                int r1 = Integer.parseInt(s1 + s2);
                int r2 = Integer.parseInt(s2 + s1);
                
                return r2 - r1;
            })
            .collect(Collectors.joining())
            .replaceAll("^0+", "0");
    }
}
```
int배열 타입은 `Asort(T[] a, Comparator<? super T> c)` 메서드를 사용할 수 없음에 주의