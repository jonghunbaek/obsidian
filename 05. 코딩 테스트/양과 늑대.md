---
플랫폼: 프로그래머스
문제 이름: 양과 늑대
알고리즘: 재귀, DFS, 이진트리
tags:
  - 이진탐색
  - 재귀
  - 구현
date: 2025-12-02
aliases:
복습 풀이: 251202(X)
---
# 1차 풀이
```java
// 1. 노드의 최대 개수는 17개이며, 정확성 테스트 인것으로 미뤄봤을 때 완탐으로 구현
// 2. 상세 구현
//  2-1. 파라미터로 받은 info, edges를 Node 객체로 변환하며, 자식-부모 관계 설정
//  2-2. 노드는 재방문이 가능하나 이미 방문한 곳에서 양/늑대를 획득할 수 없음
//  2-3. 재귀 탐색하며, 늑대 마리 수가 양의 마리 수 이상이되면 종료
class Solution {
    
    private int max = 0;
    
    public int solution(int[] info, int[][] edges) {
        // 노드 초기화
        Node[] nodes = new Node[info.length];
        for (int i = 0; i < info.length; i++) {
            nodes[i] = new Node(i, info[i]);
        }
        
        // 자식-부모 노드 관계 초기화
        for (int[] edge : edges) {
            int parentIdx = edge[0];
            int childIdx = edge[1];
            Node parent = nodes[parent];
            Node child = nodes[childIdx];
            
            if (parent.left == null) {
                parent.left = nodes[childIdx];
                parent.left.parent = parent;
                continue;
            } 
            
            if (parent.left.no < child.no) {
                parent.right = child;
                parent.right.parent = parent;
            } else {
                parent.right = parent.left;
                parent.left = child;
                parent.right.parent = parent;
            }
        }
        
        Shepherd boy = new Shepherd();
        boolean[] visited = new boolean[nodes.length];
        dfs(0, 0, 0, nodes, visited);
        
        return max;
    }
    
    private void dfs(int start, int sheepCount, int wolfCount, Node[] nodes, boolean[] visited) {
        if (wolfCount >= sheepCount) {
            max = Math.max(max, sheepCount);
            return;
        }
        if (allVisited(visited)) return;
        
        Node node = nodes[start];
        visited[start] = true;
        if (node.isSheep) {
            dfs(node.left, sheepCount + 1, wolfCount, nodes, visited);
            dfs(node.right, sheepCount + 1, wolfCount, nodes, visited);
        } else {
            dfs(node.left, sheepCount, wolfCount + 1, nodes, visited);
            dfs(node.right, sheepCount, wolfCount + 1, nodes, visited);
        }
        visited[start] = false;
    }
    
    private boolean allVisited(boolean[] visited) {
        for (boolean visit : visited) {
            if (!visit) return false;
        }
        
        return true;
    }
    
    static class Shepherd {
        private int maxSheepCount;
    }
    
    static class Node {
        private int no;
        private boolean isSheep;
        private Node parent;
        private Node left;
        private Node right;
        
        public Node(int no, int isSheep) {
            this.no = no;
            this.isSheep = isSheep == 0 ? true : false;
        }
    }
}
```
이진트리를 어떻게 재귀 탐색해야 할지 감이 안잡힘

내 방식으로 풀었다면 아래와 같이 풀어볼 수 있었음
```java
class Solution {
    private int max = 0;
    
    public int solution(int[] info, int[][] edges) {
        // 노드 초기화
        Node[] nodes = new Node[info.length];
        for (int i = 0; i < info.length; i++) {
            nodes[i] = new Node(i, info[i]);
        }
        
        // 자식-부모 노드 관계 초기화
        for (int[] edge : edges) {
            int parentIdx = edge[0];
            int childIdx = edge[1];
            Node parent = nodes[parentIdx];  // ✅ 수정
            Node child = nodes[childIdx];
            
            if (parent.left == null) {
                parent.left = child;
                child.parent = parent;
            } else {
                parent.right = child;
                child.parent = parent;
            }
        }
        
        boolean[] visited = new boolean[nodes.length];
        dfs(nodes[0], 0, 0, nodes, visited);
        
        return max;
    }
    
    // ✅ 핵심: 현재 노드를 받고, 방문 가능한 모든 노드를 탐색
    private void dfs(Node current, int sheep, int wolf, Node[] nodes, boolean[] visited) {
        // 현재 노드가 null이면 종료
        if (current == null) return;
        
        // 이미 방문한 노드면 양/늑대 획득 안함
        int newSheep = sheep;
        int newWolf = wolf;
        
        if (!visited[current.no]) {
            if (current.isSheep) {
                newSheep++;
            } else {
                newWolf++;
            }
        }
        
        // 늑대가 양보다 많거나 같으면 종료
        if (newWolf >= newSheep) {
            return;
        }
        
        max = Math.max(max, newSheep);
        
        // 현재 노드 방문 체크
        visited[current.no] = true;
        
        // ✅ 핵심: 방문한 모든 노드에서 갈 수 있는 곳을 탐색
        for (int i = 0; i < nodes.length; i++) {
            if (visited[i]) {
                Node visitedNode = nodes[i];
                // 왼쪽 자식이 미방문이면 탐색
                if (visitedNode.left != null && !visited[visitedNode.left.no]) {
                    dfs(visitedNode.left, newSheep, newWolf, nodes, visited);
                }
                // 오른쪽 자식이 미방문이면 탐색
                if (visitedNode.right != null && !visited[visitedNode.right.no]) {
                    dfs(visitedNode.right, newSheep, newWolf, nodes, visited);
                }
            }
        }
        
        // 백트래킹
        visited[current.no] = false;
    }
    
    static class Node {
        private int no;
        private boolean isSheep;
        private Node parent;
        private Node left;
        private Node right;
        
        public Node(int no, int isSheep) {
            this.no = no;
            this.isSheep = isSheep == 0;
        }
    }
}
```
문제를 처음 확인했을 땐, 부모 노드로 돌아가야만 가능할거라 착각한 것이 문제 풀이 실패의 원인
이 문제는 "물리적으로 트리를 따라 이동"하는 게 아니라:

1. **현재까지 방문한 노드들의 집합**을 유지
2. 그 집합의 **모든 노드의 자식들 중 미방문 노드**가 다음 선택지
3. 그 중 하나를 선택해서 방문

→ 마치 "방문한 영역이 확장되는" 개념