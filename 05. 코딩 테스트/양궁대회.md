---
플랫폼: 프로그래머스
문제 이름: 양궁대회
알고리즘:
tags:
date: 2025-11-20
aliases:
복습 풀이: 251120(O)
---
# 1차 풀이
```java
// 1. 구현 
// 3. 첫째, 라이언이 이길 수 있는 최대 점수 구하기(점수가 같다면 진것)
//  - 비용 구하기 : 10점부터 차례대로 화살을 소모하며 계산, 그 다음 9점부터, 그 다음 8점부터
//  - 이 과정으로 최댓값을 구하기
// 4. 가장 큰 차이로 이길 수 있는 점수 경우의 수가 여러개라면 비교하여 우선 순위가리기
// 5. 결과 반환
// 6. 최댓값을 구한다 한들, 어떤 점수에 맞췄는지 기록은?
import java.util.*;
import java.util.stream.*;

class Solution {
    public int[] solution(int n, int[] info) {
        Map<Integer, List<int[]>> records = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int pointIdx = i;
            int arrow = n;
            int[] lion = new int[11];
            int lionPoint = 0;
            int apeachPoint = 0;
            while(arrow > 0) {
                int shots = info[pointIdx] + 1;
                if (arrow - shots < 0) {
                    apeachPoint += 10 - pointIdx;
                } else {
                    if (pointIdx == info.length - 1) {
                        shots = arrow;
                    }
                    
                    lion[pointIdx] = shots;
                    lionPoint += 10 - pointIdx;    
                }
                
                arrow -= shots;
                pointIdx++;
            }
            
            if (lionPoint == apeachPoint) continue;
            
            List<int[]> record = records.getOrDefault(lionPoint, new ArrayList<>());
            record.add(Arrays.copyOfRange(lion, 0, lion.length));
            records.put(lionPoint, record);
        }
        
        records.entrySet().stream()
            .forEach(entry -> System.out.println(entry.getKey() + ", " + entry.getValue().size()));
        if (records.size() == 0) return new int[] {-1};
        
        int max = records.keySet().stream()
            .mapToInt(Integer::intValue)
            .max()
            .orElse(0);
        if (max == 0) return new int[] {-1};
        List<int[]> record = records.get(max);
        List<int[]> result = record.stream()
            .sorted((r1, r2) -> sortBy(r1, r2))
            .collect(Collectors.toList());
        
        return result.get(0);
    }
    
    private int sortBy(int[] r1, int[] r2) {
        int length = r1.length - 1;
        while (length > -1) {
            if (r1[length] != r2[length]) {
                return r2[length] - r1[length];
            }
            length--;
        }
        
        return 1;
    }
}
```
약 55분동안 풀었지만 결국 못풂
- 단순 구현이라 생각했는데 접근 방식이 잘못됐는지?
- 지문 읽고 이해하는 시간만 20분 정도 걸린듯