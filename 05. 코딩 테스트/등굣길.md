---
플랫폼: 프로그래머스
문제 이름: 등굣길
알고리즘: dp
tags:
  - dp
date: 2025-08-26
aliases:
  - dp
복습 풀이: 250826(X), 250901(X), 250907(X), 250913(O), 250920(O), 251030(X)
---
# 1차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int mod = 1000000007;
        int[][] dp = new int[n + 1][m + 1];
        dp[1][1] = 1;
        for (int[] puddle : puddles) {
            dp[puddle[0]][puddle[1]] = -1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (dp[i][j] == -1) {
                    continue;
                }
                
                
                if(dp[i - 1][j] > 0) {
                    dp[i][j] += dp[i - 1][j] % mod;
                }
                
                if(dp[i][j - 1] > 0) {
                    dp[i][j] += dp[i][j - 1] % mod;
                }
            }
        }
        
        return dp[n][m];
    }
}
```

```java
public class Solution {
    private final int[][] mem = new int[101][101];

    private int count(int x, int y, int w, int h, boolean[][] isPuddle) {
        if (x > w || y > h) return 0;
        if (isPuddle[y][x]) return 0;

        if (mem[x][y] != -1) return mem[x][y];
        if (x == w && y == h) return 1;

        int total = count(x + 1, y, w, h, isPuddle)
                + count(x, y + 1, w, h, isPuddle);
        return mem[x][y] = total % 1000000007;
    }

    public int solution(int m, int n, int[][] puddles) {
        for (int[] row : mem) {
            Arrays.fill(row, -1);
        }

        boolean[][] isPuddle = new boolean[n + 1][m + 1];
        for (int[] p : puddles) {
            isPuddle[p[1]][p[0]] = true;
        }

        return count(1, 1, m, n, isPuddle);
    }
}
```
단순히 최단 거리를 구하기라면 어렵지 않았겠지만 최단 거리로 갈 수 있는 경우의 수를 찾는 문제라 어려웠음
첫 번째 풀이는 상향식, 두 번째 풀이는 하향식 풀이다.
여전히 상향식 풀이가 쉬운것을 보면 아직 재귀에 대한 이해도가 많이 떨어지는 듯하다.

# 2차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int mod = 1000000007;
        // 1. 배열 크기를 [n][m]으로 변경
        int[][] dp = new int[n][m];

        // 2. 웅덩이 좌표를 0-based 인덱스에 맞게 변환하여 표시
        // 문제에서 웅덩이 좌표는 [열, 행] 순서이므로 dp[행-1][열-1]에 표시합니다.
        for (int[] puddle : puddles) {
            dp[puddle[1] - 1][puddle[0] - 1] = -1; 
        }

        // 3. 시작점을 (0, 0)으로 설정
        dp[0][0] = 1;

        // 4. 반복문을 0부터 n-1, m-1까지 순회
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 현재 위치가 웅덩이면 0으로 만들고 건너뜀
                if (dp[i][j] == -1) {
                    dp[i][j] = 0;
                    continue;
                }

                // 5. 위쪽과 왼쪽에서 오는 경우의 수를 더함
                // i > 0, j > 0 조건을 추가하여 ArrayIndexOutOfBoundsException 방지
                if (i > 0) {
                    dp[i][j] += dp[i - 1][j] % mod;
                }
                
                if (j > 0) {
                    dp[i][j] += dp[i][j - 1] % mod;
                }
            }
        }
        
        // 6. 최종 결과는 dp[n-1][m-1]
        return dp[n - 1][m - 1] % mod;
    }
}
```
배열을 int\[n]\[m]으로 초기화해서 작업하려니 분기 처리를 어떻게 해야 하나 헷갈려서 틀림

# 3차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n + 1][m + 1];
        for (int[] puddle : puddles) {
            int y = puddle[1];
            int x = puddle[0];
            map[y][x] = -1;
        }
        
        map[1][1] = 1;
        for (int i = 1; i < map.length; i++) {
            for (int j = 1; j < map[i].length; j++) {
                if (map[i][j] == -1) {
                    continue;
                }
                
                if (map[i - 1][j] == -1 && map[i][j - 1] == -1) {
                    continue;
                }
                
                if (map[i - 1][j] == -1) {
                    map[i][j] += map[i][j - 1];
                    continue;
                } 
                
                if (map[i][j - 1] == -1) {
                    map[i][j] += map[i - 1][j];
                    continue;
                }
                
                map[i][j] += map[i - 1][j] + map[i][j - 1];
            }
        }
        
        return map[n][m];
    }
}
```
mod연산을 빼먹어 효율성 테스트에서 모두 틀림
정수 삼각형과 마찬가지로 하향식으로 풀어보기

# 4차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n][m];
        for (int[] puddle : puddles) {
            map[puddle[1] - 1][puddle[0] - 1] = -1;
        }
        
        return dfs(0, 0, m, n, map);
    }
    
    private int dfs(int x, int y, int m, int n, int[][] map) {
        if (x == m - 1 && y == n - 1) {
            map[y][x] = 1;
            return map[y][x];
        }
        
        if (x > m - 1 || y > n - 1) {
            return 0;
        }
        
        if (map[y][x] == -1) {
            return 0;
        }
        
        if (map[y][x] != 0) {
            return map[y][x];
        }
        
        int total = dfs(x + 1, y, m, n, map) + dfs(x, y + 1, m, n, map);
        
        return map[y][x] = total % 1000000007;
    }
}
```
모듈로 연산을 자꾸 빼먹어서 틀림
이번엔 하향식으로 풀어봄 다음엔 상향식, 하향식 모두 접근해서 풀어보기

# 5차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n][m];
        for (int[] puddle : puddles) {
            map[puddle[1] - 1][puddle[0] - 1] = -1;
        }
        
        return dfs(0, 0, map, m, n);
    }
    
    private int dfs(int x, int y, int[][] map, int m, int n) {
        if (x == m - 1 && y == n - 1) {
            map[y][x] = 1;
            return map[y][x];
        }
        
        if (x >= m || y >= n) {
            return 0;
        }
        
        if (map[y][x] == -1) {
            return 0;
        }
        
        if (map[y][x] != 0) {
            return map[y][x];
        }
        
        
        map[y][x] = (dfs(x + 1, y, map, m, n) + dfs(x, y + 1, map, m, n)) % 1000000007;
        
        return map[y][x];
    }
}
```
정답 자체를 맞추는 것은 어렵지 않음
정수 삼각형과 마찬가지로 dfs를 void타입으로 수행할 때 막힘
다만 마지막 줄에 배열 범위 검사가 필요한 것을 알기 때문에 다음엔 이 방식으로 풀어보기
```java
class Solution {     
	public int solution(int m, int n, int[][] puddles) {         
		int[][] map = new int[n][m];         
		for (int[] puddle : puddles) {             
			map[puddle[1] - 1][puddle[0] - 1] = -1;
		}                  
		dfs(0, 0, map, m, n);         
		return map[0][0];     
	}          
	
	private void dfs(int x, int y, int[][] map, int m, int n) {
		if (x == m - 1 && y == n - 1) {
			map[y][x] = 1;    
			return;
		}                  
		
		if (x >= m || y >= n) {             
			return;         
		}                  
		
		if (map[y][x] != 0) {
			return;         
		}                  
		
		dfs(x + 1, y, map, m, n);
		dfs(x, y + 1, map, m, n);         
		map[y][x] += map[y + 1][x] + map[y][x + 1];     
	} 
}
```

# 6차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n][m];
        for (int[] puddle : puddles) {
            map[puddle[1] - 1][puddle[0] - 1] = -1;
        }
        
        return dfs(0, 0, map);
    }
    
    private int dfs(int y, int x, int[][] map) {
        if (y >= map.length || x >= map[0].length) {
            return 0;
        }
        
        if (y == map.length - 1 && x == map[0].length - 1) {
            map[y][x] = 1;
            return 1;
        }
        
        if (map[y][x] == -1) {
            return 0;
        }
        
        if (map[y][x] != 0) {
            return map[y][x];
        }
        
        map[y][x] += (dfs(y + 1, x, map) + dfs(y, x + 1, map)) % 1000000007;
        return map[y][x];
    }
}
```

# 7차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int[][] map = new int[n][m];
        for (int[] puddle : puddles) {
            map[puddle[1] - 1][puddle[0] - 1] = -1;
        }
        
        countAllRouting(0, 0, map);
        
        return map[0][0];
    }
    
    private void countAllRouting(int x, int y, int[][] map) {
        if (x >= map[0].length || y >= map.length) return;
        if (map[y][x] == -1) return;
        if (map[y][x] != 0) return;
        if (x == map[0].length - 1 && y == map.length - 1) {
            map[y][x] = 1;
            return;
        }
        
        countAllRouting(x + 1, y, map);
        countAllRouting(x, y + 1, map);
        
        int right = x + 1 >= map[0].length ? 0 : map[y][x + 1];
        int bottom = y + 1 >= map.length ? 0 : map[y + 1][x];
        map[y][x] += right + bottom;
    }
}
```
- 재귀 함수에서 right, bottom을 구할 때 물 웅덩이(-1)을 포함하여 계산함
- 모듈러 연산 누락