---
플랫폼: 프로그래머스
알고리즘: 완전탐색, 백트래킹
tags:
  - 완전탐색
  - DFS
  - 백트래킹
date: 2026-02-20
복습 풀이: 260220(X)
---
# 1차 풀이
```java
// 숫자 야구와 비슷한 문제. 어떤 식으로 접근해야 할지 감이 안잡힘
// 완전 탐색으로 가능할 듯? 
// 조합이므로 30C5 -> 약 14만가지 * q의 길이(최대 10) -> 140만으로 충분히 가능(각 요소 탐색에 *5를 해도 충분)
// 1. 1 ~ 30의 모든 숫자를 5자리에 오름 차순으로 배치한 모든 경우의 수 구하기
// 2. 각 경우의 수를 q에서 순회하며 정답 가능여부 판별
import java.util.*;

class Solution {
    public int solution(int n, int[][] q, int[] ans) {
        Set<Set<Integer>> passwords = findAllPasswordCase(n);
        int answer = 0;
        for (Set<Integer> password : passwords) {
            boolean isEnable = true;
            for (int i = 0; i < q.length; i++) {
                int count = 0;
                for (int j = 0; j < 5; j++) {
                    if (password.contains(q[i][j])) count++;
                }
                
                if (count != ans[i]) isEnable = false;
            }
            
            if (isEnable) answer++;
        }
        
        return answer;
    }
    
    private Set<Set<Integer>> findAllPasswordCase(int n) {
        Set<Set<Integer>> results = new HashSet<>();
        dfs(1, n, new HashSet<>(), results);
        
        return results;
    }
    
    private void dfs(int value, int n, Set<Integer> result, Set<Set<Integer>> results) {
        if (result.size() == 5) {
            results.add(new HashSet<>(result));
            return;
        }
        
        for (int i = value; i <= n; i++)  {
            result.add(i);
            dfs(i + 1, n, result, results);
            result.remove(i);
        }
            
    }    
}
```
최초에 계산한 시간 복잡도는 다음과 같음
- 5자리의 숫자에 1 ~ 30까지의 숫자가 순서 상관없이 존재(조합 - 30C5 = 약 14만)
- 해당 경우의 수를 기반으로 q를 순회 14만 x 10 = 140만
- q의 각 원소는 5개의 숫자를 가지고, set의 contains를 쓰므로 140 x 5 = 700만
그런데 실제 결과는 시간 초과

### 원인 분석 결과
- **`Set<Set<Integer>>`의 살인적인 오버헤드:**
    14만 개가 넘는 조합을 미리 다 구해두기 위해 `HashSet` 인스턴스를 14만 번 생성하셨습니다. 게다가 이를 다시 `Set`에 넣을 때, Java는 내부적으로 중복 체크를 위해 들어가는 모든 `Set`의 `hashCode()`를 계산하고 `equals()`를 호출합니다. 이 과정에서 엄청난 메모리 할당과 가비지 컬렉션(GC)이 발생하며 시간이 폭증합니다.
- **Boxing / Unboxing의 비용:**
    기본 타입인 `int` 대신 객체 타입인 `Integer`를 사용하셨습니다. 14만 가지의 경우의 수를 만들고 검사하는 과정에서 수백만 번의 `int` $\leftrightarrow$ `Integer` 변환(Boxing/Unboxing)이 일어나 성능을 크게 떨어뜨립니다.
- **불필요한 전체 저장 (메모리 낭비):**
    조합을 미리 전부 구해서 `Set`에 저장해둘 필요가 없습니다. DFS를 돌면서 5개의 숫자가 완성되었을 때 **그 즉시 정답인지 검사**하고 넘어가면, 메모리에는 단 1개의 배열만 존재해도 됩니다.
- **조기 종료(Early Exit) 부재:**
    조건이 틀렸다는 것을 확인(`isEnable = false`)한 후에도 `break`를 걸지 않아, 나머지 `q`의 조건들을 불필요하게 끝까지 순회하고 있습니다.

접근 방향 자체는 적합했고, 시간 복잡도 계산 또한 타당했음
```java
class Solution {
    public int solution(int n, int[][] q, int[] ans) {
        return dfs(1, 0, n, q, ans, new int[5]);
    }
    
    private int dfs(int value, int depth, int n, int[][] q, int[] ans, int[] result) {
        if (depth == 5) {
            if (isValid(q, ans, result)) return 1;
            return 0;
        }
        
        int count = 0;
        for (int i = value; i <= n; i++) {
            result[depth] = i;
            count += dfs(i + 1, depth + 1, n, q, ans, result);
        }
        
        return count;
    }
    
    private boolean isValid(int[][] q, int[] ans, int[] result) {
        for (int i = 0; i < q.length; i++) {
            int count = 0;
            for (int r : result) {
                for (int val : q[i]) {
                    if (val == r) count++;
                }
            }
            
            if (ans[i] != count) return false;
        }
        
        return true;
    }
}
```