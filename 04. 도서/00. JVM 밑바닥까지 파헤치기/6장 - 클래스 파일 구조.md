JVM이 다양한 플랫폼을 지원하고, 모든 VM이 동일한 프로그램 저장 형식을 지원한다는 것이 '플랫폼 독립성'의 핵심이다.
즉, VM과 바이트 코드 저장 형식이 여러 플랫폼에 구애 받지 않게 만드는 핵심이다.

자바 기술은 설계 초기부터 VM이 다른 언어를 실행할 가능성을 염두에 뒀다. 
그렇기에 JVM은 자바를 포함한 어떠한 언어에도 종속되지 않는다.
'클래스 파일'이란 특정한 바이너리 파일 형식에만 의존할 뿐이다.  
또한 클래스 파일을 이루는 바이트 코드 형식은 튜링 완전하므로 JVM에서 어떠한 언어도 표현할 수 있도록 보장한다.
더불어 자바 언어에서 효과적으로 표현하지 못하는 개념도 바이트 코드에서는 효과적으로 표현할 수 있다. 

# 1. 개요
자바 기술의 하위 호환성이 잘 유지되는 가장 큰 이유는 **안정적인 클래스 파일 구조**다. 
이번 장에서 설명할 클래스 파일 구조 대부분은 자바 가상 머신 명세 1판(1997) 내용 그대로다. (기본 구조는 거의 그대로다.)

클래스 파일은 동적으로 생성되어 클래스 로더에 직접 제공할 수도 있기 때문에 꼭 디스크에 파일 형태로 저장될 필요가 없다.
그래서 이번 장에서 말하는 클래스 파일 '구조'는 사실 클래스 파일 '형식'이라고 표현하는 것이 맞다.

![[JVM 6장 - 클래스 파일 구조.jpg|500]]
클래스 파일은 바이트를 하나의 단위로 하는 이진 스트림 집합체다. 
1바이트가 넘는 데이터는 바이트 단위로 분할 되며, 큰 단위의 바이트가 먼저 저장되는 빅 엔디언 방식으로 표현된다.
클래스 파일에 데이터를 저장할 때 의사 구조를 이용하는데, 이 구조엔 '부호 없는 숫자', '테이블'이라는 두 가지 데이터 타입만 존재한다.
- **부호 없는 숫자** 
	- 기본 데이터 타입을 표현하며, u1/u2/u4/u8이 있다. 각각 1, 2, 4, 8바이트를 의미한다.
	- 숫자, 인덱스 참조, 수량 값을 기술하거나 UTF-8로 인코딩된 문자열 값을 구성
- **테이블**
	- 여러 개의 부호 없는 숫자나 또 다른 테이블로 구성된 복합 데이터 타입을 표현
	- 이름은 관례적으로 \_info로 끝남
같은 타입의 데이터 여러 개를 표현할 때 그 개수가 정해져 있지 않다면 개수를 알려 주는 타입이 바로 앞에 등장한다.(* \_count  형태)
위 그림에 나온 데이터 항목은 **데이터가 저장되는 바이트 순서, 각 바이트의 의미, 길이, 순서가 모두 엄격하게 제한되며 변경될 수 없다**.

>[!NOTE]
>**빅 엔디언 방식 vs 리틀 엔디언 방식**
>빅 엔디언 방식은 큰 단위의 바이트가 먼저 저장되는 것을 의미한다. 때문에 낮은 메모리 주소에 저장된다. 즉, 가장 중요한 바이트를 먼저 저장하는 방식이다.
>이 방식은 사람이 숫자를 읽는 방식과 유사하며, 바이트를 배열처럼 취급할 때 적합하다.
>리틀 엔디언 방식은 빅 엔디언 방식의 반대며, 물리적으로 데이터를 조작하거나 산술 연산을 수행할 때 유리하다. 

# 2. 매직 넘버와 클래스 파일의 버전
모든 클래스 파일의 처음 4바이트는 **매직 넘버로 시작**한다. 이는 **VM이 허용하는 클래스 파일인지를 검증하는 용도**다.
파일 확장자는 사용자에 의해 변경될 수 있지만 매직넘버는 그렇지 않아 많은 곳에서 사용된다.(JPEG, GIF 등)

// TODO :: 테스트 용 클래스와 HxD로 바이트 코드 확인해보기

매직 넘버 다음 4바이트는 클래스 파일의 버전 번호다. 5, 6번째는 마이너 버전을, 7, 8번째는 메이저 버전을 의미한다. 
상위 버전 JDK는 하위 버전을 인식할 수 있지만 그 반대는 안된다.
JDK 1.2부터는 마이너 버전을 사용하지 않는다. 자세한 버전 정보는 294p를 확인하자. 

# 3. 상수 풀
버전 번호 다음은 상수 풀 항목이다. **상수 풀은 클래스 파일의 자원 창고**라 할 수 있다. 때문에 공간이 대체로 가장 크다.
상수의 수는 고정적이지 않으므로 개수를 표현하기 위한 u2 타입의 데이터가 필요하다. 관례상 이 개수를 셀 때는 1부터 시작한다.(상수 풀만 해당)
**0번째를 비운 이유는 상수 풀 인덱스를 가리키는 데이터에서 '상수 풀 항목을 참조하지 않음'을 표현**해야 하기 때문이다.

// TODO :: 테스트 용 클래스와 HxD로 바이트 코드 확인해보기

상수 풀에 담기는 상수 유형은 리터럴과 심벌 참조 두 가지다. 
심벌 참조는 컴파일 관련 개념으로 아래와 같이 세분화할 수 있다.
- 모듈에서 export하거나 import하는 패키지
- 클래스와 인터페이스의 완전한 이름
- 필드 이름과 서술자
- 메서드 이름과 서술자
- 메서드 핸들과 메서드 타입
- 동적으로 계산되는 호출 사이트와 동적으로 계산되는 상수

// TODO :: 297p 상수 풀의 항목 타입 사진 저장
상수 풀 안의 상수 각각이 모두 테이블이다. 초기엔 11가지였으나 JDK21 기준 17가지로 늘어났다. 
각 타입의 테이블들은 공통적으로 u1 타입의 플래그 비트로 시작하며, 현재 상수가 속한 타입을 나타낸다. 

상수 풀이 가장 복잡한 데이터인 이유는 17가지 각각의 데이터 구조가 독립적이기 때문이다. 



>[!NOTE]
>**C/C++과 달리 Java에선 컴파일 시 링크 단계가 없다?**
>링크 단계는 함수와 같은 개체들을 메모리에 배치하는 것을 뜻한다. 즉, C/C++은 컴파일시 모든 함수와 변수의 메모리 위치가 결정된다.
>Java는 클래스를 로드할 때 동적으로 링크를 한다. 그렇기에 **Java의 필드, 메서드에 대한 메모리 구조는 클래스 파일에 저장되지 않는다.**



