---
플랫폼: 프로그래머스
알고리즘: dp
tags:
  - dp
date: 2026-02-18
복습 풀이: 260218(X)
---
# 1차 풀이
```java
// 완전탐색
// 1. a가 잡히지 않을 최소 흔적 개수를 파악하는 것이 핵심
// 2. 배열 크기가 길지 않으니 재귀로 탐색
// 3. a가 1개 훔친것부터 info.length - 1개 훔친것까지 모두 더하며 b가 통과하는 최소 흔적 개수 탐색
// 4. int find(int idx, List<Integer> sum, int count, int[][] info, int n, int m)
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        int answer = Integer.MAX_VALUE;
        for (int i = 0; i <= info.length; i++) {
            answer = Math.min(answer, find(0, new ArrayList<>(), i, info, n, m));
        }
        
        return answer == Integer.MAX_VALUE ? -1 : answer;
    }
    
    private int find(int idx, List<Integer> values, int count, int[][] info, int n, int m) {
        if (values.size() == count) {
            int aCount = values.stream()
                .mapToInt(value -> info[value][0])
                .sum();
            int bCount = 0;
            for (int i = 0; i < info.length; i++) {
                if (values.contains(i)) continue;
                bCount += info[i][1];
            }
            
            if (aCount < n && bCount < m) return aCount;
            return Integer.MAX_VALUE;
        }
        
        int min = Integer.MAX_VALUE;
        for (int i = idx; i < info.length; i++) {
            values.add(i);
            min = Math.min(min, find(i + 1, values, count, info, n, m));
            values.remove(values.size() - 1);
        }
        
        return min;
    }
}
```
최초에 완전탐색으로 접근했으나 시간초과 발생
- info의 길이가 최대 40
- 0개부터 조합 시
	- 0인 경우 1번
	- 1인 경우 40번
	- 2인 경우 40 x 39
	- ... 40인 경우 40! 이되므로 시간 초과임

그렇다고 아래와 같이 정렬, 그리디 방식은 애초에 접근 방식 자체가 잘못됐음
```java
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        Arrays.sort(info, (i1, i2) -> {
            if (i1[0] == i2[0]) return i1[1] - i2[1];
            return i1[0] - i2[0];
        });
        
        int answer = Integer.MAX_VALUE;
        for (int i = 0; i <= info.length; i++) {
            answer = Math.min(answer, count(i, info, n, m));
        }
        
        return anwer == Initeger.MAX_VALUE ? -1 : answer;
    }
    
    private int count(int limit, int[][] info, int n, int m) {
        int aCount = 0;
        for (int i = 0; i < limit; i++) {
            aCount += info[i][0];
        }
        
        int bCount = 0;
        for (int i = limit; i < info.length; i++) {
            bCount += info[i][1];
        }
        
        if (aCount < n && bCount < m) return aCount;
        return Integer.MAX_VALUE;
    }
}
```