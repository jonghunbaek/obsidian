# 1. 스레드 안정성
일반적으로 스레드 안전성의 정의에 대해 다음과 같이 설명한다.
> 어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있다면 그 객체는 스레드 안전하다.

하지만 이는 실제로 적용하는데 필요한 정보가 빠져있다. 좀 더 자세히 정의하자면 다음과 같다.
> 여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서
> 객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면, "그 객체는 스레드 안전하다"라고 말한다.
> - 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 없다.
> - 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.

이러한 정의와 함께 자바 언어의 스레드 안정성에 대해 알아보자.
## 1.1 자바의 스레드 안정성
스레드의 안정성은 이분법적 사고에서 벗어나 아래처럼 안전함의 정도에 따라 다섯 단계로 구분할 수 있다.
- **불변**
	- 불변 객체는 객체 자체의 메서드 구현과 호출자 모두에서 아무런 안전장치 없이도 스레드 안전
- **절대적 스레드 안전**
	- 앞선 정의에 따르면 실제로 절대적 스레드 안전을 구현하는 것은 매우 많은 비용이 들거나 비현실적
	- 자바 API에서 스레드 안전하다고 표시된 클래스 대부분이 절대적 스레드 안전을 의미하지 않음
- **조건부 스레드 안전**
	- 일반적으로 스레드 안전하다고 말할 때의 안전 수준을 의미
	- 단일한 작업은 스레드 안전하게 수행되나, 특정 순서로 연달아 호출하는 작업에선 호출자에서 추가 동기화 작업이 필요
- **스레드 호환**
	- 객체 자체는 스레드 안전하지 않으나 호출자가 적절히 조치하면 스레드 안전하게 사용할 수도 있음 
- **스레드 적대적**
	- 호출자가 동기화 조치를 취해도 멀티스레드 환경에서 안전하게 사용할 수 없음

## 1.2 스레드 안전성의 구현
### 상호 배제 동기화
자바에서 상호 배제 동기화를 구현하는 가장 기본적인 수단은 syncronized 키워드다.
syncronized를 통해 락을 얻으면 다른 스레드는 락을 얻은 스레드가 락을 해제할 때까지 블록된다. 
즉, 락을 해제할 때까지 다른 스레드의 진입을 무조건 차단한다. 그러므로 락 소유 스레드가 락을 해제하도록 강제할 방법이 없다.
이 과정에서 스레드를 정지하거나 깨워야 하는데, Java 스레드는 커널 스레드와 매핑된 스레드이기 때문에 비용이 많이 발생한다. 

이러한 문제에 대한 해결책으로 JDK 5부터 Lock인터페이스가 추가되었다.
Lock 인터페이스는 논블록 구조의 상호배제 동기화를 구현하며 대표적인 구현체는 ReentrantLock이 있다.
ReentrantLock은 syncronized와 비슷하지만 몇 가지 더 진보된 기능을 제공한다.
- **대기 중 인터럽트**
	- 락을 소유한 스레드가 오랜시간 락을 해제하지 않을 경우 대기 중인 다른 스레드들이 락을 포기하고 다른 작업을 수행
- **페어 락**
	- 락 획득을 시도한 시간 순서대로 락을 획득
	- 기본은 언페어 락이며, 페어락을 사용할 경우 성능이 급격히 떨어져 처리량에 악영향을 줄 수 있음
- **둘 이상의 조건 지정**
	- 동시에 여러 개의 Condition 객체와 연결해 락 조건을 지정할 수 있음

*** 주의 ***
이상의 이야기는 JDK5까지에서 가능한 이야기다. JDK6부턴 syncronized의 성능이 향상되어 큰 차이가 존재하지 않는다.
때문에 가능하다면 syncronize를 쓰는 것이 다음과 같은 이유로 유리할 수 있다.
- 자바 구문 수준의 동기화 수단이며 매우 간결하고 명확
- Lock은 finally 블록에서 직접 해제해야 하지만 syncronized는 JVM이 예외 발생 시 락 해제를 보장
- 동기화 최적화는 JVM에 맡기는 편이 유리함
### 논블로킹 동기화
JVM에서 상호 배제 동기화를 위해 대부분 블로킹 동기화 방식을 사용한다.
때문에 컨텍스트 스위칭이 일어나 많은 비용을 사용하게 된다.
그리고 이를 문제 해결 방법이라는 관점에서 볼 때, 비관적 동시성 전략이라고 볼 수 있다.

하드웨어 기술이 발전하며 충돌 감지를 기반으로 작동하는 낙관적 동시성 전략이 등장했다.
스레드 경합이 발생하더라도 작업을 수행하고, 만약 충돌이 감지되면 보완 조치를 취한다.
일반적인 보완 조치는 경합하는 공유 데이터가 없을 때까지 계속 재시도하는 것이다. 
이를 논블로킹 동기화라고 부른다. 

이러한 낙관적 동시성 전략엔 하드웨어 명령어 집합의 발전이 필수였다.
작업 진행과 충돌 감지라는 두 단계를 원자적으로 수행해야 하기 때문이다. 
대표적인 예시는 다음과 같다.
- **TAS(Test-and-Set) : 검사와 지정**
- **FAA(Fetch-and-Add) : 페치와 증가**
- **Swap : 교환**
- **CAS(Compare-and-Swap) : 비교와 교환**
- **LL/SC(Load-Linked/Store-Condition) : 적재와 저장**
Java에선 CAS 연산을 이용해 낙관적 동시성 전략을 구현한다.
>[!CAS 연산의 한계]
>CAS 연산이 분명 단순하고 효율적이라는 큰 장점을 가지지만 그 한계 또한 명확하다.
>대표적으로 ABA문제가 존재하고, 경합이 심할 경우 CPU를 낭비하며 무한 반복될 수 있다.
>또한 단일 변수에만 사용 가능하기 때문에 모든 상호 배제 동기화 시나리오를 대신할 수 없다.

### 동기화가 필요 없는 메커니즘
스레드 안정성을 구현하기 위해 반드시 동기화 작업을 할 필요는 없다. 다음은 그 대표적인 예시다.
- **재진입 코드**
	- 실행 중간에 아무 때나 끼어들어 다른 코드를 수행하고 와도 상관없는 코드
	- 전역 변수나 공유 자원에 접근하지 않아 독립적인 실행 흐름을 가짐
	- 순수 함수에 가까운 코드
- **스레드 로컬 저장소**
# 2. 락 최적화
## 2.1 스핀 락과 적응형 스핀
수 많은 애플리케이션을 분석한 결과, 공유 데이터를 동기화하기 위해 락을 획득하고 해제하는 시간이 매우 짧았다.
이 짧은 시간을 위해 스레드를 블록했다가 다시 깨우는 것은 무의미한 행동이다.
때문에 **대기 상태에 들어가지 않고 락이 해제되는지 다른 코어에서 반복적으로 확인하는 해결책이 나왔는데 이것이 스핀락**이다. 

이 해결법은 스레드 전환 부하는 없앨 수 있지만 프로세서 시간을 그만큼 소비해야 하는 부작용이 존재한다.
이 문제를 방지하기 위해 접근 횟수를 제한할 수 있다.
여기서 더 나아가 같은 락의 이전 스핀 시간과 락 소유자의 상태에 따라 스핀락 횟수, 시간이 결정되는 적응형 스핀락이 나왔다. 

## 2.2 락 제거
락 제거는 특정 코드 조각에서 런타임에 데이터 경합이 일어나지 않는다고 판단되면 JIT 컴파일러가 락을 제거하는 최적화 기법이다.
여기선 앞서 배운 탈출 분석을 근거로 한다. 
**그런데 사용자가 실제로 동기화하기 위한 보완적인 코드를 작성하지 않았음에도 탈출 분석이 필요한 이유는 뭘까?**
바로 JVM 자체에서 추가하는 동기화 장치가 매우 많기 때문이다.

## 2.3 락 범위 확장
반복문 내부에서 매번 락을 획득하고 해제하는 작업이 일어난다면 그만큼 많은 부하가 생길 것이다. 
일련의 단순 작업에서 반복적으로 락을 획득하고 해제한다면 락의 범위를 넓혀 락 획득/해제 빈도를 낮춰 최적화할 수 있다. 

## 2.4 경량 락
경량 락이란 운영체제의 뮤텍스를 사용한 중량 락보다 성능 저하를 줄인 락을 뜻한다. 
Java에서 경량 락은 컴파일된 객체의 헤더와 연관이 깊다.

객체의 헤더는 다음과 같이 크게 두 부분으로 나뉜다.
- **마크 워드**(경량, 편향 락의 핵심)
- **데이터 타입을 가리키는 포인터**

마크 워드에서 마지막 2비트는 다음 표처럼 락 플래그를 저장하게 된다.
![[JVM 13장 - 객체 헤더의 마크 워드.jpeg|500]]

### 경량 락의 작동 방식
코드가 동기화 블록에 진입하려 할 때 락 객체가 잠겨 있지 않다면(01) 가장 먼저 현재 스레드의 스택 프레임에 락 레코드를 생성한다.
이 때, 락 레코드는 소유한 락 객체를 저장하는 용도의 공간이다. 
이후 CAS 연산으로 락 객체의 마크 워드를 락 레코드를 가리키는 포인터로 바꾼다. 
변경에 성공한다면 락을 획득한 것이고, 그렇지 않다면 경합 중인 스레드가 최소 하나는 더 있다는 뜻이 된다.
변경과 함게 마크 워드의 락 플래는 00으로 변경되어 객체가 락 상태임을 표시한다.