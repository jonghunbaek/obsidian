---
플랫폼: 프로그래머스
문제 이름: 문자열 내 마음대로 정렬하기
알고리즘: 정렬
tags:
  - 정렬
date: 2025-08-06
aliases:
  - 정렬
복습 풀이: 250806(O)
---
# 1차 풀이
```java
import java.util.*;

class Solution {
    public String[] solution(String[] strings, int n) {
        return Arrays.stream(strings)
                .sorted((o1, o2) -> compare(n, o1, o2))
                .toArray(String[]::new);
    }

    private int compare(int n, String o1, String o2) {
        if (o1.charAt(n) == o2.charAt(n)) {
            return o1.compareTo(o2);
        }

        return o1.charAt(n) - o2.charAt(n);
    }
}
```
Java 메서드를 이용해 더 간단하게 구현 가능

다만 구현 과정에서 이해되지 않는 컴파일 오류가 존재했음
```java
// 정상 
Arrays.sort(strings, Comparator.comparing((String s) -> s.charAt(n))  
        .thenComparing(Comparator.naturalOrder()));  

// 정상
Arrays.sort(strings, Comparator.comparing(s -> s.charAt(n));

// 컴파일 오류
Arrays.sort(strings, Comparator.comparing(s -> s.charAt(n))  
        .thenComparing(Comparator.naturalOrder()));

```
첫 번째, 두 번째 코드의 경우 s가 String으로 정상 인식되지만 세 번째 코드에서 s는 Object로 인식된다.
이에 관한 내용은 아래와 같음
```text
1. **단독 사용 시:**
Arrays.sort(strings, Comparator.comparing(s -> s.charAt(n)));
```

- `Arrays.sort(String[], Comparator<String>)`의 시그니처를 보고
- 컴파일러가 `Comparator.comparing`의 반환 타입이 `Comparator<String>`이어야 함을 알아냄
- 따라서 람다의 `s`를 `String`으로 추론

2. **체이닝 사용 시:**
Comparator.comparing(s -> s.charAt(n)).thenComparing(Comparator.naturalOrder())
```

- 컴파일러가 **전체 체인 표현식**의 타입을 먼저 결정하려고 시도
- `Comparator.naturalOrder()`는 `Comparator<? extends Comparable<? super ?>>`를 반환
- 이 복잡한 제네릭 타입과의 호환성을 맞추기 위해
- 컴파일러가 **가장 안전한 공통 타입인 Object**로 추론

**Java 컴파일러의 타입 추론 순서:**

1. 메서드 체이닝이 있으면 전체 표현식을 먼저 분석
2. 각 메서드의 제네릭 타입 제약을 수집
3. 모든 제약을 만족하는 가장 구체적인 타입을 찾으려고 시도
4. 불확실하면 Object로 fallback

이는 Java의 타입 추론 시스템의 한계로, 복잡한 제네릭 체이닝에서 발생하는 알려진 문제입니다. 그래서 명시적 타입 선언이 필요한 것입니다.
```