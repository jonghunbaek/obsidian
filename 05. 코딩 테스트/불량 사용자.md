---
플랫폼: 프로그래머스
문제 이름: 불량 사용자
알고리즘: 완전탐색
tags:
  - 완전탐색
date: 2025-08-01
aliases:
  - 완전탐색
복습 풀이: 250801(X), 250817(X), 250823(O), 250830(O), 250906(O), 250913(O), 251022(O)
---
# 1차 풀이
```java
// 재귀 형태로 구현  
// 상태 - real_banned_id, visited// 종료 조건 - real_banned_id가 banned_id와 길이가 같은 경우  
// 점화식 - 방문하지 않은 user_id를 순회하며 일치여부 확인해 일치하면 real_banned_id에 넣기  
public int solution(String[] user_id, String[] banned_id) {  
    return countAllBannedCase(user_id, banned_id, new boolean[user_id.length], new boolean[banned_id.length], new ArrayList<>());  
}  
  
private int countAllBannedCase(String[] user_id, String[] banned_id, boolean[] visited, boolean[] bannedVisited, List<String> banned) {  
    if (banned.size() == banned_id.length) {   
        return 1;  
    }  
  
    int count = 0;  
    for (int i = 0; i < user_id.length; i++) {  
        if (visited[i]) {  
            continue;  
        }  
        visited[i] = true;  
        String user = user_id[i];  
  
        for (int j = 0; j < banned_id.length; j++) {  
            if (bannedVisited[j]) {  
                continue;  
            }  
  
            if (isMatched(user, banned_id[j])) {  
                bannedVisited[j] = true;  
                banned.add(user);  
                count += countAllBannedCase(user_id, banned_id, visited, bannedVisited, banned);  
            }  
  
            bannedVisited[j] = false;  
        }  
  
        visited[i] = false;  
    }  
  
    return count;  
}  
  
private boolean isMatched(String user, String bannedUser) {  
    if (user.length() != bannedUser.length()) {  
        return false;  
    }  
  
    for (int i = 0; i < user.length(); i++) {  
        if (bannedUser.charAt(i) == '*') {  
            continue;  
        }  
  
        if  (user.charAt(i) != bannedUser.charAt(i)) {  
            return false;  
        }  
    }  
  
    return true;  
}
```

```java
// 재귀 형태로 구현  
// 상태 - real_banned_id, visited// 종료 조건 - real_banned_id가 banned_id와 길이가 같은 경우  
// 점화식 - 방문하지 않은 user_id를 순회하며 일치여부 확인해 일치하면 real_banned_id에 넣기  
public int solution(String[] user_id, String[] banned_id) {  
    String[][] cases = new String[banned_id.length][];  
    for (int i = 0; i < banned_id.length; i++) {  
        List<String> ids = new ArrayList<>();  
        for (int j = 0; j < user_id.length; j++) {  
            if (isMatched(user_id[j], banned_id[i])) {  
                ids.add(user_id[j]);  
            }  
        }  
        cases[i] = ids.toArray(String[]::new);  
    }  
  
    Set<Set<String>> result = new HashSet<>(); // 전체 결과를 담을 자료 구조  
    Set<String> banned = new HashSet<>(); // 하나의 경우의 수에 해당하는 자료 구조  
    boolean[] visited = new boolean[cases.length];  
    count(cases, visited, banned, result);  
  
    return result.size();  
}  
  
private void count(String[][] cases, boolean[] visited, Set<String> banned, Set<Set<String>> result) {  
    if (banned.size() == cases.length) {  
        result.add(new HashSet<>(banned));  
        return;  
    }  
  
    for (int i = 0; i < cases.length; i++) {  
        if (visited[i]) {  
            continue;  
        }  
  
        visited[i] = true;  
        for (int j = 0; j < cases[i].length; j++) {  
            if (banned.contains(cases[i][j])) {  
                continue;  
            }  
            banned.add(cases[i][j]);  
            count(cases, visited, banned, result);  
            banned.remove(cases[i][j]);  
        }  
  
        visited[i] = false;  
    }  
}  
  
private boolean isMatched(String user, String bannedUser) {  
    if (user.length() != bannedUser.length()) {  
        return false;  
    }  
  
    for (int i = 0; i < user.length(); i++) {  
        if (bannedUser.charAt(i) == '*') {  
            continue;  
        }  
  
        if  (user.charAt(i) != bannedUser.charAt(i)) {  
            return false;  
        }  
    }  
  
    return true;  
}
```

여전히 내겐 어려운 문제
우선 처음 접근은 첫 번째 풀이와 같이 접근했다. 접근법 자체는 틀리진 않았지만 실제 구현이 엉망이었음
문제를 제대로 이해하고 접근하지 않고 단순히 완전탐색, 재귀라는 방식으로 이해보단 정형화되어 접근

답안을 참고하여 두 번째 풀이를 수행했음
결과 값은 맞으나 시간 초과가 발생
시간 초과가 발생한 이유는 visited를 사용하여 같은 행의 cases를 방문했기 때문임
visited가 false로 되면서 다음 재귀에서 다시 또 반복을 하게됨
해당 문제에선 순서가 중요한 요소가 아니기 때문에 visited를 사용하는 것이 오히려 독이 됨
**다시 말하자면 순서가 중요한 문제에선 visited를 활용하는 것이 좋음**
아래는 관련된 내용을 클로드를 통해 정리한 것
```text
count(cases, [false,false], {}, result)
├─ i=0 시도 (visited[0]=true)
│  ├─ j=0: "frodo" 추가 → banned={"frodo"}
│  │  └─ count(cases, [true,false], {"frodo"}, result)
│  │     └─ i=1 시도 (visited[1]=true)  
│  │        └─ j=0: "abc123" 추가 → banned={"frodo","abc123"}
│  │           └─ count(cases, [true,true], {"frodo","abc123"}, result)
│  │              └─ 종료조건: result에 {"frodo","abc123"} 추가
│  │        └─ "abc123" 제거, visited[1]=false
│  │  └─ "frodo" 제거
│  ├─ j=1: "fradi" 추가 → banned={"fradi"}
│  │  └─ count(cases, [true,false], {"fradi"}, result)
│  │     └─ i=1 시도 (visited[1]=true)
│  │        └─ j=0: "abc123" 추가 → banned={"fradi","abc123"}
│  │           └─ count(cases, [true,true], {"fradi","abc123"}, result)
│  │              └─ 종료조건: result에 {"fradi","abc123"} 추가
│  │        └─ "abc123" 제거, visited[1]=false
│  │  └─ "fradi" 제거
│  └─ visited[0]=false
├─ i=1 시도 (visited[1]=true)  ← 여기서 중복 탐색 발생!
│  └─ j=0: "abc123" 추가 → banned={"abc123"}
│     └─ count(cases, [false,true], {"abc123"}, result)
│        └─ i=0 시도 (visited[0]=true)
│           ├─ j=0: "frodo" 추가 → banned={"abc123","frodo"}
│           │  └─ count(cases, [true,true], {"abc123","frodo"}, result)
│           │     └─ 종료조건: result에 {"abc123","frodo"} 추가 (중복!)
│           ├─ j=1: "fradi" 추가 → banned={"abc123","fradi"}  
│           │  └─ count(cases, [true,true], {"abc123","fradi"}, result)
│           │     └─ 종료조건: result에 {"abc123","fradi"} 추가 (중복!)
│           └─ visited[0]=false
│        └─ "abc123" 제거
│  └─ visited[1]=false
```

visited를 안쓰고 depth와 같은 파라미터를 인자로 넘길 경우 아래와 같은 탐색이 일어남
```text
count(0, {}, bans, result)
├─ index=0 처리
│  ├─ "frodo" 선택 → banned={"frodo"}
│  │  └─ count(1, {"frodo"}, bans, result)
│  │     └─ index=1 처리
│  │        └─ "abc123" 선택 → banned={"frodo","abc123"}
│  │           └─ count(2, {"frodo","abc123"}, bans, result)
│  │              └─ 종료조건: result에 {"frodo","abc123"} 추가
│  │        └─ "abc123" 제거
│  │  └─ "frodo" 제거
│  ├─ "fradi" 선택 → banned={"fradi"}
│  │  └─ count(1, {"fradi"}, bans, result)
│  │     └─ index=1 처리
│  │        └─ "abc123" 선택 → banned={"fradi","abc123"}
│  │           └─ count(2, {"fradi","abc123"}, bans, result)
│  │              └─ 종료조건: result에 {"fradi","abc123"} 추가
│  │        └─ "abc123" 제거
│  │  └─ "fradi" 제거
```

```java
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

public class Solution {
    private void count(int index, Set<String> banned, String[][] bans, Set<Set<String>> banSet) {
        if (index == bans.length) {
            banSet.add(new HashSet<>(banned));
            return;
        }

        for (String id : bans[index]) {
            if (banned.contains(id)) continue;
            banned.add(id);
            count(index + 1, banned, bans, banSet);
            banned.remove(id);
        }
    }

    public int solution(String[] user_id, String[] banned_id) {
        String[][] bans = Arrays.stream(banned_id)
                .map(banned -> banned.replace('*', '.'))
                .map(banned -> Arrays.stream(user_id)
                        .filter(id -> id.matches(banned))
                        .toArray(String[]::new))
                .toArray(String[][]::new);

        Set<Set<String>> banSet = new HashSet<>();
        count(0, new HashSet<>(), bans, banSet);
        return banSet.size();
    }
}
```

# 2차 풀이
```JAVA
import java.util.*;

class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[][] cases = findCasesByBannedId(user_id, banned_id);

        Set<Set<String>> results = new HashSet<>();
        Set<String> target = new HashSet<>();
        count(0, target, cases, results);

        return results.size();
    }

    private void count(int start, Set<String> target, String[][] cases, Set<Set<String>> results) {
        if (target.size() == cases.length) {
            results.add(new HashSet<>(target));
            return;
        }

        for (int i = 0; i < cases[start].length; i++) {
            if (target.contains(cases[start][i])) {
                continue;
            }
            
            target.add(cases[start][i]);
            count(start + 1, target, cases, results);
            target.remove(cases[start][i]);
        }
    }

    private String[][] findCasesByBannedId(String[] user_id, String[] banned_id) {
        String[][] cases = new String[banned_id.length][];
        for (int i = 0; i < banned_id.length; i++) {
            List<String> ids = new ArrayList<>();
            for (int j = 0; j < user_id.length; j++) {
                if (isMatch(user_id[j], banned_id[i])) {
                    ids.add(user_id[j]);
                }
            }

            cases[i] = ids.toArray(String[]::new);
        }

        return cases;
    }

    private boolean isMatch(String userId, String bannedId) {
        if (userId.length() != bannedId.length()) {
            return false;
        }

        for (int i = 0; i < userId.length(); i++) {
            if (bannedId.charAt(i) == '*') {
                continue;
            }

            if (userId.charAt(i) != bannedId.charAt(i)) {
                return false;
            }
        }

        return true;
    }
}
```
첫 번째 풀이 때와 다르게 접근법조차 기억이 안났음. 물론 컨디션 난조도 있었지만...
일단 문제 접근 방식은 다음으로 정리해볼 수 있음
- 불량 사용자 아이디별로 일치하는 모든 사용자 아이디를 미리 만들어 2차원 배열로 만들기
- 앞서 만든 2차원 배열을 재귀로 탐색하며 모든 가능한 경우를 카운트
재귀를 통해 모든 경우의 수를 계산할 때 처음엔 2중 for문을 사용해서 틀림. 조금만 생각해보면 당연한 결과였음

# 3차 풀이
```java
class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[][] cases = new String[banned_id.length][];
        for (int i = 0; i < banned_id.length; i++) {
            List<String> names = new ArrayList<>();
            for (String name : user_id) {
                if (isMatch(name, banned_id[i])) {
                    names.add(name);
                }
            }
            
            cases[i] = names.toArray(String[]::new);
        }
        
        Set<String> target = new HashSet<>();
        Set<Set<String>> results = new HashSet<>();
        count(0, target, cases, results);
        
        return results.size();
    }
    
    private void count(int depth, Set<String> target, String[][] cases, Set<Set<String>> results) {
        if (depth == cases.length) {
            results.add(new HashSet<>(target));
            return;
        }
        
        for (String name : cases[depth]) {
            if (target.contains(name)) {
                continue;
            }
            
            target.add(name);
            count(depth + 1, target, cases, results);
            target.remove(name);
        }
    }
    
    private boolean isMatch(String userName, String banned) {
        if (userName.length() != banned.length()) {
            return false;
        }
        
        for (int i = 0; i < userName.length(); i++) {
            if (banned.charAt(i) == '*') {
                continue;
            }
            
            if (userName.charAt(i) != banned.charAt(i)) {
                return false;
            }
        }
        
        return true;
    }
}
```
이전 풀이와 달리 풀이법을 확실히 인지함
다만, 아직 헷갈리는 부분이 존재하고 잘못 이해하는 곳도 존재함.
또한 복합적으로 생각할게 많은 문제이므로 많이 풀어보기
- **재귀의 종료 조건에서 HashSet을 새로 생성하는 이유**
- **결과를 List가 아닌 Set에 담는 이유**

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[][] cases = findBannedCases(user_id, banned_id);
        
        Set<String> target = new HashSet<>();
        Set<Set<String>> results = new HashSet<>();
        count(0, target, results, cases);
        
        return results.size();
    }
    
    private String[][] findBannedCases(String[] userId, String[] bannedId) {
        String[][] cases = new String[bannedId.length][];
        for (int i = 0; i < bannedId.length; i++) {
            List<String> results = new ArrayList<>();
            for (int j = 0; j < userId.length; j++) {
                if (isMatch(bannedId[i], userId[j])) {
                    results.add(userId[j]);
                }
            }
            
            cases[i] = results.toArray(String[]::new);
        }
        
        return cases;
    }
    
    private boolean isMatch(String banned, String user) {
        if (banned.length() != user.length()) {
            return false;
        }
        
        for (int i = 0; i < banned.length(); i++) {
            if (banned.charAt(i) == '*') {
                continue;
            }
            
            if (banned.charAt(i) != user.charAt(i)) {
                return false;
            }
        }
        
        return true;
    }
    
    private void count(int depth, Set<String> target, Set<Set<String>> results, String[][] cases) {
        if (target.size() == cases.length) {
            results.add(new HashSet<>(target));
            return;
        }
        
        for (String value : cases[depth]) {
            if (target.contains(value)) {
                continue;
            }
            
            target.add(value);
            count(depth + 1, target, results, cases);
            target.remove(value);
        }
    }
}
```

```java
import java.util.*;

class Solution {
    // 최종적으로 만들어지는 유니크한 아이디 조합들을 저장하는 Set
    private final Set<Set<String>> results = new HashSet<>();
    private String[] userIdCache;
    private String[] bannedIdCache;

    public int solution(String[] user_id, String[] banned_id) {
        userIdCache = user_id;
        bannedIdCache = banned_id;
        
        // 0번째 불량 아이디부터 탐색 시작
        dfs(0, new HashSet<>());
        
        return results.size();
    }

    /**
     * 불량 사용자 아이디 조합을 탐색하는 DFS(깊이 우선 탐색) 메소드
     * @param depth 현재 탐색해야 할 banned_id의 인덱스
     * @param currentSet 현재까지 만들어진 user_id 조합
     */
    private void dfs(int depth, Set<String> currentSet) {
        // 모든 불량 아이디에 대해 사용자 매칭을 완료한 경우
        if (depth == bannedIdCache.length) {
            // 결과 Set에 현재 조합을 추가 (순서와 상관없이 유일해야 하므로 새로운 HashSet으로 복사하여 추가)
            results.add(new HashSet<>(currentSet));
            return;
        }

        // 전체 사용자 아이디 목록을 순회
        for (String user : userIdCache) {
            // 1. 이미 추가된 사용자인지 확인
            if (currentSet.contains(user)) {
                continue;
            }
            
            // 2. 현재 깊이의 불량 아이디 패턴과 일치하는지 확인
            if (isMatch(bannedIdCache[depth], user)) {
                currentSet.add(user); // 조합에 추가
                dfs(depth + 1, currentSet); // 다음 깊이로 재귀 탐색
                currentSet.remove(user); // 백트래킹: 다음 경우의 수를 위해 제거
            }
        }
    }
    
    // 두 아이디가 매칭되는지 확인하는 메소드 (기존과 동일)
    private boolean isMatch(String banned, String user) {
        if (banned.length() != user.length()) {
            return false;
        }
        
        for (int i = 0; i < banned.length(); i++) {
            if (banned.charAt(i) != '*' && banned.charAt(i) != user.charAt(i)) {
                return false;
            }
        }
        
        return true;
    }
}
```

기존 내 풀이의 큰 흐름은 다음과 같음
1. 불량 사용자 아이디 패턴에 매칭되는 사용자 아이디 목록을 2차원 문자열 배열에 저장
2. 2차원 배열을 기반으로 재귀 탐색하여 모든 경우의 수 탐색
3. 결과 반환
여기서 1번 과정을 생략하고 바로 재귀로 탐색할 수도 있겠다는 생각이 들었음
물론 난 아직 재귀를 잘 활용하지 못해 제미나이를 통해 해당 코드를 확인

**다음번 풀이 땐 1번 과정을 생략하고 풀어보기**
더불어 아이디 매칭 확인도 별도 메서드보단 String의 match()를 활용해 풀어보기

# 5차 풀이
```java
class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[] banned = initBannedId(banned_id);
        boolean[] visited = new boolean[user_id.length];
        Set<Set<String>> results = new HashSet<>();
        count(0, new HashSet<>(), user_id, banned, visited, results);
            
        return results.size();
    }
    
    private String[] initBannedId(String[] banned_id) {
        return Arrays.stream(banned_id)
            .map(ban -> ban.replace("*", "."))
            .toArray(String[]::new);
    }
    
    private void count(int depth, Set<String> target, String[] userId, String[] banned, boolean[] visited, Set<Set<String>> results) {
        if (target.size() == banned.length) {
            results.add(new HashSet<>(target));
            return;
        }
        
        for (int i = 0; i < userId.length; i++) {
            if (visited[i] || !userId[i].matches(banned[depth])) {
                continue;
            }
            
            visited[i] = true;
            target.add(userId[i]);
            count(depth + 1, target, userId, banned, visited, results);
            target.remove(userId[i]);
            visited[i] = false;
        }
    }
}
```

방문 배열 없어도 가능
```java
class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[] banned = initBannedId(banned_id);
        Set<Set<String>> results = new HashSet<>();
        count(0, new HashSet<>(), user_id, banned, results);
            
        return results.size();
    }
    
    private String[] initBannedId(String[] banned_id) {
        return Arrays.stream(banned_id)
            .map(ban -> ban.replace("*", "."))
            .toArray(String[]::new);
    }
    
    private void count(int depth, Set<String> target, String[] userId, String[] banned, Set<Set<String>> results) {
        if (target.size() == banned.length) {
            results.add(new HashSet<>(target));
            return;
        }
        
        for (int i = 0; i < userId.length; i++) {
            if (target.contains(userId[i]) || !userId[i].matches(banned[depth])) {
                continue;
            }
            
            target.add(userId[i]);
            count(depth + 1, target, userId, banned, results);
            target.remove(userId[i]);
        }
    }
}
```
지난 주에 고민했던대로, 먼저 banned_id의 패턴에 일치하는 값의 경우의수를 미리 구하지 않고 바로 완탐으로 해결
마지막으로 한 번만 더 풀어보자

# 6차 풀이
```java
class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        Set<String> target = new HashSet<>();
        Set<Set<String>> results = new HashSet<>();
        findAllCases(0, target, user_id, banned_id, results);
        
        return results.size();
    }
    
    private void findAllCases(int depth, Set<String> target, String[] userId, String[] bannedId, Set<Set<String>> results) {
        if (depth == bannedId.length) {
            results.add(new HashSet<>(target));
            return;
        }
        
        for (int i = 0; i < userId.length; i++) {
            if (target.contains(userId[i])) {
                continue;
            }
            
            String banned = bannedId[depth].replace("*", ".");
            
            if (!userId[i].matches(banned)) {
                continue;
            }
            
            target.add(userId[i]);
            findAllCases(depth + 1, target, userId, bannedId, results);
            target.remove(userId[i]);
        }
    }
}
```
집중할 수 없는 환경에서 풀다보니 어색하게 느껴진 듯

# 7차 풀이
```java
// 1. 풀이 1
//      - 이중 반복문과 이중 방문 배열을 활용해 경우의 수를 판단
// 2. 풀이 2
//      - 불량 사용자 패턴에 맞는 사용자 아이디를 미리 구해 재귀 탐색
import java.util.*;

class Solution {
    public int solution(String[] user_id, String[] banned_id) {
        String[][] cases 기