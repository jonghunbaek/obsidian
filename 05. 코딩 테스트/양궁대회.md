---
플랫폼: 프로그래머스
문제 이름: 양궁대회
알고리즘: 완전탐색, 그리디
tags:
  - 완전탐색
  - 그리디
date: 2025-11-20
aliases:
복습 풀이: 251120(X), 251201(X), 251209(X), 251213(X), 251220(X), 251227(X)
---
# 1차 풀이
```java
// 1. 구현 
// 3. 첫째, 라이언이 이길 수 있는 최대 점수 구하기(점수가 같다면 진것)
//  - 비용 구하기 : 10점부터 차례대로 화살을 소모하며 계산, 그 다음 9점부터, 그 다음 8점부터
//  - 이 과정으로 최댓값을 구하기
// 4. 가장 큰 차이로 이길 수 있는 점수 경우의 수가 여러개라면 비교하여 우선 순위가리기
// 5. 결과 반환
// 6. 최댓값을 구한다 한들, 어떤 점수에 맞췄는지 기록은?
import java.util.*;
import java.util.stream.*;

class Solution {
    public int[] solution(int n, int[] info) {
        Map<Integer, List<int[]>> records = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int pointIdx = i;
            int arrow = n;
            int[] lion = new int[11];
            int lionPoint = 0;
            int apeachPoint = 0;
            while(arrow > 0) {
                int shots = info[pointIdx] + 1;
                if (arrow - shots < 0) {
                    apeachPoint += 10 - pointIdx;
                } else {
                    if (pointIdx == info.length - 1) {
                        shots = arrow;
                    }
                    
                    lion[pointIdx] = shots;
                    lionPoint += 10 - pointIdx;    
                }
                
                arrow -= shots;
                pointIdx++;
            }
            
            if (lionPoint == apeachPoint) continue;
            
            List<int[]> record = records.getOrDefault(lionPoint, new ArrayList<>());
            record.add(Arrays.copyOfRange(lion, 0, lion.length));
            records.put(lionPoint, record);
        }
        
        records.entrySet().stream()
            .forEach(entry -> System.out.println(entry.getKey() + ", " + entry.getValue().size()));
        if (records.size() == 0) return new int[] {-1};
        
        int max = records.keySet().stream()
            .mapToInt(Integer::intValue)
            .max()
            .orElse(0);
        if (max == 0) return new int[] {-1};
        List<int[]> record = records.get(max);
        List<int[]> result = record.stream()
            .sorted((r1, r2) -> sortBy(r1, r2))
            .collect(Collectors.toList());
        
        return result.get(0);
    }
    
    private int sortBy(int[] r1, int[] r2) {
        int length = r1.length - 1;
        while (length > -1) {
            if (r1[length] != r2[length]) {
                return r2[length] - r1[length];
            }
            length--;
        }
        
        return 1;
    }
}
```
약 55분동안 풀었지만 결국 못풂
- 단순 구현이라 생각했는데 접근 방식이 잘못됐는지?
- 지문 읽고 이해하는 시간만 20분 정도 걸린듯

# 2차 풀이
```java
class Solution {
    public int[] solution(int n, int[] info) {
        int[] ryan = new int[11];
        Result result = new Result(-1, new int[] {-1});
        shot(0, n, ryan, info, result);
        
        return result.points;
    }
    
    private void shot(int idx, int n, int[] ryan, int[] apeach, Result result) {
        if (idx == ryan.length || n == 0) {
            if (n > 0) ryan[10] = n;

            int point = calculatePoint(ryan, apeach);
            if (point > 0) result.putResult(point, ryan.clone());
            if (n > 0) ryan[10] = 0;
            
            return;
        }
        
        if (n > apeach[idx]) {
            ryan[idx] = apeach[idx] + 1;
            shot(idx + 1, n - ryan[idx], ryan, apeach, result);
            ryan[idx] = 0;
        }
        
        shot(idx + 1, n, ryan, apeach, result);
    }
    
    private int calculatePoint(int[] ryan, int[] apeach) {
        int ryanPoint = 0;
        int apeachPoint = 0;
        for (int i = 0; i < ryan.length; i++) {
            if (ryan[i] == 0 && apeach[i] == 0) continue;
            if (apeach[i] >= ryan[i]) {
                apeachPoint += 10 - i;
            } else {
                ryanPoint += 10 - i;
            }
        }
        
        return ryanPoint - apeachPoint;
    }
    
    static class Result {
        private int maxPoint;
        private int[] points;
        
        public Result(int maxPoint, int[] points) {
            this.maxPoint = maxPoint;
            this.points = points;
        }
        
        public void putResult(int point, int[] points) {
            if (point > maxPoint) {
                this.maxPoint = point;
                this.points = points;
            } else if (point == maxPoint) {
                for (int i = 10; i >= 0; i--) {
                    if (this.points[i] < points[i]) {
                        this.points = points;
                        break;
                    } else if (this.points[i] > points[i]) {
                        break;
                    }
                }
            }
        }
    }
}
```

# 3차 풀이
```java
public int[] solution(int n, int[] info) {  
    int[] ryan = new int[info.length];  
    Result result = new Result();  
    shoot(0, n, ryan, info, result);  
  
    return result.maxPoint == 0 ? new int[] {-1} : result.points;  
}  
  
private void shoot(int idx, int n, int[] ryan, int[] apeach, Result result) {  
    if (idx == apeach.length) {  
        if (n > 0) ryan[10] = n;  
  
        int diffPoint = 0;  
        for (int i = 0; i < apeach.length; i++) {  
            if (apeach[i] == 0 && ryan[i] == 0) continue;  
  
            if (apeach[i] >= ryan[i]) {  
                diffPoint -= 10 - i;  
            } else {  
                diffPoint += 10 - i;  
            }  
        }  
  
        if (diffPoint <= 0) {  
            if (n > 0) ryan[10] = 0;  
            return;  
        }  
  
        if (diffPoint > result.maxPoint) {  
            result.maxPoint = diffPoint;  
            result.points = ryan.clone();  
            if (n > 0) ryan[10] = 0;  
            return;  
        } else if(diffPoint == result.maxPoint) {  
            if (hasHigherPriority(result.points, ryan)) {  
                result.points = ryan.clone();  
            }  
        }  
  
        if (n > 0) ryan[10] = 0;  
        return;  
    }  
  
    if (n > apeach[idx]) {  
        ryan[idx] = apeach[idx] + 1;  
        shoot(idx + 1, n - ryan[idx], ryan, apeach, result);  
        ryan[idx] = 0;  
    }  
  
    shoot(idx + 1, n, ryan, apeach, result);  
}  
  
private boolean hasHigherPriority(int[] origin, int[] target) {  
    for (int i = 10; i >= 0; i--) {  
        if (target[i] > origin[i]) return true;  
        if (target[i] < origin[i]) return false;  
    }  
  
    return false;  
}  
  
static class Result {  
    private int maxPoint;  
    private int[] points;  
}
```

그리 어려운 문제라 생각들지 않은데 이상하게 어려운 문제..
아무래도 문제의 조건이 까다롭다보니 엣지 케이스를 계속 놓치는 것이 주요한 문제일듯

# 4차 풀이
```java
class Solution {
    public int[] solution(int n, int[] info) {
        int[] ryan = new int[info.length];
        Result result = new Result();
        shot(0, n, ryan, info, result);
        return result.maxPoint == 0 ? new int[] {-1} : result.points;
    }
    
    private void shot(int idx, int n, int[] ryan, int[] info, Result result) {
        if (idx == info.length) {
            if (n > 0) ryan[10] = n;
            
            int diff = 0;
            for(int i = 0; i < info.length; i++) {
                if (ryan[i] == 0 && info[i] == 0) continue;
                if (ryan[i] <= info[i]) {
                    diff -= 10 - i;
                } else {
                    diff += 10 - i;
                }
            }
            if (diff <= 0) {
                if (n > 0) ryan[10] = 0;
                return;
            }
            
            if (result.maxPoint < diff) {
                result.maxPoint = diff;
                result.points = ryan.clone();
            } else if (result.maxPoint == diff) {
                putIfShotManyPointsLower(ryan, result);
            }
            
            if (n > 0) ryan[10] = 0;
            return;
        }
        
        if (n > info[idx]) {
            ryan[idx] = info[idx] + 1;
            shot(idx + 1, n - ryan[idx], ryan, info, result);
            ryan[idx] = 0;
        }
        
        shot(idx + 1, n, ryan, info, result);
    }
    
    private void putIfShotManyPointsLower(int[] ryan, Result result) {
        for (int i = 10; i >= 0; i--) {
            if (ryan[i] > result.points[i]) {
                result.points = ryan.clone();
            } else if (ryan[i] < result.points[i]) {
                break;  // 기존 결과가 더 낮은 점수를 많이 맞힌 경우
            }
        }
    }
    
    static class Result {
        private int maxPoint;
        private int[] points;
    }
 }	 
```

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int n, int[] info) {
        int[] ryan = shot(0, n, info, new int[info.length]);
        
        return ryan == null ? new int[] {-1} : ryan;
    }
    
    private int[] shot(int idx, int n, int[] apeach, int[] hits) {
        if (idx == apeach.length) {
            if (n > 0) return null;
            if (calculateDiff(apeach, hits) <= 0) return null;
            
            return Arrays.copyOf(hits, hits.length);
        }
        
        int maxDiff = 0;
        int[] result = null;
        for (int i = 0; i <= n; i++) {
            hits[idx] = i;
            int[] ryan = shot(idx + 1, n - hits[idx], apeach, hits);
            if (ryan == null) continue;
            
            int diff = calculateDiff(apeach, ryan);
            if (diff > maxDiff || (diff == maxDiff && hasPrior(result, ryan))) {
                maxDiff = diff;
                result = ryan;
            }   
        }
        
        return result;
    }
    
    private int calculateDiff(int[] apeach, int[] ryan) {
        int result = 0;
        for (int i = 0; i < apeach.length; i++) {
            if (apeach[i] == 0 && ryan[i] == 0) continue;
            
            if (apeach[i] >= ryan[i]) {
                result -= 10 - i;
            } else {
                result += 10 - i;
            }
        }
        
        return result;
    }
    
    private boolean hasPrior(int[] base, int[] target) {
        for (int i = 10; i >= 0; i--) {
            if (target[i] == base[i]) continue;
            return target[i] > base[i];
        }
        return false;
    }
}
```
좀 더 표준적인 풀이를 참고하여 따라함
재귀의 종료 조건이 까다로움에 주의해서 풀어야함

# 6차 풀이
```java
```