레디스의 데이터는 기본적으로 메모리에 저장되기에 여러 장애 상황이 발생해 서버가 다운되면 데이터가 유실될 가능성이 존재한다.
이러한 문제를 해결하기 위해 레디스에선 두 가지 백업 방식을 제공한다.
- **RDB**
	- 일정 시점에 메모리에 저장된 데이터 전체를 저장(스냅숏 방식)
	- 바이너리 형태로 저장
- **AOF**
	- 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록,  복원 시에는 파일을 다시 읽어가며 데이터 셋 구성
	- RESP 형태로 저장

>[!RESP(REdis Serialization Protocol)]
>
>Redis 클라이언트와 서버가 통신할 때 사용되는 프로토콜로 단순하고 빠른 파싱이 장점이다. 또한 사람이 읽을 수 있는 형태를 지향한다.
>**타입 구분 기호 + 요소에 대한 정보 + 줄바꿈 + 실제 데이터와 같은 구조**로 이뤄진다.
>타입 구분 기호는 총 5개(+, -, :, $, \*)로 각각 단순 문자열, 에러, 정수, 벌크 문자열, 배열을 뜻한다.
>구조가 단순하지만 명령어와 데이터의 분리가 명확해 파싱이 빠르다.
>또한 문자열의 길이를 명시하기에 NULL, \0과 같은 문자가 들어와도 잘못 읽지 않는다.
>**즉, prefixed-length를 활용해 바이너리 안전하게 데이터를 읽는다.**
>RESP 또한 TCP 기반에서 작동하며, HTTP와 같이 애플리케이션 계층에서 이뤄진다.

두 백업 방식을 동시에 사용하는 것이 가능하며, 데이터의 안정성을 위해서 함께 사용되는 것이 권장된다.
레디스에서 해당 방식들을 이용해 복구하는 것은 레디스 서버가 재시작될 때뿐이며, 실행 도중에 복원할 수 있는 방법은 없다.

### 백업 사용시 주의점
레디스의 두 가지 백업 방식 모두 COW(Copy-On-Write)방식을 이용하기 때문에 최악의 경우 레디스는 기존 메모리 용량의 2배를 사용하게 될 수도 있다. 
그러므로 레디스의 maxmemory 값을 적절히 설정해 OOM을 예방해야 한다.

# 1. RDB 백업 방식
RDB 방식으로 백업 파일을 생성하는 방법은 다음과 같다.
- **특정 조건을 활용해 자동 저장**
- **사용자가 원하는 시점에 커맨드를 활용해 수동 저장**
- **복제 기능 활용**

## 1.1 특정 조건에 자동으로 RDB 파일 생성
Redis의 설정 파일을 수정하여 자동 생성
```text
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>   // 기본 값은 dump.rdb
dir <RDB 파일이 저장될 경로> // 파일 저장 경로 지정

save 900 1    // 900초 동안 1개 이상의 키가 변경된 경우
save ""       // 비활성화
```

>[!주의점]
> save 60 10과 같은 설정을 적용했다고 가정
> 1. 11개의 키가 변경되어 RDB 파일이 생성 완료되고 나면 카운팅은 초기화 됨
> 2. 시간은 초기화되지 않음
> 3. RDB 파일이 생성되는 도중에 키 11개가 또 변경된다면 추가적으로 RDB 파일을 만드는 것이 아니라 무시됨

| 시간  | 변경 수               | 설명                         |
| --- | ------------------ | -------------------------- |
| 0초  | 11개 변경 → RDB 저장 시작 | 백그라운드로 RDB 저장 진행중          |
| 10초 | 5개 추가 변경           | 조건 충족하지만 **이미 저장 중**이므로 무시 |
| 30초 | 10개 추가 변경          | 역시 무시                      |
| 50초 | RDB 저장 완료          |                            |
| 70초 | 또 변경 감지            | 새롭게 RDB 저장 가능해짐            |

### 실행 중인 레디스 인스턴스에 설정을 적용하려면?
redis-cli에 직접 아래와 같은 명령어를 입력한다.
```
> CONFIG SET save ""
OK

> CONFIG REWRITE
OK
```

## 1.2 수동으로 RDB 파일 생성
아래와 같은 방식으로 사용자가 원하는 시점에 RDB 파일을 생성할 수 있다.
- **SAVE**
	- 동기 방식으로 파일 저장
	- 때문에 파일 생성 완료까지 모든 클라이언트의 명령이 차단됨
- **BGSAVE**
	- 백그라운드에서 파일 생성
	- fork를 호출해 자식 프로세스가 파일 생성
	- SCHEDULE 옵션을 함께 사용할 수 있음
RDB 파일의 정상 저장 여부는 LASTSAVE 커맨드로 확인할 수 있음

## 1.3 복제를 활용한 RDB 파일 자동 생성
**REPLICAOF 명령어를 이용해 복제를 요청하면 마스터 노드에서 RDB 파일을 생성해 복제본에게 전달**한다.
네트워크 장애와 같은 이슈가 발생해 순단 현상이 생기는 경우에도 자동으로 복제본에게 RDB 파일을 전달한다. 

# 2. AOF 백업 방식
설정 파일에서 아래와 같은 옵션을 사용해 AOF 파일에 주기적으로 데이터를 저장할 수 있다.
```text
appendonly yes                  // aof 사용 여부
appendfilename "appendonly.aof" // 저장될 파일 이름
appenddirname "appendonlydir"   // 파일 저장 경로
```

AOF 방식에서 저장되는 명령어와 사용자가 직접 입력한 명령어가 반드시 일치하지는 않는다. 
AOF 파일상에는 **메모리의 데이터가 변경되는 명령어만 기록되기 때문에 그 외 부가적인 작업들은 저장되지 않는다.**
→ ex) BRPOP과 같은 블로킹 기능

하지만 메모리가 변경될 때마다 명령어가 저장된다면 INCR 명령어를 사용해 값을 1씩 1000번 증가시키면 1000번의 명령어가 모두 저장되게 된다.
이러한 단점을 해결하기 위해 파일을 재구성하는 방법이 필요하다.
## 2.1 AOF 파일 재구성 
AOF 파일 재구성이란 압축과도 같으며 7버전 전, 후로 다른 방식이 사용된다.
재구성은 기본적으로 디스크에 저장되어 있던 **기존의 AOF 파일을 사용하는 것이 아니라 새로운 파일로 저장하는 형태로 동작**한다.
또한 RDB의 생성 방식과 마찬가지로 fork를 활용해 자식 프로세스가 AOF 파일을 생성한다.

**AOF 파일의 재구성 과정은 모두 순차 I/O만 사용**하므로 효율적이다.
파일 목적 자체가 검색이 아니기 때문에 랜덤 I/O가 필요 없기 때문이다.  
### 7 버전 이전
![[Redis - AOF 재구성(7버전 이전).png]]
- 자식 프로세스 생성
- 자식 프로세스는 메모리의 데이터를 읽어 새로 생성한 임시 파일에 저장(RDB)
- 앞선 과정이 진행되는 동안 메모리에 변경된 데이터 내역을 기존의 AOF 파일과 인메모리 버퍼에 동시 저장
- 자식 프로세스의 재구성 과정이 끝나면 인메모리 버퍼에 저장된 내용을 임시 파일 마지막에 추가
- 기존의 AOF 파일을 새로운 임시 파일로 덮어 씌운다.

해당 방식은 다음과 같은 문제점이 존재한다.
- **데이터 변경 로그가 이중 저장(인메모리 버퍼, AOF 파일)**
- **하나의 AOF 파일에 바이너리, RESP 방식의 데이터가 함께 저장되어 수동 처리가 어려움**

### 7 버전 이후
앞선 문제를 해결하고자 레디스는 버전 7 이후 AOF는 RDB 파일과 AOF 파일을 나눠서 관리한다. 
또한 현재 레디스가 바라보고 있는 파일이 어느 것(AOF, RDB)인지 알려주는 매니 페스트 파일을 도입했다. 
AOF가 재구성될 때마다 AOF를 구성하고 있는 RDB와 AOF의 파일명의 번호, 매니페스트 파일 내부의 seq 값도 1씩 증가한다. 
![[Redis - AOF 재구성(7버전 이후).png]]
- 자식 프로세스 생성
- 자식 프로세스는 메모리의 데이터를 읽어 새로 생성한 임시 파일에 저장(RDB)
- 앞선 과정이 진행되는 동안 변경된 데이터 내역을 새로운 AOF 파일에 저장
- 자식 프로세스의 재구성 과정이 끝나면 임시 매니페스트 파일을 생성하여 기존의 매니페스트 파일을 대체한다.
- 이후 이전 버전의 AOF, RDB 파일을 삭제

### 자동/수동 AOF 재구성
아래 옵션을 통해 자동으로 AOF 파일을 재구성할 수 있다. 파일 크기가 매우 작은 경우 비효율적이니 두 번째 옵션을 함께 사용하는 것을 권장
```text
auto-aof-rewrite-percentage 100 // 마지막으로 재구성된 AOF 파일의 크기와 비교해 현재 AOF 파일이 옵션으로 준 값(%단위)만큼 커질 경우 재구성 시도
auto-aof-rewrite-min-size 64mb  // 재구성된 이후의 AOF 파일의 최소 크기 지정
```

아래 명령어를 통해 수동으로 재구성을 할 수 있다.
```text
BGREWRITEAOF
```

### AOF 타임 스탬프
버전 7 이상부터 AOF 저장 시 타임스탬프를 남길 수 있다.
이를 활용해 시스템 상에서 시점 복원을 가능하게 만들 수 있다.
7버전 이전의 레디스와 호환되지 않음에 주의해야 한다.

### AOF 파일 복원
AOF 파일 작성 도중 서버에 장애가 발생해 레디스가 중지될 수 있다.
이 때, redis-check-aof 프로그램을 사용해 AOF 파일의 정상 여부를 확인할 수 있다.

### AOF 파일의 안전성
AOF 파일 저장 시 APPENDSYNC 옵션을 이용해 FSYNC 호출을 제어할 수 있다. 다음과 같은 옵션이 존재한다. 
- **no**
	- WRITE 시스템 콜 호출. 성능은 가장 빠르지만 내구성이 떨어짐
- **always**
	- WRITE, FSYNC 시스템 콜을 함게 호출. 내구성은 좋지만 쓰기 성능이 가장 느림
- **everysec**
	- 1초마다 FSYNC를 호출. 성능은 no 옵션과 비슷하며, 최대 1초 동안의 데이터 유실이라 내구성이 높은 편

>[!FSYNC]
>커널의 OS 메모리 버퍼에 저장된 내용을 실제로 디스크에 저장하도록 강제하는 시스템 콜