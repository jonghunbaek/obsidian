---
플랫폼: 프로그래머스
알고리즘: 배열, 구현
tags:
  - 배열
  - 구현
date: 2025-12-11
복습 풀이: 251211(O), 251219(O), 251229(X)
---
# 1차 풀이
```java
// 1. 단순 배열 문제
// 2. n과 w에 따라 2차원 배열의 길이 정하기
// 3. 배열 상하로 뒤집어 보기 편하게 만들기

class Solution {
    public int solution(int n, int w, int num) {
        int height = (int) Math.ceil((double) n / w);
        int[][] dummy = new int[height][w];
        
        int value = 1;
        int x = 0;
        boolean isLeftDirection = true;
        for (int y = 0; y < dummy.length; y++) {
            while (0 <= x && x < w) {
                if (value > n) break;
                
                dummy[y][x] = value++;    
                
                if (isLeftDirection) {
                    x++;
                } else {
                    x--;
                }
            }
            
            isLeftDirection = isLeftDirection ? false : true;
            if (isLeftDirection) {
                x++;
            } else {
                x--;
            }
        }
        
        int col = 0;
        int row = 0;
        for (int i = 0; i < dummy.length; i++) {
            for (int j = 0; j < dummy[i].length; j++) {
                if (dummy[i][j] == num) {
                    col = j;
                    row = i;
                }
            }
        }
        
        int count = 0;
        for (int i = row; i < dummy.length; i++) {
            if (dummy[i][col] != 0) count++;
        }
        
        return count;
    }
}
```
단순한 배열문제. 
20분걸림
이런 문제는 10분 컷 해줘야 함.
풀이도 지저분함
다른 사람 풀이를 보니 수식으로 최대 O(n)으로 풀이함

# 2차 풀이
1차 풀이와 동일하게 푸는 것은 의미가 없음
대신 input의 범위가 매우 커질 때 이 문제의 난이도가 대폭 상승할 수 있으니 수식을 이용한 풀이를 이해해보기
## 풀이 1
```java
class Solution {
    public int solution(int n, int w, int num) {
        int cnt = 0;
        while(num <= n) {
            num += (w - ((num - 1) % w) -1) * 2 + 1;
            cnt++;
        }

        int answer = cnt;
        return answer;
    }
}
```

핵심 수식 `(w - ((num-1) % w) -1) * 2 + 1`의 의미를 단계별로 분석해드리겠습니다.
## 수식 분해
```java
num += (w - ((num-1) % w) -1) * 2 + 1;
```
### 1단계: `(num-1) % w`
- 현재 위치 `num`이 컨베이어 벨트의 어느 위치에 있는지 계산
- 0-indexed로 변환하기 위해 `num-1`을 사용
- `% w`로 현재 벨트 내에서의 상대 위치를 구함
**예시:** w=5일 때
- num=1 → (1-1)%5 = 0 (첫 번째 칸)
- num=3 → (3-1)%5 = 2 (세 번째 칸)
- num=6 → (6-1)%5 = 0 (다시 첫 번째 칸)
### 2단계: `w - ((num-1) % w) - 1`
- **벨트 끝까지 남은 칸 수** 계산
- 현재 위치에서 벨트의 마지막까지 가는데 필요한 이동 횟수
**예시:** w=5일 때
- num=1 (위치 0) → 5-0-1 = 4 (끝까지 4칸)
- num=3 (위치 2) → 5-2-1 = 2 (끝까지 2칸)
### 3단계: `(...) * 2 + 1`

- **왕복 + 1**을 의미
- `* 2`: 벨트 끝까지 갔다가 다시 돌아오는 왕복
- `+ 1`: 현재 상자를 꺼내는 것
## 전체 로직의 의미
````java
while(num <= n) {
    num += (w - ((num-1) % w) -1) * 2 + 1;
    cnt++;
}
```

이 코드는:
1. 현재 위치(`num`)에서 **벨트를 한 바퀴 돌려서 다음에 꺼낼 상자의 위치**를 계산
2. 벨트 끝까지 가는 칸 수를 구하고, 그만큼 왕복하면서 지나가는 모든 상자의 개수를 더함

## 구체적 예시

**조건:** n=10, w=3, num=1
```
벨트: [1][2][3] ... 10개 상자

1회차: num=1 (위치 0)
  - 끝까지: 3-0-1 = 2칸
  - 이동: 2*2+1 = 5개 지나감
  - num = 1+5 = 6
  
2회차: num=6 (위치 0, 새로운 사이클)
  - 끝까지: 3-0-1 = 2칸
  - 이동: 2*2+1 = 5개 지나감
  - num = 6+5 = 11 (n=10 초과)
  
답: 2회
````
## 핵심 개념
이 알고리즘은 **원형 컨베이어 벨트**에서:
- 순서대로 상자를 꺼내되
- 현재 위치에서 벨트를 회전시켜 다음 상자까지 도달하는 과정을 수식으로 표현한 것입니다
- 벨트 끝에서 다시 처음으로 돌아오는 순환 구조를 `% w`로 처리합니다

이런 방식으로 **시뮬레이션 없이 수학적으로 직접 계산**하여 효율적으로 문제를 해결하고 있습니다.

## 풀이 2
```java
class Solution {
    public int solution(int n, int w, int num) {
        int diff = n - num;
        int answer = (diff / (2 * w)) * 2 + 1;
        int rest = diff % (2 * w);
        int limit = ((w - num % w) * 2 + 1) % (2 * w);
        if(rest >= limit) answer++;

        return answer;
    }
}
```
이 문제는 컨베이어 벨트에서 택배 상자를 꺼내는 문제로 보이네요. 수식들을 하나씩 분석해드리겠습니다.
## 핵심 변수 의미
```java
int diff = n - num;  // 목표 상자까지 가야 하는 거리
```
## 주요 수식 분석
1. `answer = (diff / (2 * w)) * 2 + 1`

```java
int answer = (diff / (2 * w)) * 2 + 1;
```

- **`2 * w`**: 컨베이어 벨트의 한 사이클(왕복 거리)
    - `w`는 벨트의 한쪽 길이
    - 벨트가 앞으로 `w` 이동 → 뒤로 `w` 이동 = 총 `2w`
- **`diff / (2 * w)`**: 완전한 왕복 사이클 수
    - 목표까지 거리를 한 사이클로 나눈 몫
- **`* 2 + 1`**: 왕복 사이클을 "방향 전환 횟수"로 변환
    - 한 왕복(앞→뒤) = 2번의 방향 전환
    - 시작이 1번째 방향이므로 `+1`

**예시**: `diff=10`, `w=3`이면 `2*w=6`
- 완전 사이클: `10/6 = 1`회
- 방향 전환: `1*2 + 1 = 3`번째 방향

2. `limit = ((w - num % w) * 2 + 1) % (2 * w)`

```java
int limit = ((w - num % w) * 2 + 1) % (2 * w);
```

이건 좀 복잡한데, 단계별로 보면:
- **`num % w`**: 목표 상자의 현재 위치에서의 상대 위치
- **`w - num % w`**: 현재 위치에서 벨트 끝까지의 거리
- **`* 2 + 1`**: 이 거리를 "방향 인덱스"로 변환
    - 앞으로 가는 거리를 2배 하고 +1
- **`% (2 * w)`**: 한 사이클 내로 정규화
**의미**: 목표 상자를 꺼낼 수 있는 "임계 지점"을 나타냅니다.
- 나머지 이동 거리(`rest`)가 이 값보다 크거나 같으면 한 번 더 방향을 전환해야 함

3. `if(rest >= limit) answer++`

```java
int rest = diff % (2 * w);  // 완전 사이클 후 남은 거리
if(rest >= limit) answer++;
```
- 남은 거리가 임계값 이상이면 방향 전환이 한 번 더 필요
- 마지막 불완전한 사이클에서의 추가 방향 전환 처리
## 전체 로직 요약
1. **완전 사이클 계산**: 목표까지의 거리를 왕복 단위로 나눔
2. **방향 전환 횟수 계산**: 왕복을 방향 전환 횟수로 변환
3. **나머지 처리**: 마지막 불완전한 구간에서 추가 방향 전환 필요 여부 판단
이 알고리즘의 핵심은 **컨베이어 벨트의 왕복 운동을 선형적인 방향 전환 횟수로 변환**하는 것입니다!

# 3차 풀이
```java
class Solution {
    public int solution(int n, int w, int num) {
        int result = 0;
        while (num <= n) {
            num += (w - ((num - 1) % w) - 1) * 2 + 1;
            result++;
        }
        
        return result;
    }
}
```
비슷한 유형의 문제를 다음과 같은 순서로 접근해보기
1. 타겟 대상의 상대 위치를 구하기 -> `(num - 1) % w`
2. 상대 위치로부터 끝위치까지의 거리 구하기 -> `w - (상대 위치) - 1`
3. 상자를 쌓으면서 좌 -> 우로 방향이 바뀌므로 x 2 + 1로 다음 줄로 이동