자바 개발자는 JVM에서 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제라는 작업에서 자유로울 수 있다. 하지만 문제가 발생하게 되면 JVM의 메모리 관리 방식을 이해하지 못하는 한 문제 해결이 상당히 어려워진다. 
그렇기 때문에 JVM이 관리하는 다양한 메모리 영역과 각 영역의 역할 등에 대해 알아둬야 한다.
## 2.1 런타임 데이터 영역
![[JVM 구조.png]]
#### 2.2.1 프로그램 카운터
프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트 코드 줄 번호 표시기'라고 볼 수 있다. 다시 말해 프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현한 것이다. 
JVM의 멀티 스레딩은 CPU 코어를 여러 스레드가 교대로 사용하며, 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 그러므로 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 이러한 이유 때문에 **프로그램 카운터(PC)레지스터는 각 스레드의 고유한 공간에 저장된다.**
>[!NOTE] 참고
> 스레드가 자바 메서드를 실행할 땐, 바이트 코드 명령어의 주소가 저장되지만 네이티브 메서드를 실행할 땐 Undefined가 프로그램 카운터에 저장된다.
#### 2.2.2 자바 가상 머신 스택
가상 머신 스택도 스레드 프라이빗하며, 연결된 스레드와 생명주기가 같다. 자바에서 각 **메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장**한다. 이후 스택 프레임을 가상 머신 스택에 push, pop을 반복한다.

지역 변수 테이블에는 자바 가상 머신이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 그리고 지역 변수 테이블에서 이러한 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.

지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 다시 말해 런타임에 해당 공간의 크기(슬롯 개수)는 변하지 않는다.
>[!NOTE] 반환 주소 타입이란?
>  return 문이 실행될 때, 어느 위치로 돌아가야 하는지를 가리킴
>  일반적인 자바 코드에선 다룰 일이 없고, 보통 바이트 코드 수준에서 존재함

#### 2.2.3 네이티브 메서드 스택
가상 머신 스택과 비슷한 역할을 하지만 대상이 네이티브 메서드라는 점에서 다르다. 자바 가상 머신 며엣에 네이티브 메서드 스택에 대해 명시된 것이 없어 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 존재한다. 대표적으로 핫스팟 가상 머신이 그러하다.
#### 2.2.4 자바 힙
힙은 모든 스레드가 공유하는 메모리 영역이며 자바 애플리케이션이 사용할 수 있는 가장 큰 공간이다. 해당 영역의 유일한 목적은 **객체 인스턴스를 저장**하는 것이다.
메모리 할당 관점에서 자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러 개로 나뉜다. 이와 같이 작게 구분하는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.
힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로는 연속되어야 한다. 
> 구현 관점에서 자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보인다.
> 따라서 모든 자바 객체 인스턴스가 힙에 할당된다는 설명이 절대적 진리라고 보기에는 조금씩 애매해지고 있다.
> -> 메서드 내부에서만 사용되는 객체라면 굳이 힙에 할당할 필요 없이 스택에 할당하여 최적화 할 수 있다는 의미?

>[!NOTE] 신세대? 구세대? 에덴 공간?
> 자바 힙을 설명할 때 신세대, 구세대, 영구 세대, 에덴 공간, 생존자 공간에서부터 등의 용어는 GC의 일반적 특성 또는 설계 방식일 뿐이다.

#### 2.2.5 메서드 영역
메서드 영역도 모든 스레드가 공유하는 영역이다. 해당 영역의 목적은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용된다. 
과거 핫스팟 가상 머신 개발 팀에서 GC의 수집 범위를 메서드 영역까지 확장하기로 결정했다. 그래서 메서드 영역을 영구 세대에 구현했다. 이 때문에 많은 사람들이 메서드 영역 == 영구 세대라고 개념을 혼동했다. 자바 가상 머신 명세에선 원칙적으로 메서드 영역을 어떻게 구현할지는 강제하지 않았기에 발생한 현상이었다. 메서드 영역을 영구 세대에 구현한 결정은 오히려 좋은 생각이 아니었다. 메모리 오버 플로를 겪을 가능성이 높아지기 때문이다. JDK 8이 되면서 영구 세대라는 개념을 완전히 지우고 네이티브 메모리에 메타스페이스를 구현했다. 
메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서 회수 효과가 상대적으로 매우 작다. 
>[!NOTE]
>자바 가상 머신 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해 논힙이라고 부르기도 한다.
#### 2.2.6 런타임 상수 풀
런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 메타 데이터에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.