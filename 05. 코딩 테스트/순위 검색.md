---
플랫폼: 프로그래머스
문제 이름: 순위 검색
알고리즘: 재귀, 이진탐색
tags:
  - 재귀
  - 이진탐색
date: 2025-08-15
aliases:
  - 이진탐색
복습 풀이: 250815(X), 250818(X), 250823(X), 250830(X)
---
# 1차 풀이
### 처음 풀이
```java
public int[] solution(String[] info, String[] query) {  
        Map<String, List<Integer>> scoresByCondition = createAllConditions();  
        putScoreByCondition(info, scoresByCondition);  
  
        scoresByCondition.values().forEach(value -> value.sort(Comparator.naturalOrder()));  
  
        List<Integer> results = new ArrayList<>();  
        for (String s : query) {  
            String[] split = s.split(" ");  
            String key = split[0] + split[2] + split[4] + split[6];  
            List<Integer> scores = scoresByCondition.get(key);  
  
            if (scores.isEmpty()) {  
                results.add(0);  
                continue;  
            }  
  
            int idx = findScoreIndex(scores, Integer.parseInt(split[7]));  
            results.add(scores.size() - idx);  
        }  
  
        return results.stream()  
                .mapToInt(Integer::intValue)  
                .toArray();  
    }  
  
    private Map<String, List<Integer>> createAllConditions() {  
        String[] languages = new String[] {"java", "python", "cpp", "-"};  
        String[] categories = new String[] {"backend", "frontend", "-"};  
        String[] careers = new String[] {"senior", "junior", "-"};  
        String[] soulFoods = new String[] {"pizza", "chicken", "-"};  
  
        Map<String, List<Integer>> scoresByCondition = new HashMap<>();  
        for (String language : languages) {  
            for (String category : categories) {  
                for (String career : careers) {  
                    for (String soulFood : soulFoods) {  
                        String target = language + category + career + soulFood;  
                        scoresByCondition.put(target, new ArrayList<>());  
                    }  
                }  
            }  
        }  
  
        return scoresByCondition;  
    }  
  
    private void putScoreByCondition(String[] info, Map<String, List<Integer>> scoresByCondition) {  
        for (String target : info) {  
            String[] split = target.split(" ");  
            List<String> keys = new ArrayList<>();  
//            createKeys(0, Arrays.copyOfRange(split, 0, 4), "", keys);  
            createKeys(0, Arrays.copyOfRange(split, 0, 4), keys);  
            keys.add(String.join("", Arrays.copyOfRange(split, 0, 4)));  
            for (String key : keys) {  
                scoresByCondition.get(key).add(Integer.parseInt(split[4]));  
            }  
        }  
    }  
  
    private void createKeys(int start, String[] conditions, List<String> keys) {  
        if (start == conditions.length) {  
            String join = String.join("", conditions);  
            keys.add(join);  
            return;  
        }  
  
  
        for (int i = start; i < conditions.length; i++) {  
            String swap = conditions[i];  
            conditions[i] = "-";  
            createKeys(i + 1, conditions, keys);  
            conditions[i] = swap;  
        }  
    }  
  
    private int findScoreIndex(List<Integer> scores, int score) {  
        int start = 0;  // inclusive  
        int end = scores.size() - 1;  // inclusive  
  
        while (end > start) {  
            int mid = (start + end) / 2;  
  
            if (scores.get(mid) >= score) {  
                end = mid;  
            } else {  
                start = mid + 1;  
            }  
        }  
  
        if (scores.get(start) < score) {  
            return scores.size();  
        }  
        return start;  
    }
```

### 정답 풀이
```java
public int[] solution(String[] info, String[] query) {  
    Map<String, List<Integer>> scoresByCondition = createAllConditions();  
    putScoreByCondition(info, scoresByCondition);  
  
    scoresByCondition.values().forEach(value -> value.sort(Comparator.naturalOrder()));  
  
    List<Integer> results = new ArrayList<>();  
    for (String s : query) {  
        String[] split = s.split(" ");  
        String key = split[0] + split[2] + split[4] + split[6];  
        List<Integer> scores = scoresByCondition.get(key);  
  
        if (scores.isEmpty()) {  
            results.add(0);  
            continue;  
        }  
  
        int idx = findScoreIndex(scores, Integer.parseInt(split[7]));  
        results.add(scores.size() - idx);  
    }  
  
    return results.stream()  
            .mapToInt(Integer::intValue)  
            .toArray();  
}  
  
private Map<String, List<Integer>> createAllConditions() {  
    String[] languages = new String[] {"java", "python", "cpp", "-"};  
    String[] categories = new String[] {"backend", "frontend", "-"};  
    String[] careers = new String[] {"senior", "junior", "-"};  
    String[] soulFoods = new String[] {"pizza", "chicken", "-"};  
  
    Map<String, List<Integer>> scoresByCondition = new HashMap<>();  
    for (String language : languages) {  
        for (String category : categories) {  
            for (String career : careers) {  
                for (String soulFood : soulFoods) {  
                    String target = language + category + career + soulFood;  
                    scoresByCondition.put(target, new ArrayList<>());  
                }  
            }  
        }  
    }  
  
    return scoresByCondition;  
}  
  
private void putScoreByCondition(String[] info, Map<String, List<Integer>> scoresByCondition) {  
    for (String target : info) {  
        String[] split = target.split(" ");  
        List<String> keys = new ArrayList<>();  
        createKeys(0, Arrays.copyOfRange(split, 0, 4), "", keys);  
        keys.add(String.join("", Arrays.copyOfRange(split, 0, 4)));  
        for (String key : keys) {  
            scoresByCondition.get(key).add(Integer.parseInt(split[4]));  
        }  
    }  
}  
  
private int findScoreIndex(List<Integer> scores, int score) {  
    int start = 0;  // inclusive  
    int end = scores.size() - 1;  // inclusive  
  
    while (end > start) {  
        int mid = (start + end) / 2;  
  
        if (scores.get(mid) >= score) {  
            end = mid;  
        } else {  
            start = mid + 1;  
        }  
    }  
  
    if (scores.get(start) < score) {  
        return scores.size();  
    }  
    return start;  
}  
  
private void createKeys(int depth, String[] conditions, String currentKey, List<String> keys) {  
    if (depth == 4) {  
        keys.add(currentKey);  
        return;  
    }  
  
    createKeys(depth + 1, conditions, currentKey + "-", keys);  
    createKeys(depth + 1, conditions, currentKey + conditions[depth], keys);  
}
```
재귀와 이진 탐색이 함께 섞인 문제.
재귀 부분에 막혀 이진 탐색은 그냥 답안만 복사함

문제 풀이 과정을 살펴보자.
먼저, 문제를 읽어보면 조건을 만족하는 사람 중 코딩 테스트 점수가 n점 이상 받은 사람이 몇 명인가를 찾는 문제다.
**이 부분에서 조건을 만족하는 지원자들을 찾고 이를 기준으로 n점 이상의 지원자 수를 구하면 된다는 것을 알 수 있다.**

여기서 첫 번째 걸림돌이 등장한다.
조건을 담고 있는 query엔 "-"라는 문자열로 해당 자리의 조건에 어떤 값이든 들어갈 수 있도록 만들고 있다.
일단 조건이 일치하는 지원자를 찾으려면 Map이나 클래스를 사용할 수 있을텐데 Map인 경우 정규 표현식을 활용할 수 없다.
**때문에 info를 활용해 미리 각 자리에 "-"문자가 들어간 key를 미리 만들어야 한다.**

여기서 재귀를 활용하게 되는데 이 부분이 첫 번째 걸림돌이었다.
처음엔 첫번째 풀이처럼 작성했는데 케이스가 8개만 생성되었다. 경우의 수를 따져본다면 16가지가 나오는게 정상이었다.

제미나이를 통해 확인해보니 **해당 재귀는 트리 재귀로 분류**할 수 있었다.
```text
재귀는 호출되는 형태에 따라 분류할 수도 있습니다.

- 선형 재귀 (Linear Recursion): 함수가 자기 자신을 한 번만 호출하는 구조입니다. 팩토리얼 계산이 대표적인 예입니다. 호출 흐름이 하나의 선처럼 이어집니다.
    
- 트리 재귀 (Tree Recursion): 함수가 자기 자신을 여러 번(두 번 이상)** 호출하는 구조입니다. `createKeys`에서는 함수 내에서 `createKeys(...)`를 두 번 호출하고 있습니다.
```
내가 처음 사용했던 방식은 선형 재귀이기에 딱 반쪽만 탐색할 수 있었다.

# 2차 풀이
```java
// 1. 100,000 * 50,000 수치로 봤을 때, 모든 조건을 완전 탐색하는 것은 시간 복잡도가 높음
// 2. 조건 중 - 값은 모든 값을 대체할 수 있음
// 3. Map을 사용할 경우, key로 정규 표현식을 사용할 수 없음
// 4. 지원자 정보 info와 -를 조합하여 모든 경우의 수를 키로 만들고 값으로 코테 점수를 오름차순 정렬해 저장
// 5. 조건에 일치하는 키를 가져와 이진 탐색으로 코테 점수를 계산해 결과 도출
import java.util.*;

class Solution {
    public int[] solution(String[] info, String[] query) {
        Map<String, List<Integer>> cases = findCasesByCondition(info);
        List<Integer> results = countByQuery(cases, query);
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    private Map<String, List<Integer>> findCasesByCondition(String[] info) {
        Map<String, List<Integer>> cases = new HashMap<>();
        for (String value : info) {
            String[] conditions = value.split(" ");
            findCase(0, "", Arrays.copyOfRange(conditions, 0, 4), cases, Integer.parseInt(conditions[4]));
        }
        
        cases.entrySet().stream()
            .forEach(entry -> Collections.sort(entry.getValue()));
        return cases;
    }
    
    private void findCase(int depth, String target, String[] conditions, Map<String, List<Integer>> cases, int score) {
        if (depth == conditions.length) {
            List<Integer> scores = cases.getOrDefault(target, new ArrayList<>());
            scores.add(score);
            cases.put(target, scores);
            return;
        }
        
        findCase(depth + 1, target + conditions[depth], conditions, cases, score);
        findCase(depth + 1, target + "-", conditions, cases, score);
    }
    
    private List<Integer> countByQuery(Map<String, List<Integer>> cases, String[] query) {
        List<Integer> results = new ArrayList<>();
        for (String condition : query) {
            String[] conditions = condition.split(" ");
            String key = conditions[0] + conditions[2] + conditions[4] + conditions[6];
            int score = Integer.parseInt(conditions[7]);
            if (!cases.containsKey(key)) {
                results.add(0);
                continue;
            }
            
            List<Integer> scores = cases.get(key);
            
            int idx = findScoreIndex(score, scores);
            results.add(scores.size() - idx);
        }
        
        return results;
    }
    
    private int findScoreIndex(int score, List<Integer> scores) {
        int start = 0;
        int end = scores.size();
        
        while (start < end) {
            int middle = (start + end) / 2;
            
            if (scores.get(middle) < score) {
                start = middle + 1;
            } else {
                end = middle;
            }
        }
        
        return start;
    }
}
```
조건을 조합하는 재귀는 성공적으로 코딩했음
하지만 지난번에 하지 못한 이분 탐색 메서드를 틀림
[[이분 탐색]]을 참고

# 3차 풀이
```java
class Solution {
    public int[] solution(String[] info, String[] query) {
        Map<String, List<Integer>> scoresByCondition = saveScoresByCondition(info);
        List<Integer> results = new ArrayList<>();
        for (String value : query) {
            String[] conditions = value.split(" ");
            String key = conditions[0] + conditions[2] + conditions[4] + conditions[6];
            int targetScore = Integer.parseInt(conditions[7]);
            
            if (!scoresByCondition.containsKey(key)) {
                results.add(0);
                continue;
            }
            
            List<Integer> scores = scoresByCondition.get(key);
            int targetIndex = binarySearch(scores, targetScore);
            results.add(scores.size() - targetIndex);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    private Map<String, List<Integer>> saveScoresByCondition(String[] info) {
        Map<String, List<Integer>> scoresByCondition = new HashMap<>();
        
        for (String value : info) {
            String[] values = value.split(" ");
            String[] conditions = Arrays.copyOfRange(values, 0, 4);
            int score = Integer.parseInt(values[4]);
            saveScoresByKey("", 0, conditions, score, scoresByCondition);
        }
        
        scoresByCondition.values().stream()
            .forEach(value -> value.sort((o1, o2) -> o1 - o2));
        
        return scoresByCondition;
    }
    
    private void saveScoresByKey(String target, int depth, String[] conditions, int score, Map<String, List<Integer>> scoresByCondition) { 
        if (depth == conditions.length) {
            List<Integer> values = scoresByCondition.getOrDefault(target, new ArrayList<>());
            values.add(score);
            scoresByCondition.put(target, values);
            return;
        }
        
        saveScoresByKey(target + conditions[depth], depth + 1, conditions, score, scoresByCondition);
        saveScoresByKey(target + "-", depth + 1, conditions, score, scoresByCondition);
    }
    
    private int binarySearch(List<Integer> scores, int targetScore) {
        int start = 0;
        int end = scores.size() - 1;
        
        while (start < end) {
            int mid = (start + end) / 2;
            
            if (scores.get(mid) >= targetScore) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        
        if (start >= scores.size()) {
            return scores.size();
        }
        
        return start;
    }
}
```
전체적인 풀이의 흐름은 이해함.
다마 아직 이분 탐색을 어떤 기준으로 수행해야 할지 감이 안잡힘
이 문제의 이분 탐색은 다음과 같은 방식들로 구현될 수 있음. 각각의 차이를 곱씹어 보기

| 구분            | 메서드 1 (`start <= end`)           | 메서드 2 (`start < end`, `end` 독점)                 | 메서드 3 (`end > start`)        |
| :------------ | :------------------------------- | :---------------------------------------------- | :--------------------------- |
| **구현 방식**     | 가장 고전적인 방식                       | C++ STL `lower_bound` 스타일                       | 메서드 2와 유사 + 후처리              |
| **탐색 범위**     | `start` 포함, `end` **포함**         | `start` 포함, `end` **미포함**                       | `start` 포함, `end` **포함**     |
| **`end` 초기값** | `scores.size() - 1`              | `scores.size()`                                 | `scores.size() - 1`          |
| **종료 조건**     | `start > end`                    | `start == end`                                  | `start == end`               |
| **특징**        | 직관적이지만 종료 시 `start`와 `end`가 교차함. | `end`가 삽입 위치를 의미. 종료 시 `start`와 `end`가 한곳에서 만남. | 메서드 2와 루프 로직은 같지만, 후처리가 필요함. |

```java
private int binarySearch(List<Integer> scores, int targetScore) { 
	int start = 0; 
	int end = scores.size() - 1; 
	while (start <= end) { 
		int mid = (start + end) / 2; 
		
		if (scores.get(mid) < targetScore) { 
			start = mid + 1; 
		} else { 
			end = mid - 1; 
		} 
	} 
	
	return start; 
}
```

```java
private int binarySearch(List<Integer> scores, int targetScore) {
	int start = 0;
	int end = scores.size();
	
	while (start < end) {
		int mid = (start + end) / 2;
		
		if (scores.get(mid) >= targetScore) {
			end = mid;
		} else {
			start = mid + 1;
		}
	}
	
	return start;
}
```

```java
private int binarySearch(int score, List<Integer> scores) {
	int start = 0;  // inclusive
	int end = scores.size() - 1;  // inclusive

	while (end > start) {
		int mid = (start + end) / 2;

		if (scores.get(mid) >= score) {
			end = mid;
		} else {
			start = mid + 1;
		}
	}

	if (scores.get(start) < score) {
		return scores.size();
	}
	
	return start;
}
```

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(String[] info, String[] query) {
        List<Integer> results = new ArrayList<>();
        Map<String, List<Integer>> cases = findConditionCases(info);
        for (String q : query) {
            String[] splited = q.split(" ");
            String key = splited[0] + splited[2] + splited[4] + splited[6];
            int targetScore = Integer.parseInt(splited[7]);
            
            if (!cases.containsKey(key)) {
                results.add(0);
                continue;
            }
            
            List<Integer> scores = cases.get(key);
            int idx = binarySearch(targetScore, scores);
            
            results.add(scores.size() - idx);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    private Map<String, List<Integer>> findConditionCases(String[] info) {
        Map<String, List<Integer>> cases = new HashMap<>();
        
        for (int i = 0; i < info.length; i++) {
            String[] splited = info[i].split(" ");
            String[] conditions = Arrays.copyOfRange(splited, 0, 4);
            int score = Integer.parseInt(splited[4]);
            createCases(0, "", conditions, score, cases);    
        }
        
        cases.values().forEach(value -> Collections.sort(value));
        return cases;
    }
    
    private void createCases(int depth, String target, String[] conditions, int score, Map<String, List<Integer>> cases) {
        if (depth == conditions.length) {
            List<Integer> scores = cases.getOrDefault(target, new ArrayList<>());
            scores.add(score);
            cases.put(target, scores);
            return;
        }
        
        createCases(depth + 1, target + conditions[depth], conditions, score, cases);
        createCases(depth + 1, target + "-", conditions, score, cases);
    }
    
    private int binarySearch(int targetScore, List<Integer> scores) {
        int start = 0;
        int end = scores.size() - 1;
        
        while (start <= end) {
            int mid = (start + end) / 2;
            
            if (scores.get(mid) >= targetScore) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return start;
    }
}
```
또 이진 탐색에서 틀림
반복적으로 계속 풀어보자.