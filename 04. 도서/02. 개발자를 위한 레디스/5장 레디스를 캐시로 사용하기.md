# 1. 다양한 캐싱 전략

## 1.1 읽기 전략 - Look Aside 전략
### 동작 방식
- 데이터 조회 요청
- 캐시에 데이터가 존재하는지 확인
	- 존재한다면 캐시 히트 
	- 존재하지 않는다면 캐시 미스
- 데이터가 없다면 **DB에 접근**해 데이터를 조회
- 조회한 데이터를 캐시에 저장
### 주요 특징
레디스 장애에도 DB에서 데이터를 조회할 수 있음
대신 DB에 많은 부하가 몰릴 수 있음

데이터가 레디스에 없을 때만 저장되기 때문에 지연 로딩 구조로 볼 수 있다.
만약 트래픽이 많은 기존 서비스에 레디스를 도입하게 되면 초기에 DB에 많은 부하가 발생할 수 있다.
이를 방지 하기 위해 **레디스에 미리 데이터를 저장하는 캐시 워밍**을 수행한다.

가장 중요한 점은 캐시와 DB 사이의 데이터 정합성이 깨질 수도 있다는 점이다.
그러므로 데이터가 자주 변경되지 않는 경우에 사용하는 것이 좋다.

## 1.2 읽기 전략 - Read Through 전략
### 동작 방식
- 데이터 조회 요청
- 캐시에 데이터가 존재하는지 확인
	- 존재한다면 캐시 히트
	- 존재하지 않는다면 캐시 미스
- 데이터가 없다면 **DB에 직접 접근**해 데이터를 조회한 뒤 캐시에 해당 데이터를 갱신
- 캐시에서 데이터를 조회
### 주요 특징
Look Aside 전략과 비슷하지만 캐시 미스 이후의 과정을 수행하는 주체가 다르다.
Read Through 전략에서 **캐시에 데이터를 동기화하는 주체는 캐시 제공자에게 있다**. 
이러한 특징 덕에 데이터 베이스의 직접 접근을 최소화하고, 데이터 정합성이 깨지지 않지만 **캐시 제공자(레디스)에 장애가 생길 경우 서비스 전체 장애로 전파**될 수 있다.
이외의 주요 특징은 Look Aside 전략과 유사하다.

## 1.3 쓰기 전략 - Write Back 전략
### 동작 방식
- 모든 데이터를 캐시에 저장
- 일정 시간이 지난 후 DB에 마이그레이션
### 주요 특징
데이터의 저장/갱신을 캐시에서 수행 후 일정 시간마다 DB에 데이터를 마이그레이션하는 것이 주요 특징이다.
DB에 가해지는 부하를 줄일 수 있는 장점이 존재하지만 캐시에 장애가 발생하면 데이터 유실이 발생할 수도 있는 단점이 존재한다.
또한 캐시에서 데이터를 갱신하기에 데이터 정합성은 자동으로 보장된다.

이러한 특징에 **쓰기가 빈번하며, 읽기에 많은 자원이 소모되는 서비스에 유리한 전략**이다.

## 1.4 쓰기 전략 - Write Through 전략
### 동작 방식
- 쓰기 요청이 들어오면 우선 캐시에 저장
- 이후 바로 DB에 해당 데이터 저장
### 주요 특징
캐시, DB 데이터 쓰기가 같이 일어나기 때문에 항상 동기화 된 정보를 가진다는 점이 가장 큰 장점이다.
하지만 매번 캐시와 DB에 데이터를 쓰기 때문에 리소스 낭비가 존재한다.
데이터 정합성이 중요한 금융 도메인과 같은 곳에서 활용될 수 있는 전략이다.

## 1.5 쓰기 전략 - Write Around 전략
### 동작 방식
- 쓰기 요청이 들어오면 데이터를 바로 DB에 저장
- 캐시에는 저장하지 않음
### 주요 특징
캐시 미스가 발생할 때만 캐시에 데이터를 저장하고, 쓰기 요청 시엔 DB에만 데이터를 쓰기 때문에 데이터 정합성이 깨질 수 있다. 
때문에 읽기보다 쓰기가 중요한 서비스에 활용될 수 있다.(로깅 시스템 같은 경우)

## 1.6 전략 조합
- **Look Aside + Write Around**(가장 일반적)
- **Read Through + Write Around**(데이터 정합성 보장)
- **Read Through + Write Through**(캐시에 최신 데이터 보장, 데이터 정합성 보장?)

# 2. 캐시 스탬피드
![[Redis - 캐시 스탬피드.png|600]]
Look Aside 전략 사용 시, 캐시 미스 때문에 원본 저장소에서 데이터를 가져와 캐시에 적재하는 상황이 발생할 수 있다.
이를 캐시 스탬피드 현상이라고 한다.

해결책은 다음 세 가지가 존재한다.
- **잠금(Locking) 방식** 
	- 한 요청 처리 스레드가 해당 캐시 키에 대한 잠금을 획득. 이로 인해 다른 요청 처리 스레드들은 잠시 대기
	- 잠금을 획득한 스레드는 사용자 요청에 응답하는 과정동안 캐시 적재 작업은 비동기 스레드로 처리
	- 잠금을 사용하기 때문에 성능 저하 가능성이 존재하며, 잠금 획득 스레드의 실패, 잠금의 생명 주기, 데드락 등 다양한 상황을 고려해야한다는 단점이 존재
- **외부 재계산(External Recomputation) 방식** 
	- 모든 요청 처리 스레드가 캐시 적재를 수행하지 않음. 
	- 대신, 캐시를 주기적으로 모니터링하는 스레드를 별도로 관리하여 캐시의 만료시간이 얼마 남지 않은 경우, 데이터를 갱신하여 문제를 예방. 
	- 해당 방식은 다시 사용되지 않을 데이터를 포함하여 갱신하기 때문에 메모리에 대한 불필요한 연산이 발생하고, 메모리 공간을 비효율적으로 사용할 가능성이 존재
- **확률적 조기 재계산(Probablistic Early Recomputation) 방식**
	- 캐시 만료 시간이 얼마 남지 않았을 경우, 확률이라는 개념을 사용하여 여러 요청 처리 스레드 중에서 적은 수만이 캐시를 적재하는 작업을 수행하여 스탬피드 현상을 완화

읽어보면 좋은 글
https://toss.tech/article/34481