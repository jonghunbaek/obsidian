# 3.1 들어가며
GC의 역사는 1960년 MIT에서 개발된 리스프라는 언어이며, 자바의 역사보다 훨씬 오래됐다.
리스프의 창시자인 존 맥카시가 말한 'GC가 처리해야 할 문제' 세 가지
- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 하나?
- 어떻게 회수해야 하나?
다시 말해, GC의 주된 역할은 적절한 시기에 적절한 방법으로 적절한 메모리 영역의 데이터를 회수해야 하는 것이다.
또한 객체의 생명 주기는 런타임에만 알 수 있기에 메모리 회수와 할당은 동적으로 수행해야 한다. 

# 3.2 대상이 죽었는가?
자바에서 거의 모든 객체 인스턴스는 힙에 저장된다. 
GC가 힙을 청소하려면 객체의 생사 여부를 판단해야 한다.
이번 절에선 객체의 생사 판단 기준에 대해 알아보자.

### 3.2.1 참조 카운팅 알고리즘
객체의 생서 여부를 판단하는 가장 기초적이고 단순한 알고리즘이다.
- 객체를 가리키는 참조 카운터를 추가
- 참조하는 곳이 하나 늘어날 때마다 카운터 값++
- 참조하는 곳이 하나 줄어들 때마다 카운터 값--
- 카운터 값이 0인 인스턴스는 더 사용될 수 없음

하지만 여러 예외 케이스를 고려할 때, 실제 JVM에서 해당 알고리즘을 사용하는 것은 불가능하다.
대표적으로 순환 참조 문제가 존재한다. 
```java
/**  
 * VM Option : -Xlog:gc* 
*/
public class ReferenceCouningGC {  
    public Object instance = null;  
    private static final int _1MB = 1024 * 1024;  
    private byte[] bigSize = new byte[2 * _1MB];  
  
    public static void testGC() {  
        ReferenceCouningGC objA = new ReferenceCouningGC();  
        ReferenceCouningGC objB = new ReferenceCouningGC();  
  
        objA.instance = objB;  
        objB.instance = objA;  
  
        objA = null;  
        objB = null;  
  
        System.gc();  
    }  
  
    public static void main(String[] args) {  
        testGC();  
    }  
}
```
![[순환 참조 객체 회수 로그.png]]
-> 위 코드 실행을 통해 JVM은 참조 카운팅 알고리즘을 사용하지 않음을 알 수 있음

### 3.2.2 도달 가능성 분석 알고리즘
참조 카운팅 알고리즘의 한계는 명확하기에 현재 주류 프로그래밍 언어는 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 활용한다. 

이 알고리즘의 핵심은 GC루트라고 하는 루트 객체를 시작 노드 집합으로 삼아 참조 객체들을 탐색해 나가는 것이다. 이 과정에서 만들어진 경로를 참조 체인이라고 한다. 
이 때, **특정 객체에 대한 참조 체인이 존재하지 않는다면 해당 객체는 회수 대상**이 된다. 
![[도달 가능성 분석 알고리즘의 객체 생사 판별.png]]

#### GC루트로 사용될 수 있는 객체 목록
- VM 스택에서 참조하는 객체(매개 변수, 지역 변수 등 지역 변수 테이블)
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체(문자열 테이블 안의 참조 -> String 상수 풀)
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- JVM 내부에서 쓰이는 참조(기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체)
- 동기화 락으로 잠겨있는 모든 객체
- JVM 내부 상황을 반영하는 JMXBean
- 그 외 GC 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시 추가 될 수 있음
GC루트로부터 참조를 탐색하는 과정에서 주의할 점은 한 객체가 다른 영역에 존재하는 객체를 참조할 수도 있다는 점이다. 그러므로 연관된 영역의 객체들도 GC루트 집합에 포함해야 알고리즘을 정확하게 구현할 수 있다. 

### 3.2.3 참조의 개념
전통적인 참조의 개념은 다음과 같다.
- 참조 타입 데이터에 저장된 값이 다른 메모리 조각의 시작 주소를 뜻한다면, 이 참조 데이터를 해당 메모리 조각이나 객체를 참조한다고 말한다.

현 시점에서 해당 개념은 범위가 좁다. 
그래서 현재는 참조 개념을 확장해 아래와 같이 네 가지로 구분한다.
- **강한 참조**
	- 가장 전통적인 참조
	- 프로그램 코드에서 참조를 할당하는 것이며 **GC 회수 대상이 아님**
- **부드러운 참조**
	- 유용하지만 필수는 아닌 객체를 표현
	- 메모리 오버플로 발생 직전에 두 번째 회수를 위한 회수 목록에 추가됨
	- **두 번째 회수 이후에도 메모리가 부족한 경우 회수 대상이 됨**
- **약한 참조**
	- 부드러운 참조와 비슷하지만 연결 강도가 더 약함
	- **다음 가비지 컬렉션까지만 생존**
- **유령 참조**
	- 객체 수명에 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것은 불가능

>[!NOTE]
> **finalize()** 
> 도달 불가능한 객체라고 해서 반드시 회수 되어야 하는 것은 아니다. 
> 확실한 회수 대상이 되려면 두 번의 표시 과정을 거쳐야 하는데 이 때 활용되는 것이 finalize()다.
> 실행 비용도 높고 불확실성도 크기에 절대 사용 하지마라

### 3.2.4 메서드 영역 회수
메서드 영역은 GC의 회수 대상이 아니다는 거짓이다.
다만, 메서드 영역의 회수는 조건이 까다롭고 비용 효율이 좋지 않다. .

메서드 영역에서 GC의 회수 대상은 크게 상수, 클래스 두 가지다.
상수의 경우 'java'라는 리터럴을 참조하는 문자열 객체가 전혀 없다면 해당 상수는 회수 대상이 된다. 
클래스의 경우 다음 세 가지 조건을 만족해야 한다.
- 힙 영역에 해당 클래스와 하위 클래스의 인스턴스가 존재하지 않음
- 해당 클래스를 읽어들인 클래스 로더가 회수 되어야 함
- 해당 클래스의 java.lang.Class 객체를 참조하는 객체가 없고, 리플렉션으로도 해당 기능을 이용하지 않아야 함
**-> 회수를 허용한다지 반드시 회수하는 것은 아님**

## 3.3 가비지 컬렉션 알고리즘
이번 절에서 소개하는 알고리즘은 모두 추적 GC(도달 가능성 분석)에 속한다.
### 3.3.1 세대 단위 컬렉션 이론
세대 단위 컬렉션 이론은 다음과 같은 가설에서 시작하며, 현재 사용 VM 대부분이 해당 이론에 기초해 설계 됐다.
- **약한 세대 가설** - 대다수 객체는 일찍 죽는다.
- **강한 세대 가설** - GC 회수 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
이 가설에 따라 **자바 힙을 몇 개의 영역으로 구분하고, 객체들의 나이에 따라 각기 다른 영역에 할당하는 것**이 세대 단위 컬렉션 이론의 핵심이다.

힙 영역을 몇 가지로 구분하면 GC는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC(신세대), 메이저 GC(구세대), 전체 GC로 구분할 수 있다. 
각 영역의 객체 생존 특성에 따라 마크-스윕, 마크-카피, 마크-컴패트 알고리즘을 구분해 회수하게 된다.

이 이론에 기초하여 VM 설계자들은 보통 자바 힙을 두 개 영역으로 구분한다. 
- **신세대**
- **구세대**
GC 회수 과정에서 살아 남은 신세대 영역의 객체들은 구세대 영역으로 승격된다. 

#### 그렇다면 이 두 가지 이론으로 완벽한 설계가 가능할까?
객체들은 단독으로 존재하지 않고 다른 세대에 존재하는 객체들을 참조하는 상황이 존재하기 때문에 두 가설만 가지고 완벽한 설계를 하는 것은 불가능 하다. 
예를 들어, 신세대에서만 가비지 컬렉션을 수행하고 싶어도 구세대에서 신세대의 객체를 참조 중인 경우가 존재한다. 반대의 경우도 마찬가지인데, 이 경우 구세대 전체를 탐색하는 것은 성능 면에서 부담이 크다. 
그러므로 **도달 가능성을 분석할 때, 고정된 GC 루트뿐만 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰**할 수 있다.

#### 약점을 어떻게 보완할까?
앞선 두 가설의 예외 케이스를 보완하기 위해 아래 가설이 추가적으로 필요하다.
- **세대 간 참조 가설** - 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
**즉, 상호 참조 관계의 두 객체는 생명 주기가 비슷한 경향이 있다.**
이 가설에 따르면 세대 간 참조의 수는 적기에 구세대 전체를 탐색하는 것은 낭비다. 

이를 해결하기 위해 신세대에 **기억 집합**이라는 전역 데이터 구조를 둔다.
이 구조는 **구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 기록해 관리하기 위함**이다.
마이너 GC가 수행되면 세대 간 참조를 포함하는 작은 메모리 블록 안의 객체들만 GC 루트에 추가된다. 

### 3.3.2 마크-스윕 알고리즘
해당 알고리즘은 가장 기본적인 가비지 컬렉션 알고리즘이다.
![[마크-스윕 알고리즘.png]]
방식은 아래와 같다. 
- 회수할 객체를 표시
- 표시된 객체를 회수
단순한만큼 큰 단점이 두 가지 존재한다.
- **실행 효율이 일정하지 않음**
	- 객체가 많아질수록 효율이 떨어짐
- **메모리 파편화가 심함**
	- GC가 회수하고 간 자리에 불연속적인 메모리 파편이 만들어짐
	- 파편화가 심해지면 큰 객체를 만들 수 없고, 이에 추가적인 가비지 컬렉션이 발생

### 3.3.3 마크-카피 알고리즘
앞선 마크-스윕 알고리즘의 단점을 해결하기 위해 나온 알고리즘이다 .
해당 알고리즘은 **가용 메모리 영역을 이등분하여 한 번에 한 블록만 사용**한다.
![[마크-카피 알고리즘.png]]
위 그림에서 볼 수 있듯이 메모리 파편화 문제를 해결할 수 있다. 하지만 여전히 아래와 같은 문제가 존재한다.
- 회수 대상이 적은 경우 여전히 비용 효율이 나쁨(대다수가 회수된다면 ㄱㅊ)
- 이등분하여 한 영역만 사용하기 때문에 메모리 공간을 낭비
#### 그럼에도 불구하고 오늘날 대부분의 상용 VM은 해당 방식을 채택
IBM의 연구 결과 신세대 객체 중 98%가 첫 번째 가비지 컬렉션에서 회수된다는 것을 알게 됐다. 
그러므로 가용 메모리 영역을 반드시 이등분할 필요가 없게 된다. 
이 이론을 구체화하면 아래와 같다.
- 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눔
- 이 공간의 비율은 8(에덴) : 1(생존자)이다.
- 메모리 할당시 생존자 공간 하나와 에덴만 사용
- 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 복사 후 에덴과 이전 생존자 공간을 지운다.
이를 통해 메모리 낭비 공간을 10%로 줄일 수 있다.

#### 만약 10%(생존자 공간 크기)가 넘는 크기의 객체들이 살아 남는다면?
98%의 객체가 회수된다는 연구 결과는 일반적인 상황을 가정한 결과다.
이를 해결하기 위해 **메모리 할당 보증**이란 메커니즘이 추가된다.
마이너 GC에서 생존한 객체를 생존자 공간에 모두 할당하지 못한다면, 다른 메모리 영역(대부분 구세대)을 활용해 메모리 할당을 보증하는 것이 핵심이다.

### 3.3.4 마크-컴팩트 알고리즘
마크-카피 알고리즘에서 해결하지 못한 문제 하나가 여전히 남아 있다.
- **객체 생존율이 높을수록 효율이 떨어진다.**
때문에 마크-카피 알고리즘은 구세대에는 적합하지 않다. 
