---
플랫폼: 프로그래머스
문제 이름: 큰 수 만들기
알고리즘: 그리디
tags:
  - 그리디
date: 2025-10-09
aliases:
  - 그리디
복습 풀이: 251009(X), 251012(O), 251020(O)
---
# 1차 풀이
```java
// 1. 숫자의 정렬상태는 유지
// 2. 앞에서부터 반복하며, 0 ~ 9의 인덱스를 가진 배열의 값을 ++
// 3. replace()를 사용해 가장 낮은 숫자의 값부터 주어진 개수만큼 삭제

class Solution {
    public String solution(String number, int k) {
        int[] numbers = new int[10];
        for (char c : number.toCharArray()) {
            numbers[c - '0']++;
        }

        int idx = 0;
        while (k > 0) {
            int value = numbers[idx];
            if (value > 0 && value <= k) {
                number = number.replace(String.valueOf(idx), "");
                k -= value;
            } else if (value > 0 && value > k) {
                for (int i = 0; i < number.length(); i++) 
            }
            
            idx++;
            continue;
        }
        
        return "";
    }
}
```
최초 접근 방식이나 시간 복잡도가 제대로 고려되지 않고, 가장 큰 문제로 문제 해결의 접근 방식 자체가 잘못됐음

결과적으로 보니 스택으로 쉽게 풀 수 있었음. 
```java
import java.util.*;

class Solution {
    public String solution(String number, int k) {
        Stack<Character> stack = new Stack<>();
        for (char c : number.toCharArray()) {
            while (k > 0 && !stack.isEmpty() && c > stack.peek()) {
                stack.pop();
                k--;
            }
            
            stack.push(c);
        }
        
        while (k-- > 0) {
            stack.pop();
        }
        
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        
        return sb.reverse().toString();
    }
}
```
하지만 문제를 볼 때, 스택 자료구조가 전혀 생각나지 않았음

# 2차 풀이
```java
// 1. 문자열 앞에서부터 순회하며 값을 스택에 저장
// 2. 스택의 최상단 값과 다음 원소의 값을 비교해 원소의 값이 크다면 스택의 값을 꺼내고 k--
// 3. 그렇지 않다면 스택에 넣기
// 4. 이러한 방식으로 앞에서부터 큰 숫자를 넣고 작은 숫자를 제거해 가장 큰 수를 구할 수 있음
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(String number, int k) {
        Stack<Character> stack = new Stack<>();
        for (char c : number.toCharArray()) {
            while (!stack.isEmpty() && stack.peek() < c && k > 0) {
                stack.pop();
                k--;
            }
            
            stack.push(c);
        }
        
        while (k > 0) {
            k--;
            stack.pop();
        }
        
        return stack.stream()
            .map(c -> String.valueOf(c))
            .collect(Collectors.joining());
    }
}
```
왜 스택을 써야하는지 곱씹어 보며 풀어보기

# 3차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(String number, int k) {
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < number.length(); i++) {
            while (!stack.isEmpty() && stack.peek() < number.charAt(i) && k > 0) {
                stack.pop();
                k--;
            }
            
            stack.push(number.charAt(i));
        }
        
        while (k > 0) {
            stack.pop();
            k--;
        }
        
        return stack.stream()
            .map(c -> String.valueOf(c))
            .collect(Collectors.joining());
    }
}
```