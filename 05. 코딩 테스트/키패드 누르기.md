---
플랫폼: 프로그래머스
문제 이름: 키패드 누르기
알고리즘: 구현
tags:
  - 구현
date: 2025-09-23
aliases:
  - 구현
복습 풀이: 250923(O), 251006(O)
---
# 1차 풀이
```java
class Solution {
    public String solution(int[] numbers, String hand) {
        String[] results = new String[numbers.length];
        String[][] keypad = initKeypad();

        String left = "*";
        String right = "#";
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == 1 || numbers[i] == 4 || numbers[i] == 7) {
                results[i] = "L";
                left = String.valueOf(numbers[i]);
                continue;
            }

            if (numbers[i] == 3 || numbers[i] == 6 || numbers[i] == 9) {
                results[i] = "R";
                right = String.valueOf(numbers[i]);
                continue;
            }

            String direction = findCloserThumb(numbers[i], left, right, keypad, hand);
            if (direction.equals("right")) {
                results[i] = "R";
                right = String.valueOf(numbers[i]);
            } else {
                results[i] = "L";
                left = String.valueOf(numbers[i]);
            }
        }

        return String.join("", results);
    }

    private String[][] initKeypad() {
        String[][] keypad = new String[4][3];
        int value = 1;
        for (int i = 0; i < keypad.length - 1; i++) {
            for (int j = 0; j < keypad[i].length; j++) {
                keypad[i][j] = String.valueOf(value++);
            }
        }

        keypad[3][0] = "*";
        keypad[3][1] = String.valueOf(0);
        keypad[3][2] = "#";

        return keypad;
    }

    private String findCloserThumb(int number, String left, String right, String[][] keypad, String major) {
        int[] leftPoint = new int[2];
        int[] rightPoint = new int[2];
        int[] targetPoint = new int[2];

        for (int i = 0; i < keypad.length; i++) {
            for (int j = 0; j < keypad[i].length; j++) {
                if (keypad[i][j].equals(String.valueOf(number))) {
                    targetPoint[0] = i;
                    targetPoint[1] = j;
                }

                if (keypad[i][j].equals(left)) {
                    leftPoint[0] = i;
                    leftPoint[1] = j;
                }

                if (keypad[i][j].equals(right)) {
                    rightPoint[0] = i;
                    rightPoint[1] = j;
                }
            }
        }

        int leftLength = Math.abs(leftPoint[0] - targetPoint[0]) + Math.abs(leftPoint[1] - targetPoint[1]);
        int rightLength = Math.abs(rightPoint[0] - targetPoint[0]) + Math.abs(rightPoint[1] - targetPoint[1]);

        if (leftLength < rightLength) {
            return "left";
        } else if (leftLength > rightLength) {
            return "right";
        } else {
            return major;
        }
    }
}
```
구현에만 집중해 깔끔하지 않음

# 2차 풀이
```java
// 1. 키패드를 구현한 2차원 배열을 생성
// 2. Hand라는 객체로 왼손/오른손 구현(direction, x, y)
// 3.
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers, String hand) {
        int[][] keypad = createKeypad();
        Hand myHand = new Hand(hand);
        
        return Arrays.stream(numbers)
            .mapToObj(number -> myHand.moveTo(number, keypad[number]))
            .collect(Collectors.joining());
    }
    
    private int[][] createKeypad() {
        int[][] keypad = new int[10][2];
        int row = 0;
        int col = 0;
        for (int i = 1; i < 10; i++) {
            if (col == 3) {
                row++;
                col = 0;
            }
            
            keypad[i] = new int[] {row, col++};
        }
        
        keypad[0] = new int[] {3, 1};
        
        return keypad;
    }
    
    static class Hand {
        String priority;
        Point leftPoint;
        Point rightPoint;
        
        public Hand(String priority) {
            this.priority = priority;
            this.leftPoint = new Point(0, 3);
            this.rightPoint = new Point(2, 3);
        }
        
        public String moveTo(int number, int[] point) {
            if (isLeft(number)) {
                moveLeft(point);
                return "L";
            } else if (isRight(number)) {
                moveRight(point);
                return "R";
            } 
            
            if (findCloserDirection(point).equals("L")) {
                moveLeft(point);
                return "L";    
            } else {
                moveRight(point);
                return "R";
            }
        }
        
        private boolean isLeft(int number) {
            return number == 1 || number == 4 || number == 7;
        }
        
        private boolean isRight(int number) {
            return number == 3 || number == 6 || number == 9;
        }
        
        private void moveLeft(int[] point) {
            leftPoint.y = point[0];
            leftPoint.x = point[1];
        }
        
        private void moveRight(int[] point) {
            rightPoint.y = point[0];
            rightPoint.x = point[1];
        }
        
        private String findCloserDirection(int[] point) {
            int leftDistance = Math.abs(leftPoint.y - point[0]) + Math.abs(leftPoint.x - point[1]);
            int rightDistance = Math.abs(rightPoint.y - point[0]) + Math.abs(rightPoint.x - point[1]);
   
            if (leftDistance > rightDistance) {
                return "R";
            } else if (leftDistance < rightDistance) {
                return "L";
            } else {
                return priority.equals("left") ? "L" : "R";
            }
        }
    }
    
    static class Point {
        int x;
        int y;
        
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```