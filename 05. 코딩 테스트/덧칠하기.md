---
플랫폼: 프로그래머스
알고리즘: 그리디
tags:
  - 그리디
date: 2025-12-30
복습 풀이: 251230(O)
---
# 1차 풀이
```java
// 슬라이딩 윈도우? 누적합?

class Solution {
    public int solution(int n, int m, int[] section) {
        boolean[] sectionToPaint = new boolean[n + 1];
        for (int s : section) sectionToPaint[s] = true;
        
        int count = 0;
        for (int i = 1; i <= n; i++) {
            if (!sectionToPaint[i]) continue;
            
            sectionToPaint[i] = false;
            if (i + m - 1 <= n) {
                sectionToPaint[i + m - 1] = false;    
            } else {
                sectionToPaint[n] = false;
            }
            
            i += m - 1;
            count++;
        }
        
        return count;
    }
}
```
처음에 슬라이딩 윈도우나 구간합 같은 알고리즘을 써야하나 생각이 들었음
하지만 알고리즘을 쓰지 않고, 탐색 범위를 m만큼 더하며 계산하면 O(n)으로 해결 가능

다른 사람의 풀이를 보니 더 간단하게 해결도 가능함
```java
class Solution {
    public int solution(int n, int m, int[] section) {
        int maxPainted = 0, cntPaint = 0;
        for (int point : section) {
            if (maxPainted <= point) {
                maxPainted = point + m;
                cntPaint++;
            }
        }
        return cntPaint;
    }
}
```