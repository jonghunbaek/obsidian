# 1. 문제점
데이터를 관리하는 시스템에선 내결함성을 위해 데이터를 여러 서버로 복제한다.
그런데 여러 서버에 데이터를 복제할 경우, **클라이언트가 일관되지 못한 데이터를 응답받을 수**도 있다.
따라서 여러 서버로 데이터가 복제될 때는 **클라이언트가 데이터를 언제 볼 수 있게 할지 결정**해야 한다.

이 문제를 해결하는 데에 과반수 정족수 읽기/쓰기는 충분한 해결책이 아니다. 
개별 서버는 정족수 내 다른 서버의 데이터 상태를 알지 못하기 때문에 강한 일관성을 보장할 수 없다.

# 2. 해결책
이를 해결하기 위한 해결책으로 리더-팔로워 모델을 선택할 수 있다.
리더는 전체 **클러스터를 대표해 결정을 내리고, 그 결정을 다른 모든 서버에게 전달할 책임**이 있다.

리더-팔로워 모델에서 리더는 주로 쓰기 요청을 처리하며, 이를 통해 **쓰기 일관성을 보장**할 수 있다.
팔로워는 주로 읽기 요청을 처리하는데, 어떻게 읽기 일관성을 보장할 수 있을까?


그럼 이런 리더를 어떻게 선출할 수 있을까?
### 일반적인 리더 선출(작은 클러스터)
노드가 셋에서 다섯으로 구성된 작은 클러스터에선 별도의 외부 시스템에 의존하지 않고 **자체적으로 리더를 선출**할 수 있다.
리더 선출은 서버를 구동할 때 발생하며, 새로운 리더를 선출할 때마다 세대 번호를 갱신한다.
-> 장애 후 재구동한 경우도 마찬가지

이 방식에서 서버는 다음 세 가지 상태 중 하나로만 존재할 수 있다.
- 리더
- 팔로워
- 리더 탐색

새로운 리더 선출은 동료 서버에게 투표 요청을 보내며 시작한다.
-> 자신을 뽑아달라고 투표 요청을 보내는 것임
이 때, 리더를 선출하는 가장 중요한 조건은 다음과 같다.
- 가장 최신 상태의 서버만이 합법적으로 리더가될 수 있음
- 모든 서버가 동일한 최신 상태라면 구현체에 따라 다를 수 있음
	- 잽은 특정 기준으로 우선 순위를 나눔
	- 래프트는 한 번에 한 서버만 투표를 하므로, 가장 먼저 선거를 시작한 서버를 리더로 선택
>[!최신 상태]
>여기서 말하는 최신 상태란, **최신의 세대 시계**와 쓰기 전 로그의 **최신 로그 인덱스**를 의미한다.

>[!분리 투표]
>분리 투표는 일종의 Split Brain 문제로 볼 수 있다.
>간단히 말하자면, **여러 노드가 동시에 자신이 리더가 되겠다고 선언하며 서로 다른 서버에게 투표하는 상황**을 일컫는다. 
>이는 결국 어느 서버든 과반수의 표를 받지 못하게 되는 문제를 야기한다. 
>이를 해결하기 위한 방법은 다음과 같다.
> - 무작위 지연(래프트 - 선거 시작 전, 랜덤한 타임아웃 설정)
> - 합의 알고리즘(잽 - 모든 서버가 같은 로직으로 리더를 선택)

### 일관성 코어를 이용한 리더 선출
>[!일관성 코어]
>강한 일관성이 필요한 핵심 데이터나 로직을 별도로 분리해서 관리하는 아키텍처
>CAP(Consistency, Avaliability, Partition tolerance)이론에 따라 세 가지를 완벽히 보장할 수는 없기에 중요한 부분만 일관성을 보장, 나머지는 최종적 일관성과 같은 약한 일관성 모델 사용

클러스터의 규모가 수천대의 노드로 구성된 경우라면 일관성 코어를 사용하는 편이 수월하다. 
일관성 코어는 내부적으로 합의를 사용하며 선형성을 보장한다.
대규모 클러스터에선 일반적으로 마스터 또는 컨트롤러 노드로 지정한 서버를 두는데, 이 서버는 전체 클러스터를 대신해 모든 결정을 내린다. 

리더 선출을 구현하기 위해 세 가지가 필요하다.
- **키를 원자적으로 설정하기 위한 CAS(Compare And Swap)명령어**
- **리더에게 하트비트를 받지 못하면 키를 만료해 새 선거를 발동할 수 있는 하트비트 구현**
- **키가 만료되면 관심 있는 모든 서버에 알릴 수 있는 알림 메커니즘**

리더 선출은 아래와 같은 방식으로 이루어진다.
- CAS 명령어를 사용해 외부 저장소에 키 생성 시도
	- 가장 먼저 생성한 서버가 리더로 선출
	- 키는 짧은 TTL로 생성
- 선출된 리더는 만료 시간전에 키를 갱신
- 모든 서버에선 이 키를 감시하며, 만료 시 알림을 받게 됨
- 리더가 다운됐다고 판단 후 새로운 리더 선출
>[! ttl 구현 방식]
>모든 구현체에서 TTL이 존재하는 것은 아니다.
>주키퍼의 경우 명시적인 유효 기간은 없지만 '일시 노드'라는 개념이 존재한다. 
>서버가 주키퍼와 활성 세션을 유지하는 동안에는 노드가 존재하지만, 그렇지 않으면 노드를 제거하고 감시하는 모든 대상에게 알린다. 

