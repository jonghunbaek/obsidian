---
플랫폼: 프로그래머스
문제 이름: 호텔 방 배정
알고리즘: 유니온파인드,
tags:
  - 유니온파인드
date: 2025-09-17
aliases:
  - 유니온파인드
복습 풀이: 250917(X), 250921(X), 251004(X), 251011(O), 251017(O)
---
# 1차 풀이
```java
import java.util.*;
// 1. 방번호를 키로 Room을 값으로 Map 생성
    // 2. 키가 존재하지 않는다면 방 선택
    // 3. 키가 존재한다면 더 큰 번호의 방을 찾아야 함.
    //  3-1. 방번호를 합칠 땐, 가장 큰 숫자를 부모로 변경해줌
    //  3-2. 가장 큰 숫자가 부모로 변경될 땐, Map애 그 다음 숫자가 키로 존재하는지 확인하고 존재한다면 해당 방과 합침
class Solution {
    
    public long[] solution(long k, long[] room_number) {
        List<Long> results = new ArrayList<>();
        Map<Long, Room> roomByNo = new HashMap<>();
        for (long no : room_number) {
            long next = no;
            if (roomByNo.containsKey(no)) { // 방이 이미 선택됐다면 숫자가 더 큰 방번호 선택
                next = roomByNo.get(no).rootNo() + 1;
            }

            Room room = new Room(next);
            roomByNo.put(next, room);
            if (roomByNo.containsKey(next - 1)) {
                room.merge(roomByNo.get(next - 1));
            }

            if (roomByNo.containsKey(next + 1)) {
                room.merge(roomByNo.get(next + 1));
            }

            results.add(next);
        }

        return results.stream()
                .mapToLong(Long::longValue)
                .toArray();
    }

    static class Room {
        int depth;
        long no;
        Room parent;

        public Room(long no) {
            this.no = no;
            this.depth = 1;
            this.parent = null;
        }

        public long rootNo() {
            return root().no;
        }

        public Room root() {
            if (parent == null) {
                return this;
            }

            return parent.root();
        }

        public void merge(Room other) {
            if (root() == other.root()) {
                return;
            }

            Room room1 = root();
            Room room2 = other.root();

            if (room1.depth > room2.depth) {
                room2.parent = room1;
            } else if (room1.depth < room2.depth) {
                room1.parent = room2;
            } else {
                room2.parent = room1;
                room1.depth++;
            }

            room1.no = room2.no = Math.max(room1.no, room2.no);
        }
    }
}
```
전체적인 접근은 괜찮았지만 구현을 못해 틀림
유니온 파인드에 익숙하지 않은 것도 한 몫함

아래처럼 간단하게도 풀이 가능함(유니온 파인드가 아닌 일종의 DP - 메모이제이션을 활용한 재귀)
```java
import java.util.*;

class Solution {
    Map<Long, Long> map = new HashMap<>();

    public long[] solution(long k, long[] room_number) {
        int n = room_number.length;
        long[] answer = new long[n];

        for (int i = 0; i < n; i++) {
            answer[i] = findEmptyRoom(room_number[i]);
        }

        return answer;
    }
    
    private long findEmptyRoom(long room) {
        if (!map.containsKey(room)) {
            map.put(room, room + 1);
            return room;
        }
        
        long nextRoom = map.get(room);
        long emptyRoom = findEmptyRoom(nextRoom);
        map.put(room, emptyRoom);
        return emptyRoom;
    }
}
```

# 2차 풀이
```java
import java.util.*;

class Solution {
    public long[] solution(long k, long[] room_number) {
        List<Long> rooms = new ArrayList<>();
        
        Map<Long, Node> nodes = new HashMap<>();
        for (long number : room_number) {
            if (nodes.containsKey(number)) {
                number = nodes.get(number).max() + 1;
            }
            
            Node node = new Node(number);
            nodes.put(number, node);
            if (nodes.containsKey(number - 1)) {
                node.merge(nodes.get(number - 1));
            } 
            
            if (nodes.containsKey(number + 1)) {
                node.merge(nodes.get(number + 1));
            }
            
            rooms.add(number);
        }
        
        return rooms.stream()
            .mapToLong(Long::longValue)
            .toArray();
    }
    
    static class Node {
        int depth = 1;
        Node parent = null;
        long max;
        
        public Node(long value) {
            this.max = value;
        }
        
        public void merge(Node other) {
            if (root() == other.root()) {
                return;
            }
            
            Node r1 = root();
            Node r2 = other.root();
            
            if (r1.depth > r2.depth) {
                r2.parent = r1;
            } else if (r1.depth < r2.depth) {
                r1.parent = r2;
            } else {
                r2.parent = r1;
                r1.depth++;
            }
            
            r1.max = r2.max = Math.max(r1.max, r2.max);
        }
        
        public Node root() {
            if (parent == null) {
                return this;
            }
            
            return this.parent.root();
        }
        
        public long max() {
            return root().max;
        }
    }
}
```
유니온 파인드에 대한 감을 전혀 잡지 못하겠네

# 3차 풀이

```java
import java.util.*;

class Solution {
    public long[] solution(long k, long[] room_number) {
        Map<Long, Long> nextNoByNo = new HashMap<>();
        long[] results = new long[room_number.length];
        for (int i = 0; i < room_number.length; i++) {
            results[i] = getRoomNo(room_number[i], nextNoByNo);
        }
        
        return results;
    }
    
    private long getRoomNo(long currentNo, Map<Long, Long> nextNoByNo) {
        if (!nextNoByNo.containsKey(currentNo)) {
            nextNoByNo.put(currentNo, currentNo + 1);
            return currentNo;
        }
        
        long nextNo = nextNoByNo.get(currentNo);
        return getRoomNo(nextNo, nextNoByNo);
    }
}
```
해당 풀이는 정확도는 맞으나 효율성에서 탈락.
빈방을 찾은 다음 현재 방번호와 빈방번호를 연결해 경로를 압축해줘야 함.
유니온 파인드의 파인드를 응용한 문제라고 볼 수 있음

# 4차 풀이
```java
// 1. 현재 방 번호 키가 존재하지 않는다면 방 배정
// 2. 존재한다면 값을 얻어 방배정
// 3. 방배정 이후엔 다음 방번호를 다시 Map에 저장하여 단축

import java.util.*;

class Solution {
    public long[] solution(long k, long[] room_number) {
        Map<Long, Long> nextByRoom = new HashMap<>();
        
        long[] result = new long[room_number.length];
        for (int i = 0; i < result.length; i++) {
            result[i] = findRoomNo(room_number[i], nextByRoom);
        }
        
        return result;
    }
    
    private long findRoomNo(long roomNo, Map<Long, Long> nextByRoom) {
        if (!nextByRoom.containsKey(roomNo)) {
            nextByRoom.put(roomNo, roomNo + 1);
            return roomNo;
        }
        
        long next = nextByRoom.get(roomNo);
        long result = findRoomNo(next, nextByRoom);
        nextByRoom.put(roomNo, result);
        
        return result;
    }
}
```
탐색 과정을 단축시켜 성공
이전 풀이에서 배웠듯 유니온 파인드의 변형 형태로 볼 수 있음

# 5차 풀이
```java
import java.util.*;

class Solution {
    public long[] solution(long k, long[] room_number) {
        long[] results = new long[room_number.length];
        Map<Long, Long> nextByRoom = new HashMap<>();
        for (int i = 0; i < room_number.length; i++) {
            results[i] = findRoomNo(room_number[i], nextByRoom);
        }
        
        return results;
    }
    
    private long findRoomNo(long roomNo, Map<Long, Long> nextByRoom) {
        if (!nextByRoom.containsKey(roomNo)) {
            nextByRoom.put(roomNo, roomNo + 1);
            return roomNo;
        }
        
        long nextNo = findRoomNo(nextByRoom.get(roomNo), nextByRoom);
        nextByRoom.put(roomNo, nextNo);
        
        return nextNo;
    }
}
```
익숙해질때까지 더 풀어보기