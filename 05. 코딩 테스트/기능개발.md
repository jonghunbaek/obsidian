---
플랫폼: 프로그래머스
문제 이름: 기능개발
알고리즘: 큐
tags:
  - 큐
date: 2025-09-02
aliases:
  - 큐
복습 풀이: 250902(X), 250907(O), 250913(O), 250920(O)
---
# 1차 풀이
### 최초 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Double> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer(Math.ceil(((double) 100 - progresses[i]) / speeds[i]));
        }

        List<Integer> results = new ArrayList<>();
        int count = 0;
        int previous = Integer.MAX_VALUE;
        while (!q.isEmpty()) {
            if (previous >= q.peek()) {
                count++;
                previous = q.poll().intValue();
                continue;
            }

            results.add(count);
            count = 0;
            previous = Integer.MAX_VALUE;
        }

        results.add(count);

        return results.stream()
                .mapToInt(Integer::intValue)
                .toArray();
    }
}
```
접근 방향은 좋았으나 세부적인 구현이 잘못됨
이유는 아래와 같음
```text
다음과 같이 각 기능의 배포까지 남은 일수가 `[10, 5, 8]`일 경우를 생각해 보겠습니다.
- 올바른 로직:
    1. 첫 번째 기능이 **10일** 걸리므로 기준일은 `10`일이 됩니다.
    2. 두 번째 기능은 5일 걸립니다. (`5 <= 10` 이므로 함께 배포)
    3. 세 번째 기능은 8일 걸립니다. (`8 <= 10` 이므로 함께 배포)
    4. 결과: `[3]` (세 기능 모두 한 번에 배포)
        
- 현재 코드의 로직:
    1. `previous`는 초깃값(`Integer.MAX_VALUE`), 큐의 첫 값은 `10`입니다. `MAX_VALUE >= 10`이므로 배포 묶음에 포함시킵니다.
        - `count`는 1이 됩니다.
        - `previous`는 **10**으로 업데이트됩니다.
    2. `previous`는 `10`, 큐의 다음 값은 `5`입니다. `10 >= 5`이므로 배포 묶음에 포함시킵니다.
        - `count`는 2가 됩니다.
        - `previous`는 **5**로 업데이트됩니다. **<-- 🚨 문제 발생 지점**
    3. `previous`는 `5`, 큐의 다음 값은 `8`입니다. `5 >= 8`은 거짓이므로 배포가 여기서 끊깁니다.
        - 결과 리스트에 `count` 값인 `2`를 추가합니다.
    4. 이후 남은 `8`이 새로운 배포 묶음으로 처리되어 결과에 `1`이 추가됩니다.
    5. 최종 결과: `[2, 1]` (잘못된 결과)
        
이처럼 기준이 되는 `previous` 값을 묶음 내에서 더 작은 값으로 갱신해버리기 때문에, 원래 함께 배포되어야 할 기능(`8`일)이 누락되는 문제가 발생합니다.
```

### 올바른 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }

        List<Integer> results = new ArrayList<>();
        while (!q.isEmpty()) {
            int deployDay = q.poll();
            int count = 1;

            while (!q.isEmpty() && q.peek() <= deployDay) {
                q.poll();
                count++;
            }
            results.add(count);
        }

        return results.stream()
                .mapToInt(Integer::intValue)
                .toArray();
    }
}
```

# 2차 풀이
```java
class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        int[] completions = new int[progresses.length];
        for (int i = 0; i < progresses.length; i++) {
            completions[i] = (int) Math.ceil((100.0 - progresses[i]) / speeds[i]);
        }
        
        Queue<Integer> q = new LinkedList<>();
        List<Integer> results = new ArrayList<>();
        int count = 0;
        for (int i = 0; i < completions.length; i++) {
            if (!q.isEmpty() && q.peek() < completions[i]) {
                int limit = q.peek();
                while (!q.isEmpty() && completions[i] > limit) {
                    q.poll();
                    count++;
                }
                
                results.add(count);
                count = 0;
            }
            
            q.add(completions[i]);
        }
        
        while (!q.isEmpty()) {
            q.poll();
            count++;
        }
        
        if (count != 0) {
            results.add(count);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
지난 풀이 방법을 확인하고, 조금 더 간단하고 깔끔하게 풀어보기

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> tasks = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            tasks.add((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }
        
        List<Integer> results = new ArrayList<>();
        while (!tasks.isEmpty()) {
            int count = 1;
            int current = tasks.poll();
            while (!tasks.isEmpty() && tasks.peek() <= current) {
                tasks.poll();
                count++;
            }
            
            results.add(count);
            count = 1;
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
스택/큐 관련 문제는 여러번 풀어도 매번 낯설음
근데 또 푸는건 잘 풀게 됨
구현 과정을 천천히 곱씹어 보며 한 번 더 풀어 볼것

# 4차 풀이
```java
import java.util.*;

// 1. 작업 일수를 계산하여 큐에 넣기
// 2. 큐가 비어있지 않고 큐의 다음 값이 현재 값보다 작다면 count++
// 3. 큰 값이 나오면 결과 값을 List에 넣고 count초기화
class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }
        
        int count = 1;
        List<Integer> results = new ArrayList<>();
        while (!q.isEmpty()) {
            int current = q.poll();
            while (!q.isEmpty() && q.peek() <= current) {
                q.poll();
                count++;
            }
            
            results.add(count);
            count = 1;
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
