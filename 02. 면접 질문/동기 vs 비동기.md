동기는 요청에 대한 응답이 와야 다음 작업을 시작하므로 순차적인 작업을 수행한다고 볼 수 있습니다.
비동기는 요청에 대한 응답이 오지 않아도 다음 요청을 보내므로 비순차적인 작업을 수행한다고 볼 수 있습니다.


### Java에서 비동기 방식을 구현하는 방법은?
만약 Spring을 같이 활용한다면 @Async 어노테이션으로 쉽게 사용할 수 있음
다만 @Async의 경우 Spring AOP를 기반으로 작동하기에 AOP 사용시 발생할 수 있는 문제들을 고려하여 사용해야 함
- Self-Invocation 문제(private/final 메서드에선 사용 불가, 같은 클래스 내에서 다른 메서드를 호출하는 경우)
- 별도의 비동기용 예외 핸들러 추가 필수
- 비동기에서 생성된 트랜잭션은 상위 트랜잭션과 별도의 트랜잭션
- 별도의 스레드풀 관리 필요

Java로만 구현이 된다면 
- `CompletableFuture` (Java 8+): 콜백(Callback) 방식의 단점(Callback Hell)을 보완하고, 비동기 작업들을 조합하거나 체이닝(Chaining)하여 복잡한 비동기 로직을 선언적으로 구성할 수 있습니다. 예외 처리나 결과 처리도 용이하여 현대 Java 비동기 프로그래밍의 핵심입니다.
- **`ExecutorService` & `Future`:** 스레드 풀(`ExecutorService`)에 작업을 제출(`submit`)하고, 작업의 결과를 담는 `Future` 객체를 즉시 반환받는 방식입니다. 다만 `Future`만 사용할 경우, 작업이 완료되었는지 확인하기 위해 `get()` 메서드를 호출해야 하는데, 이는 스레드를 블로킹시키는 단점이 있습니다.
- `Thread` 클래스 직접 사용: 가장 기본적인 방법이지만, 스레드의 생성과 소멸에 따른 오버헤드가 크고 관리가 어려워 일반적으로는 `ExecutorService`와 같은 스레드 풀을 사용하는 것이 권장됩니다.

### 비동기 방식을 사용할 때 주의점은?
비동기를 흔히 성능을 높이는 마법같은 기술로 알고 있는 사람이 많음.
응답을 기다리지 않고 요청을 여러개 보낼 수 있다는 점에서 어느정도 타당하지만, 그 응답을 처리는 시점이 더욱 중요해짐
- **스레드 풀 관리:** 비동기 작업은 별도의 스레드에서 실행됩니다. 부하가 많은 서비스에서 요청마다 스레드를 생성하면 오히려 시스템 자원 고갈로 성능이 저하될 수 있습니다. 따라서 **애플리케이션의 특성에 맞는 적절한 크기의 스레드 풀을 설정하고 관리**하는 것이 매우 중요
- **복잡한 예외 처리 및 디버깅:** 작업 흐름이 분리되기 때문에 예외가 발생한 지점을 추적하기 어렵고, 스택 트레이스(Stack Trace)가 복잡해져 디버깅이 까다로워집니다. 위에서 언급한 것처럼 **비동기 작업에 특화된 예외 처리 전략**이 반드시 필요합니다.
- **데이터 일관성:** 여러 비동기 작업이 공유 자원에 동시에 접근할 경우 **경쟁 상태(Race Condition)**나 **교착 상태(Deadlock)**가 발생할 수 있습니다. 따라서 스레드 안전성(Thread-Safety)을 신중하게 고려하여 코드를 설계해야 합니다.
- **코드 복잡도 증가:** 동기 코드에 비해 비동기 코드는 실행 순서를 예측하기 어렵고, 콜백이나 체이닝 로직으로 인해 코드의 가독성이 떨어질 수 있습니다.

### 블로킹/논블로킹과 동기/비동기의 차이점은?
블로킹/논블로킹은 현재 작업 중인 스레드의 활성 상태를 블락하냐 안하냐에 가장 큰 차이가 있음
예를 들어, I/O 작업시 블로킹이 된다면 해당 스레드는 유휴 상태에 빠지고 그 시간동안 아무 작업을 할 수 없음
만약 논블로킹으로 작업한다면 해당 스레드는 I/O 작업 요청을 보내고 다른 작업을 수행하게 됩니다. 이후 I/O작업 완료 신호가 오면 해당 작업을 이어 수행함

따라서 블로킹/논블로킹과 동기/비동기의 차이는 스레드의 유휴 상태, 요청/응답을 받는 시점에 따라 다른 개념으로 볼 수 있습니다. 

블로킹/논블로킹과 동기/비동기는 자주 혼동되지만, **관점의 차이**를 이해하는 것이 핵심입니다.
- **블로킹(Blocking) / 논블로킹(Non-Blocking):** **호출된 함수(Callee)가 호출한 함수(Caller)에게 제어권을 즉시 반환하는지**에 대한 관점입니다. 즉, **제어권의 흐름**에 대한 이야기입니다.
    - 블로킹: 호출된 함수가 자신의 작업을 마칠 때까지 호출한 함수의 제어권을 계속 가지고 있으며, 호출한 함수는 멈춥니다.
    - 논블로킹: 호출된 함수가 바로 제어권을 호출한 함수에게 넘겨주어, 호출한 함수가 다른 일을 할 수 있도록 합니다.
- **동기(Synchronous) / 비동기(Asynchronous):** **호출한 함수(Caller)가 호출된 함수(Callee)의 작업 완료 여부를 신경 쓰는지**에 대한 관점입니다. 즉, **결과를 기다리는 주체**에 대한 이야기입니다.
    - 동기: 호출한 함수가 호출된 함수의 작업 결과를 직접 계속 확인하며 기다립니다.
    - 비동기: 호출한 함수는 작업 요청만 하고 결과는 신경 쓰지 않습니다. 대신 호출된 함수가 콜백 등을 통해 결과를 처리합니다.