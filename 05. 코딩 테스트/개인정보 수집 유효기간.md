---
플랫폼: 프로그래머스
알고리즘:
tags:
date: 2025-12-31
복습 풀이: 251231(X), 260105(O)
---
# 1차 풀이
```java
// 문자열, 구현, 해시
// 1. 약관별 유효 기간 Map에 저장
// 2. 문자열 날짜를 int[] 형태로 변환
// 3. prvacies를 순회하며, 약관 종류별로 유효 기간 더하기 
// 4. 결과 값을 오늘 날짜와 비교하여 파기해야 한다면 List에 담아 반환
import java.util.*;

class Solution {
    public int[] solution(String today, String[] terms, String[] privacies) {
        Map<String, Integer> expirationByTerm = new HashMap<>();
        for (String term : terms) {
            expirationByTerm.put(term.split(" ")[0], Integer.parseInt(term.split(" ")[1]));
        }
        
        int[] todayArr = toIntArr(today);
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < privacies.length; i++) {
            int[] target = toIntArr(privacies[i].split(" ")[0]);
            int expirationMonth = expirationByTerm.get(privacies[i].split(" ")[1]);
            
            int[] expirationDay = addExpirationMonth(target, expirationMonth);
            if (isOver(todayArr, expirationDay)) results.add(i + 1);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    private int[] toIntArr(String target) {
        String[] split = target.split("\\.");
        int year = Integer.parseInt(split[0]);
        int month = Integer.parseInt(split[1]);
        int day = Integer.parseInt(split[2]);
        
        return new int[] {year, month, day};
    }
    
    private int[] addExpirationMonth(int[] target, int expiration) {
        int yearAdd = target[0] + expiration / 12;
        int monthAdd = target[1] + expiration % 12;
        if (monthAdd > 12) {
            monthAdd = monthAdd - 12;
            yearAdd++;
        }
        
        if (target[2] == 1) {
            monthAdd--;    
            if (monthAdd == 0) {
                monthAdd = 12;
                yearAdd--;
            }
        }
        int dayAdd = target[2] == 1 ? 28 : target[2] - 1;
 
        return new int[] {yearAdd, monthAdd, dayAdd};
    }
    
    private boolean isOver(int[] today, int[] targetDay) {
        if (targetDay[0] < today[0]) return true;
        if (targetDay[1] < today[1]) return true;
        if (targetDay[2] < today[2]) return true;
        
        return false;
    }
}
```
기본 테케만 통과하고 나머진 다틀림
- isOver 메서드에서 치명적인 논리 오류가 존재해서 틀림
- addExpirationMonth가 계속 문제라는 생각에 사로잡힘

그리고 시간/날짜 관련 문제에서 까다로운 계산이 반복된다면 다른 단위로 바꾸는 것은 어떨지 우선 고민해보기
여기선 year, month, day를 일단위로 통일해서 int로 계산했다면 훨씬 수월했음

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(String today, String[] terms, String[] privacies) {
        int theDay = toDay(today);
        Map<String, Integer> expirationByTerm = new HashMap<>();
        for (String term : terms) {
            expirationByTerm.put(term.split(" ")[0], Integer.parseInt(term.split(" ")[1]));
        }
        
        List<Integer> results = new ArrayList<>();
        for (int i = 0; i < privacies.length; i++) {
            String[] split = privacies[i].split(" ");
            int targetDay = toDay(split[0]);
            int expiration = expirationByTerm.get(split[1]);
            
            if (targetDay + expiration * 28 <= theDay) results.add(i + 1);
        }
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
    
    private int toDay(String target) {
        String[] split = target.split("\\.");
        int year = Integer.parseInt(split[0]);
        int month = Integer.parseInt(split[1]);
        int day = Integer.parseInt(split[2]);
        
        return (year * 12 * 28) + (month * 28) + day; 
    }
}
```

`if (targetDay + expiration * 28 <= theDay) results.add(i + 1);`에서 -1을 하지 않았음에도 통과한 이유는 다음과 같음
- 부등호를 `<=`로 설정하고 `-1`을 상쇄시킨 형태
- 즉 `if (targetDay + expiration * 28 - 1 < theDay`와 같음
- 