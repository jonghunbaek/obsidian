JVM은 컴파일된 클래스 파일을 메모리로 읽어 들이고, 그 데이터를 검증/변환/초기화하고 나서 최종적으로 VM이 곧바로 사용할 수 있는 자바 타입을 생성한다. 
이를 클래스 로딩 메커니즘이라고 한다.

6장에 잠깐 나왔듯 자바는 컴파일 타임에 링킹이 일어나지 않는다. 자바에서 클래스 로딩, 링킹, 초기화는 모두 프로그램 실행 중에 일어난다. 
그렇기에 AOT 컴파일에 제약이 생기고 실행 성능이 떨어질 수 밖에 없다. 반대로 높은 확장성, 유연성이라는 장점이 존재한다. 

# 1. 클래스 로딩 시점
![[JVM 7장 - 클래스 로딩 메커니즘.png|700]]
로딩 → 검증 → 준비 → 초기화 → 언로딩은 반드시 순서대로 진행되어야 하지만 해석은 그렇지 않다. 
해석은 초기화 이후에도 시작할 수 있는데, 동적 바인딩을 지원하기 위함이다.
여기서 각 단계 진행 순서의 기준은 '시작'시점이다. 즉, 각 단계의 종료 시점은 앞서 말한 순서와 다를 수 있다. 

>[!NOTE]
>**정적 바인딩 vs 동적 바인딩**
>정적 바인딩은 컴파일 타임에 메서드 호출이 결정된다. 오버로딩,  static 메서드, private 메서드에서 발생한다.
>동적 바인딩은 런타임에 메서드 호출이 결정된다. 오버라이딩 메서드에서 발생한다.(다형성)

## 초기화 단계 촉발 
자바 가상 머신 명세에 따르면 초기화가 즉시 일어나야 하는 6가지 상황을 엄격하게 규정하며, 이러한 경우들을 **능동 참조**라고 한다.
- new, getstatic, putstatic, invokestatic과 같은 명령어를 만났을 때 해당 타입이 초기화 되지 않은 경우
	- new 키워드로 인스턴스 생성
	- 타입의 정적 필드를 읽거나 설정(final까지 붙은 경우 컴파일 타임에 설정됨)
	- 타입의 정적 메서드 호출
- 리플렉션 메서드를 사용할 때 해당 타입이 초기화 되지 않은 경우
- 클래스 초기화 시 상위 클래스가 초기화 되어 있지 않은 경우
- VM 구동 직후 main() 메서드가 존재하는 타입의 초기화
- java.lang.invokeMethodHandler 인스턴스를 호출할 때 해당 하는 클래스가 초기화 되어 있지 않은 경우
- 인터페이스에 default 메서드가 정의되었고, 해당 인터페이스를 구현하는 클래스를 초기화할 때 인터페이스부터 초기화

### 수동 참조 vs 능동 참조
능동 참조와 수동 참조의 주요한 차이는 참조하는 클래스의 초기화 여부에 달렸다. 능동 참조가 일어나는 경우 참조하는 타입에 대한 초기화가 먼저 일어나지만 수동 참조는 그렇지 않다.
수동 참조가 일어나는 상황은 다음과 같다.
- 정적 필드를 참조할 때 발생하며, 필드를 직접 정의한 클래스만 초기화 된다.
- 배열 정의에서 클래스를 참조하는 경우 -> SuperClass[] sca = new SuperClass[10]; 
	- 이 경우 JVM이 Object로부터 곧바로 상속하여 자동으로 하위 클래스를 생성하므로 실제 타입은 '원소 타입이 SuperClass인 일차원 배열'이다.
- 상수를 참조하는 경우(상수 전파 최적화)
	- 상수는 **컴파일 과정에서 호출하는 클래스의 상수 풀에 저장되므로 상수를 정의한 클래스로의 직접적인 참조가 없어지게** 된다.
	- 즉, 컴파일 후에 상수를 호출하는 클래스와 정의하는 클래스의 연결점은 없다.

# 2. 클래스 로딩 처리 과정

## 로딩
JVM은 로딩 단계에서 다음 세 가지 작업을 수행한다.
- 완전한 이름을 보고 해당 클래스를 정의하는 바이너리 바이트 스트림 읽기
- 바이트 스트림으로 표현된 정적인 저장 구조를 메서드 영역에서 사용하는 런타임 데이터 구조로 변환
- 로딩 대상 클래스를 표현하는 java.lang.Class 객체를 힙 메모리에 생성
	- Class 객체는 애플리케이션에서 메서드 영역에 저장된 타입 데이터를 활용할 수 있는 통로가 됨

자바 가상 머신 명세에서 로딩에 대한 요구 사항을 세세하게 정의하지 않아 다음과 같은 장점을 얻을 수 있게 됐다.
- ZIP 압축 파일로부터 로딩 - JAR, WAR, EAR의 기초가 됨
- 네트워크로부터 로딩 - 웹 애플릿
- 런타임에 동적으로 생성 - JDK 동적 프록시
- 다른 파일로부터 생성 - JSP 
- DB로부터 로딩 - SAP 넷위버
- 암호화된 파일로부터 로딩 - 보안

클래스 로딩은  JVM에 내장된 부트스트랩 클래스 로더 또는 사용자 정의 클래스 로더를 사용해 수행할 수 있다. 
하지만 배열 클래스는 클래스 로더가 생성하지 않고 JVM이 직접 메모리에 동적으로 생성한다. 
-> 하지만 배열의 원소 타입은 여전히 클래스 로더를 통해 로드 된다.

배열 클래스 생성 과정은 다음 규칙을 따른다.
- 배열의 컴포넌트 타입이 참조 타입이면 로딩 과정을 재귀적으로 수행하여 컴포넌트 타입을 로딩
- 배열 클래스는 컴포넌트 타입을 로드하는 클래스 로더의 namespace에 저장됨
- 컴포넌트 타입이 참조 타입이 아니면 배열 클래스를 부트스트랩 클래스 로더에게 위임
- 배열 클래스의 접근성은 해당 컴포넌트 타입과 같음

>[!NOTE]
>**배열의 컴포넌트 타입**
>배열에서 첫 번째 차원이 제거된 타입을 의미하며, int\[]\[]와 같은 경우엔 int\[] 1차원 배열이 컴포넌트 타입이 된다.

## 검증
검증은 링킹 과정 중 첫 번째 단계이며, 두 가지 목적을 가진다.
- 클래스 파일의 구조가 자바 가상 머신 명세에서 규정한 모든 제약 조건을 만족하는지 검증
- 코드로 변환해 실행했을 때 JVM 자체의 보안을 위협하는지 검증

검증 단계가 필요한 이유는 클래스 파일이 반드시 자바 소스 코드로부터 만들어지는 것이 아니기 때문이다. 
그러므로 JVM은 자신을 보호하기 위해 검증 단계를 반드시 수행해야 한다.
이러한 이유에 따라 만약 모든 코드를 신뢰할 수 있다면 생략할 수 있는 선택 단계가 되기도 한다.

현재 검증 단계는 굉장히 많은 양의 검증을 수행하며, 다음과 같이 4가지 유형으로 분류할 수 있다.
- 파일 형식 검증
- 메타데이터 검증
- 바이트 코드 검증
- 심볼 참조 검증

### 파일 형식 검증
바이트 스트림이 클래스 파일 형식에 부합하고, 현재 버전의 VM에서 처리될 수 있는지 검증한다.
주된 목적은 입력 바이트 스트림이 올바르게 해석되어 메서드 영역에 저장되었는지, 파일 형태가 자바 타입 정보 설명에 대한 요구 사항을 준수하는지 확인하는 것이다.
즉, **이 유형의 검증은 다른 유형의 검증과 달리 바이트 스트림을 대상으로 한다.**

### 메타데이터 검증
바이트 코드로 설명된 정보의 의미를 분석해  서술된 정보가 요구사항을 준수하는지 검증한다.
주된 목적은 클래스의 메타데이터 정보에 대한 의미론적 검증을 수행하는 것이다.

### 바이트 코드 검증
가장 복잡한 단계이며, 시간이 오래 걸린다. 
주된 목적은 데이터 흐름과 제어 흐름을 분석해 프로그램의 의미가 적법하고 논리적인지를 검증하는 것이다. 
이 검증을 통과했다고 해서 100% 안전하다고 보장할 수는 없다. 즉, 로직에 버그가 존재하는지 완벽하게 검증할 수는 없다. 

수행 시간이 복잡하고 긴 문제를 해결하기 위해 메서드 본문 Code 속성의 속성 테이블에 StackMapTable이라는 속성을 추가했다. 
덕분에 바이트 코드 검증 단계에서 지역 변수 테이블과 피연산자 스택의 상태를 추론할 필요가 없어졌다.

### 심볼 참조 검증
해당 검증은 VM이 심벌 참조를 직접 참조로 변환할 때 수행된다. 이 변환은 해석 단계에서 이뤄진다. 
주된 목적은 상수 풀의 다양한 심벌 참조 같은 클래스 자체를 제외한 모든 정보를 확인하는 것이다. 
즉, **현재 클래스가 참조하는 외부 클래스, 메서드, 필드 등의 자원들에 접근할 권한이 있는지 확인**한다.

## 준비
준비는 클래스 변수를 메모리에 할당하고 초깃값을 설정하는 단계다.
JDK 7까지는 클래스 변수가 메서드 영역에 할당된다고 말하는 것이 타당했다 그 때는 영구 세대에 메서드 영역을 구현했기 때문이다.
하지만 JDK8부터 메서드 영역은 메타 스페이스로 이동했기에 현재는 타당하지 않다.
즉, 현재 클래스 변수는 클래스 객체와 함께 힙 영역에 저장된다. 그러므로 클래스 변수는 메서드 영역에 존재한다라는 말은 논리적으로만 그렇다는 이야기다.

준비 단계에서 초깃값이 설정되는 변수는 인스턴스 변수가 아닌 클래스 변수만 해당된다.
준비 단계에서 클래스 변수에 초깃갓은 해당 데이터 타입의 제로 값으로 설정된다.
하지만 static final같이 final이 붙은 경우엔 ConstantValue에 지정한 값을 할당한다. 

## 해석
해석은 JVM이 상수 풀의 심벌 참조를 직접 참조로 대체하는 과정이다. 

### 심벌 참조 vs 직접 참조
먼저, 심벌 참조와 직접 참조가 의미하는 바에 대해 알아보자.
- **심벌 참조**
	- 몇 가지 심벌로 참조 대상을 설명하며, 대상을 명확하게 가리키는데 이용될 수 있는 모든 형태의 리터럴이 될 수 있다. 
	- VM의 메모리 레이아웃과는 무관하며, 참조 대상이 반드시 VM의 메모리에 로드되어 있을 필요도 없다. 
- **직접 참조**
	- 포인터, 상대적 위치(오프셋) 또는 대상의 위치를 간접적으로 가리키는 핸들이다.
	- VM의 메모리 레이아웃과 유관하며, 같은 심벌 참조를 변환하더라도 직접 참조는 VM에 따라 달라질 수 있다. 
	- 또한 참조 대상이 VM의 메모리에 존재해야 한다.

JVM 명세에서 해석 단계를 수행하는 시간을 특정하지 않고, 심벌 참조를 다루는 바이트 코드 명령어들에 대해 실행하도록 규정한다.
**즉, 특정 시점이 아닌 특정 명령어를 기준으로 해석하기에 동적 바인딩이 가능해진다.** 

해석 단계에선 또한 메서드나 필드에 접근 권한이 있는지 확인한다.(private, protected 등)
동일한 심벌 참조에 대해 여러 번 해석 요청이 이뤄지므로 첫 번째 결과를 캐시해두는 것이 일반적이며 특정 심벌 참조 해석이 성공했다면 다음 번에도 성공해야 하고, 실패했다면 다음 번에도 실패해야 한다. 
단, invokedynamic의 명령어 해석 결과는 캐시하지 않는다.

java 모듈 vs spring 모듈