---
플랫폼: 프로그래머스
문제 이름: 체육복
알고리즘: 그리디
tags:
  - 그리디
date: 2025-10-08
aliases:
  - 그리디
복습 풀이: 251009(X), 251012(O)
---
# 1차 풀이
```java
import java.util.*;

// 2 0 2 0 2
class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] array = new int[n];
        Arrays.fill(array, 1);
        
        for (int l : lost) {
            array[l - 1]--;
        }
        
        for (int r : reserve) {
            array[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] >= 1) {
                count++;
                continue;
            }
            
            if (array[i] == 0 && i > 0 && i < n - 1) {
                if (array[i - 1] < 2 && array[i + 1] < 2) {
                    continue;
                }
                
                if (array[i - 1] >= 2) {
                    count++;
                    array[i - 1]--;
                    continue;
                }
                
                if (array[i + 1] >= 2) {
                    count++;
                    array[i + 1]--;
                }
            }
        }
        
        return count;
    }
}
```
경계 조건을 잘못 설정해 틀림.
배열의 첫번째와 마지막에 대한 요소도 조건문 안에 포함되도록 변경해야 함
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] array = new int[n];
        Arrays.fill(array, 1);
        
        for (int l : lost) {
            array[l - 1]--;
        }
        
        for (int r : reserve) {
            array[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] >= 1) {
                count++;
                continue;
            }
            
            if (array[i] == 0) {
                // 왼쪽 학생에게 빌리기
                if (i > 0 && array[i - 1] >= 2) {
                    count++;
                    array[i - 1]--;
                    continue;
                }
                
                // 오른쪽 학생에게 빌리기
                if (i < n - 1 && array[i + 1] >= 2) {
                    count++;
                    array[i + 1]--;
                }
            }
        }
        
        return count;
    }
}
```
단순 구현 느낌으로 풀었는데, 책을 보니 다른 풀이가 존재하니 참고할 것

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] students = new int[n];
        Arrays.fill(students, 1);
        for (int l : lost) {
            students[l - 1]--;
        }
        
        for (int r : reserve) {
            students[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (students[i] >= 1) {
                count++;
                continue;
            }
            
            if (i > 0 && students[i - 1] > 1) {
                students[i - 1]--;
                count++;
                continue;
            }
            
            if (i < n - 1 && students[i + 1] > 1) {
                students[i + 1]--;
                count++;
            }
        }
        
        return count;
    }
}
```
1차 풀이와 달리 경계 값을 제대로 명시해 첫 번째, 마지막 원소도 검사할 수 있도록 수정
