바이트 코드를 중간 단계로 볼 때, 네이티브 코드로 변환하는 과정은 전체 컴파일 과정 중 백엔드라고 볼 수 있다.
이러한 백엔드 역할을 하는 컴파일러가 바로 JIT컴파일러와 AOT 컴파일러다.

두 컴파일러 모두 JVM에서 필수 요소는 아니다.
→ JVM 명세 기준이므로 VM에 따라 지원 기능과 구현 방식이 완전히 다를 수 있음
하지만 두 컴파일러의 컴파일 성능과 품질은 **상용 VM의 우수성을 좌우하는 핵심 지표이기 때문에 사실상 필수**에 가깝다.

# 1. JIT 컴파일러
자주 실행 되는 메서드나 코드 블록을 핫스팟 코드 또는 핫 코드라고 부른다. 
이러한 핫스팟 코드를 런타임에 네이티브 코드로 컴파일하고 최적화를 수행하는 것이 바로 JIT 컴파일러다. 

## 1.1 인터프리터와 컴파일러
![[JVM 11장 - 인터프리터와 JIT 컴파일러의 관계.png|500]]
현 시대의 주류 상용 가상 머신은 대부분 인터프리터와 JIT 컴파일러를 함께 사용한다.

인터프리터의 주로 사용되는 경우는 다음과 같다.
- **컴파일 없이 프로그램을 빠르게 시작해야 할 때**
- **메모리가 부족한 환경에서 사용되어야 할 때**
- **JIT 컴파일러의 적극적 최적화가 실패할 때**
즉, 인터프리터는 JIT 컴파일러의 단점을 보완하는 역할을 한다.

### 계층형 컴파일 모드
핫스팟 가상 머신엔 2개 또는 3개의 JIT 컴파일러가 존재한다.
- **C1**(클라이언트 컴파일러)
- **C2**(서버 컴파일러)
- **그랄 컴파일러**
	- C2 대체 예정이었느나 JDK16부터 표준 JDK에선 배제되고, 그랄 VM의 프로젝트에서만 유지됨

기존의 핫스팟 VM의 인터프리터는 하나의 컴파일러와만 협력하여 작동했다.
하지만 현재는 호스트 모신의 하드웨어 성능과 자체 버전에 따라 실행 모드를 자동으로 선택한다.

JIT 컴파일러가 최적화를 수행하며 네이티브 코드로 컴파일하는 것은 시간이 오래 걸리는 작업이다.
또한 JIT 컴파일러가 더 많은 최적화를 수행하기 위해 인터프리터가 성능 모니터링 정보를 수집하는 것 역시 속도에 영향을 준다.
프로그램 시작 응답 속도와 운영 효율 사이의 균형을 찾기 위해 나온 것이 '계층형 컴파일' 기능이다. 

![[JVM 11장 - 계층형 컴파일.png]]
계층형 컴파일은 다음과 같은 단계로 수행된다.
- **계층 0**
	- 인터프리터가 바이트 코드를 해석하며, 성능 모니터링을 수행하지 않음
- **계층 1**
	- 클라이언트 컴파일러가 사용되며, 간단하고 안정적인 최적화를 수행. 성능 모니터링은 수행하지 않음
- **계층 2**
	- 클라이언트 컴파일러가 사용되며, 몇 가지 성능 모니터링을 수행함
- **계층 3**
	- 클라이언트 컴파일러가 사용되며, 모든 종류의 성능 모니터링이 수행됨
- **계층 4**
	- 서버 컴파일러가 사용되며, 성능 모니터링 정보를 활용해 시간이 오래 걸리는 최적화도 수행. 신뢰도가 낮은 공격적인 최적화를 수행하기도 함

계층형 컴파일이 도입된 뒤로는 인터프리터, C1, C2 컴파일러가 협력하며 동작하고 핫 코드가 여러 번 컴파일될 수 있다.
→ 해석 속도는 인터프리터 > C1 > C2 순이다.

### 1. 2 컴파일 대상과 촉발 조건
핫 코드의 대표적인 유형은 다음과 같다.
- **여러 번 호출되는 메서드**
- **여러 번 실행되는 순환문의 본문**
	- 실제 메서드의 호출 횟수가 적어도 핫 코드가 될 수 있음

두 유형 모두 메서드 전체를 타겟으로 한다. 
두 번째 유형에선 순환문이 작동하는 시점에 최적화가 수행될 수 있다.
이 때,  메**서드의 실행 진입점(루프의 시작 지점?)이 살짝 달라지며, 컴파일 시 진입점의 바이트코드 인덱스 값을 컴파일러에 전달**한다. 
메서드의 스택 프레임이 스택에 존재하는 상태에서 치환되기 때문에 **온스택 치환**(OSR)이라고 한다.

### 여러 번이라는 표현은 주관적
JIT 컴파일러가 촉발되는 조건을 판단하는 것을 핫스팟 코드 탐지 또는 핫스팟 탐지라고 하며 다음과 같은 방식으로 수행될 수 있다.
- **샘플 기반 핫스팟 코드 탐지**
	- 각 스레드 호출 스택 상단을 샘플링하여 자주 발견되는 메서드를 핫 메서드로 간주
	- 정확도가 떨어지며, 스레드 블로킹 등 외부 요인이 핫스팟 탐지를 방해
- **카운터 기반 핫스팟 코드 탐지**
	- 각 메서드와 코드 블록에 대한 카운터를 설정하여 개별 실행 횟수를 기록
	- 실행 횟수가 문턱값을 초과하면 핫 메서드로 간주
	- 구현이 어렵지만 더 정확한 결과를 얻을 수 있음
두 방식 모두 상용 가상 머신에서 사용되며, 핫스팟 VM에선 카운터 방식이 사용된다.
핫스팟 VM에선 메서드 각각에 대해 **메서드 호출 카운터와 백 에지 카운터를 준비하고 이를 토대로 JIT 컴파일 촉발 조건을 판별**한다.

아래 두 방식은 클라이언트 모드의 JIT 컴파일 방식만을 보여준다. 서버 모드는 더 복잡하게 구현되어 있다.
### 메서드 호출 카운터에 의한 JIT 컴파일 촉발
#### 메서드 호출 카운터의 작동 방식
메서드가 호출되면 VM은 해당 메서드의 JIT 컴파일 버전의 존재 여부를 확인한다. 
있다면 컴파일된 네이티브 코드를 실행하고, 
없다면 카운터의 값을 1 증가 시킨 후에 메서드 호출 카운터와 백 에지 카운터 값의 합이 문턱 값을 넘어서면 컴파일을 요청한다.

이 때, 따로 설정하지 않았다면 **VM 실행 엔진은 컴파일이 완료될 때까지 인터프리터로 작업을 계속**한다.
즉, **JIT 컴파일 작업은 백그라운드에서 비동기로 수행**된다.
컴파일 완료 후엔 메서드의 호출 진입점 주소가 시스템에 의해 자동으로 새 값으로 덮어 써지고, 그 다음 호출부터는 컴파일된 버전이 사용된다. 
#### 메서드 호출 카운터의 카운팅 단위 시간
메서드 호출 카운터는 '단위 시간당 호출 횟수'를 계산한다.
만약 **단위 시간 동안 집계 횟수가 문턱 값을 넘어서지 못한다면 카운터의 값을 반으로 줄이게** 된다. 
이 방식을 '카운트 감쇠 메서드 호출(counter decay method invocation)'이라고 한다. 

### 백 에지 카운터에 의한 JIT 컴파일 촉발
#### 백 에지 카운터 작동 방식
백 에지는 순환문 경계에서 순환문 처음으로 점프한다는 뜻이다.
그러므로 백 에지 카운터란 순환문의 반복 횟수라고 볼 수 있다.
이 카운터를 사용하는 목적은 OSR을 촉발하기 위함이다.

인터프리터는 **백 에지 명령어를 만나면 실행할 코드 조각의 컴파일된 버전이 있는지 먼저 확인**한다.
있다면, 컴파일된 네이티브 코드를 실행하고,
없다면 백 에지 카운터의 값을 1 증가 시킨다. 
이후 **메서드 호출 카운터와 백 에지 카운터의 합이 문턱 값을 넘기면 OSR 컴파일을 요청**한다. 
이 때, 백 에지 카운터의 값을 약간 줄이는데, 컴파일러가 컴파일을 마칠 때까지 인터프리터에서 순환문을 계속 실행하기 위해서다. 

메서드 호출 카운터와 달리 **감쇠 없이 절대 실행 횟수를 계산**한다.

## 3. 컴파일 과정
### 클라이언트 컴파일러의 컴파일 과정
- **단계 1**
	- 
- **단계 2**
- **단계 3**