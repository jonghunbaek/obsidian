---
플랫폼: 프로그래머스
문제 이름: 섬 연결하기
알고리즘: 유니온파인드, 그리디
tags:
  - 유니온파인드
  - 그리드
date: 2025-09-16
aliases:
  - 유니온파인드
복습 풀이: 250916(X), 250921(X), 251004(X), 251011(X), 251017(O), 251024(O)
---
# 1차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Edge[] edges = Arrays.stream(costs)
            .map(cost -> new Edge(cost[0], cost[1], cost[2]))
            .sorted((e1, e2) -> e1.cost - e2.cost)
            .toArray(Edge[]::new);
        
        Node[] nodes = new Node[n];
        for (int i = 0; i < nodes.length; i++) {
            nodes[i] = new Node();
        }
        
        int totalCost = 0;
        for (Edge edge : edges) {
            Node from = nodes[edge.from];
            Node to = nodes[edge.to];
            
            if (from.isConnected(to)) {
                continue;
            }
            
            from.connect(to);
            totalCost += edge.cost;
        }
        
        return totalCost;
    }
    
    static class Edge {
        int from;
        int to;
        int cost;
        
        public Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }
    
    static class Node {
        int depth = 1;
        Node parent;
        
        public void connect(Node other) {
            if (isConnected(other)) {
                return;
            }
            
            Node root1 = root();
            Node root2 = other.root();
            
            if (root1.depth > root2.depth) {
                root2.parent = root1;
            } else if (root1.depth < root2.depth) {
                root1.parent = root2;
            } else {
                root2.parent = root1;
                root1.depth++;
            }
        }
        
        public boolean isConnected(Node other) {
            return root() == other.root();
        }
        
        public Node root() {
            return parent == null ? this : parent.root();
        }
        
    }
}
```
유니온 파인드 알고리즘을 알아야 쉽게 푸는 문제.
유니온 파인드의 핵심은 한 집합의 요소들을 하나의 대표로부터 찾기 쉽게 만드는 것.
이를 통해 깊은 탐색을 하지 않고도 두 요소가 같은 집합에 속해있는지 확인할 수 있음
비용을 적은 순으로 정렬해 놓았기 때문에 그대로 더하기만 하면됨.
나중에 다른 유니온 파인드 문제를 풀어보기.

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Edge[] edges = Arrays.stream(costs)
            .map(cost -> new Edge(cost[0], cost[1], cost[2]))
            .sorted((e1, e2) -> e1.cost - e2.cost)
            .toArray(Edge[]::new);
        
        Node[] nodes = new Node[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node();
        }
        
        int totalCost = 0;
        for (Edge edge : edges) {
            Node n1 = nodes[edge.from];
            Node n2 = nodes[edge.to];
            
            if (n1.isConnected(n2)) continue;
            
            n1.merge(n2);
            totalCost += edge.cost;
        }
        
        return totalCost;
    }
    
    static class Node {
        int depth = 1;
        Node parent = null;
        
        public boolean isConnected(Node other) {
            return root() == other.root();
        }
        
        public void merge(Node other) {
            if (isConnected(other)) {
                return;
            }
            
            Node r1 = root();
            Node r2 = other.root();
            
            if (r1.depth > r2.depth) {
                r2.parent = r1;
            } else if (r1.depth < r2.depth) {
                r1.parent = r2;
            } else {
                r2.parent = r1;
                r1.depth++;
            }
        }
        
        private Node root() {
            if (this.parent == null) {
                return this;
            }
            
            return this.parent.root();
        }
    }
    
    static class Edge {
        int from;
        int to;
        int cost;
        
        public Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }
}
```
유니온 파인드 구현이 아직 쉽지 않음

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]); // 낮은 비용순대로 정렬
        int[] nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = i; // 자기 자신을 초깃값으로 설정
        }
        
        int totalCost = 0;
        for (int[] cost : costs) {
            int from = cost[0];
            int to = cost[1];
            
            if (find(from, nodes) != find(to, nodes)) { // 두 섬이 연결되어 있지 않다면
                union(from, to, nodes); // 두 섬을 이어줌
                totalCost += cost[2]; // 비용을 더해줌
            }
        }
        
        return totalCost;
    }
    
    private int find(int start, int[] nodes) {
        if (nodes[start] == start) { // 초깃값 그대로거나, 자신이 루트인 경우
            return start;    
        }
        
        return find(nodes[start], nodes);
    }
    
    private void union(int from, int to, int[] nodes) {
        int r1 = find(from, nodes);
        int r2 = find(to, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }
}
```

기존 책에 나와있는 풀이는 아무래도 직관적으로 이해하기 어렵고, 쉽게 기억하기 어려움
대신 나만의 풀이로 풀어 기억할 것

# 4차 풀이
```java
// 1. 최소 비용으로 계산할 수 있도록 비용 기준 오름차순으로 정렬
// 2. costs 배열을 순회하며 섬 방문 배열을 표시
// 3. 방문할 수 있을 때마다 비용을 더하기
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int i = 0; i < n; i++) {
            if (isConnected(costs[i][0], costs[i][1], nodes)) {
                continue;
            }
            
            connect(costs[i][0], costs[i][1], nodes);
            totalCost += costs[i][2];
        }
        
        return totalCost;
    }
    
    private void connect(int from, int to, int[] nodes) {
        if (isConnected(from, to, nodes)) {
            return;
        }
        
        if (from < to) {
            nodes[to] = from;
        } else {
            nodes[from] = to;
        }
    }
                
    private boolean isConnected(int from, int to, int[] nodes) {
        return nodes[from] == nodes[to];
    }
}
```
처음엔 무의식적으로 유니온 파인드를 생각하지 못하고 방문 배열을 이용해 풀이하려고 함.
하지만 전체적인 구조는 유니온 파인드와 유사했고, 결국 풀어내지 못함

```java
// 1. 최소 비용으로 계산할 수 있도록 비용 기준 오름차순으로 정렬
// 2. costs 배열을 순회하며 섬 방문 배열을 표시
// 3. 방문할 수 있을 때마다 비용을 더하기
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int[] cost : costs) {
            int from = cost[0];
            int to = cost[1];
            if (find(from, nodes) == find(to, nodes)) {
                continue;
            }
            
            connect(from, to, nodes);
            totalCost += cost[2];
        }
        
        return totalCost;
    }
    
    private void connect(int from, int to, int[] nodes) {
        int r1 = find(from, nodes);
        int r2 = find(to, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }

    private int find(int no, int[] nodes) {
        if (nodes[no] == no) {
            return no;
        }
        
        return find(nodes[no], nodes);
    }
}
```

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int i = 0; i < costs.length; i++) {
            if (findRoot(costs[i][0], nodes) == findRoot(costs[i][1], nodes)) continue;
            
            totalCost += costs[i][2];
            connect(costs[i][0], costs[i][1], nodes);
        }
        
        return totalCost;
    }
    
    private int findRoot(int node, int[] nodes) {
        if (nodes[node] == node) {
            return node;
        }
        
        return findRoot(nodes[node], nodes);
    }
    
    private void connect(int n1, int n2, int[] nodes) {
        int r1 = findRoot(n1, nodes);
        int r2 = findRoot(n2, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }
}
```
이제야 유니온 파인드에 익숙해진듯

# 6차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        int[] nodes = new int[n];
        for (int i = 0; i < nodes.length; i++) {
            nodes[i] = i;
        }
        
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int totalCost = 0;
        for (int[] cost : costs) {
            if (find(cost[0], nodes) == find(cost[1], nodes)) continue;
            
            connect(cost[0], cost[1], nodes);
            totalCost += cost[2];
        }
        
        return totalCost;
    }
    
    private int find(int node, int[] nodes) {
        if (nodes[node] == node) {
            return node;
        }
        
        return find(nodes[node], nodes);
    }
    
    private void connect(int node1, int node2, int[] nodes) {
        int root1 = find(node1, nodes);
        int root2 = find(node2, nodes);
        
        if (root1 < root2) {
            nodes[root2] = root1;
        } else {
            nodes[root1] = root2;
        }
    }
}
```
유니온 파인드는 좀 더 다양한 문제를 풀어봐야할 듯