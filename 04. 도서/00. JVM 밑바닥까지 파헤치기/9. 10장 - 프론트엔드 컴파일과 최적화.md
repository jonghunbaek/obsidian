우리가 흔히 말하는 컴파일 타임의 정확한 정의는 무엇일까?
Java로 작성된 소스 코드를 JVM에서 실행하는 과정까지 여러 컴파일 과정이 존재한다.
- **프론트엔드 컴파일러**
	- JDK의 javac, 이클립스의 JDT의 증분 컴파일러
- **JIT 컴파일러**
	- 핫스팟 가상 머신의 C1, C2 컴파일러, 그랄 컴파일러
- **AOT 컴파일러**
	- 그랄 컴파일러, JDK용 jaotc, 자바용 GNU 컴파일러(CGJ) 등

만약 맥락 없이 '컴파일 타임', '컴파일러'를 말한다면 대개 첫 번째 프론트엔드 컴파일러를 뜻할 것이다.
프론트엔드 컴파일러는 코드 실행 효율 측면의 최적화는 거의 하지 않는다.(JIT 컴파일러와 달리)
하지만 최적화의 범위를 개발 단계까지 포함한다면 프론트엔드 컴파일러의 최적화는 상당 부분 존재한다.
즉, 런타임엔 코드 실행 효율을 높이기 위한 최적화를 JIT 컴파일러가 수행하고, 컴파일 타임엔 개발자의 코딩 효율을 높이기 위해 프론트엔드 컴파일러가 수행된다.

# 1. javac 컴파일러
javac 컴파일러는 순수 자바로 작성됐다.
JDK 버전에 따라 javac를 구현한 코드의 디렉터리 경로가 다른데 JDK 10 부터는 JDK_SRC_HOME/src/jdk.compiler/share/classes/com/sun/tools/javac로 고정되었다.

## 1.1 동작 과정
![[JVM 9장 - javac 컴파일 과정.png]]
javac의 전체 과정은 아래와 같이 구분할 수 있다.
- **준비(0단계)**
	- 플러그인 애너테이션 처리기 초기화
- **구문 분석 및 심벌 채우기(1단계)**
	- 어휘 및 구문 분석 - 소스 코드 토큰화를 통한 추상 구문 트리 구성
	- 심벌 테이블 채우기 - 심벌 주소와 심벌 정보 생성
- **플러그인 애너테이션 처리기들로 애너테이션 처리(2단계)**
- **의미 분석 및 바이트코드 생성(3단계)**
	- 특성 검사 - 문법의 정적 정보 확인
	- 데이터 흐름 및 제어 흐름 분석 - 프로그램의 동적 실행 과정 확인
	- 편의 문법 제거 - 편의 문법을 원래 형식으로 복원
	- 바이트코드 생성 - 앞서 생성된 정보들을 바이트코드로 변환

이 중 2단계로 인해 심벌이 새롭게 추가되면 1단계가 다시 수행된다.
이 컴파일 과정은 앞선 javac 디렉토리에 존재하는 javac.main.JavaCompiler 클래스가 수행한다.
```java
public void compile(Collection<JavaFileObject> sourceFileObjects,  Collection<String> classnames, Iterable<? extends Processor> processors, Collection<String> addModules) {  

	. . .
  
    try {  
        initProcessAnnotations(processors, sourceFileObjects, classnames);  // 0단계 - 플러그인 애너테이션 처리기 초기화
  
        . . .
        
        // These method calls must be chained to avoid memory leaks  
        processAnnotations(  // 2단계 - 애너테이션 처리
            enterTrees(  // 1단계 - 심벌테이블 채우기
                    stopIfError(CompileState.PARSE,  
                            initModules(stopIfError(CompileState.PARSE, parseFiles(sourceFileObjects)))) // 1단계 - 구문 분석
            ),  
            classnames  
        );  
  
        . . .
  
        switch (compilePolicy) {  
        
		. . .
  
        case BY_TODO:  
            while (!todo.isEmpty())  
		        // 호출 순서대로 3단계 - 특성 검사, 흐름 분석, 편의 문법 제거, 바이트코드 생성성
                generate(desugar(flow(attribute(todo.remove())))); 
            break;  
  
        default:  
            Assert.error("unknown compile policy");  
        }  
    } catch (Abort ex) {  
        . . .
    } finally {  
        . . .
    }  
}
```
### 1단계 - 어휘 및 구문 분석
compile()에서 호출되는 parseFiles() 메서드가 어휘 및 구문 분석을 처리하는 역할을 한다.
**어휘 분석은 소스 코드의 문자 스트림을 토큰 집합으로 변환하는 작업**이다.
이를 담당하는 클래스는 javac.parser.Scanner 클래스다.

**구문 분석은 일련의 토큰들로부터 추상 구문 트리를 구성하는 과정**이다.
추상 구문 트리에서 각 노드는 프로그램 코드의 구문 구조를 나타낸다.
구문 분석을 수행하는 클래스는 javac.parser.Parser 클래스다.
추상 구문 트리를 표현하는 클래스는 javac.tree.JCTree 클래스다.

이상의 과정을 마쳐 추상 구문 트리가 생성되면 더 이상 소스 코드 문자 스트림은 사용되지 않는다.
#### 추상 구문 트리 예시
```java
int sum = 3 + 4;
```
```text
Assignment (=)
├── Variable: sum // 왼쪽 자식 노드
└── BinaryExpression (+) // 오른쪽 자식 노드
    ├── Literal: 3
    └── Literal: 4
```
### 1단계 - 심벌 테이블 채우기
complie()에서 호출되는 enterTrees() 메서드가 심벌 테이블 채우기 역할을 수행한다.
심벌 테이블은 '심벌 주소'와 '심벌 정보'의 집합으로 구성된 데이터 구조다. 
키-값 쌍의 해시 테이블과 비슷한데 구현 방식은 다양하다.

심벌 테이블은 의미 분석 과정, 목적 코드 생성 단계 등에서 활용된다.
→ 여기서 목적 코드는 바이트 코드를 의미하며 3단계 마지막 작업 중 바이트 코드 생성 단계에서 심벌 테이블이 활용됨을 의미한다.

심벌 테이블 채우기는 javac.comp.Enter 클래스가 담당하며, 이 단계의 결과로 컴파일 단위 각각에 대한 추상 구문 트리의 최상위 노드와 package-info.java의 최상위 노드 목록이 만들어진다.
→ 컴파일러 입장에서 .java는 하나의 컴파일 단위다.
→ 이 단위에서 가장 최상위 노드는 class, interface, enum 등을 의미한다.