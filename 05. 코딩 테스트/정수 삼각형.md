---
플랫폼: 프로그래머스
문제 이름: 정수 삼각형
알고리즘: dp
tags:
  - dp
date: 2025-08-25
aliases:
  - dp
복습 풀이: 250825(O), 250830(O), 250906(O)
---
# 1차 풀이
```java
// 1. 완탐을 할 경우 2의 500승으로 무조건 시간 초과
// 2. DP를 사용해야 함
// 3. 이동 가능한 값은 아래와 오른쪽 아래
// 4. 두 방향에서 진입 가능하면 둘 중 큰 값을 대입
// 7
// 3 8
// 8 1 0
// 2 7 4 4
// 4 5 2 6 5

class Solution {
    public int solution(int[][] triangle) {
        int y = triangle.length;
        int x = triangle[triangle.length - 1].length;
        int[][] dp = new int[y][x];
        for (int i = 0; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {
                dp[i][j] = triangle[i][j];
            }
        }
    
        for (int i = 1; i < dp.length; i++) {
            for (int j = 0; j < dp[i].length; j++) {
                if (j - 1 < 0) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j];
                    continue;
                }
                
                dp[i][j] = Math.max(dp[i - 1][j] + dp[i][j], dp[i - 1][j - 1] + dp[i][j]);
            }
        }
        
        int max = 0;
        for (int i = 0; i < dp[0].length; i++) {
            max = Math.max(max, dp[dp.length - 1][i]);
        }
        
        return max;
    }
}
```
생각보다 어렵지 않게 풀었음. 
다만 아래 풀이처럼 재귀를 이용한 풀이도 있으니 참고해서 분석해볼 것
```java
public class Solution {
    private final int[][] mem = new int[501][501];

    private int max(int x, int y, int[][] triangle) {
        if (y == triangle.length) return 0;
        if (mem[x][y] != -1) return mem[x][y];

        return mem[x][y] = triangle[y][x] + Math.max(
                max(x, y + 1, triangle),
                max(x + 1, y + 1, triangle));
    }

    public int solution(int[][] triangle) {
        for (int[] row : mem) {
            Arrays.fill(row, -1);
        }
        return max(0, 0, triangle);
    }
}
```

# 2차 풀이
```java
class Solution {
    public int solution(int[][] triangle) {
        int[][] dp = new int[triangle.length][triangle[triangle.length - 1].length];
        
        for (int i = 0; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {
                if (i - 1 < 0 && j - 1 < 0) {
                    dp[i][j] = triangle[i][j];
                    continue;
                }
                
                if (j - 1 < 0) {
                    dp[i][j] = triangle[i][j] + dp[i - 1][j];
                    continue;
                }
                
                dp[i][j] = Math.max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];
            }
        }
        
        int max = 0;
        for (int i = 0; i < dp[dp.length - 1].length; i++) {
            max = Math.max(max, dp[dp.length - 1][i]);
        }
        
        return max;
    }
}
```
하향식 풀이법도 공부해보자

# 3차 풀이
```java
class Solution {
    public int solution(int[][] triangle) {
        int[][] mem = new int[501][501];
        for (int i = 0; i < mem.length; i++) {
            Arrays.fill(mem[i], -1);
        }
        
        dfs(0, 0, mem, triangle);
        
        return mem[0][0];
    }
    
    private int dfs(int x, int y, int[][] mem, int[][] triangle) {
        if (y == triangle.length - 1) {
            mem[y][x] = triangle[y][x];
            return triangle[y][x];
        }
        
        if (mem[y][x] != -1) {
            return mem[y][x];
        }
        
        mem[y][x] = Math.max(dfs(x + 1, y + 1, mem, triangle), dfs(x, y + 1, mem, triangle)) + triangle[y][x];
        
        return mem[y][x];
    }
}
```
하향식으로 풀어봄 
낯설어서 여러번 풀어봐야 할듯