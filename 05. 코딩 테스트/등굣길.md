---
플랫폼: 프로그래머스
문제 이름: 등굣길
알고리즘: dp
tags:
  - dp
date: 2025-08-26
aliases:
  - dp
복습 풀이: 250826(X), 250901(X)
---
# 1차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int mod = 1000000007;
        int[][] dp = new int[n + 1][m + 1];
        dp[1][1] = 1;
        for (int[] puddle : puddles) {
            dp[puddle[0]][puddle[1]] = -1;
        }
        
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (dp[i][j] == -1) {
                    continue;
                }
                
                
                if(dp[i - 1][j] > 0) {
                    dp[i][j] += dp[i - 1][j] % mod;
                }
                
                if(dp[i][j - 1] > 0) {
                    dp[i][j] += dp[i][j - 1] % mod;
                }
            }
        }
        
        return dp[n][m];
    }
}
```

```java
public class Solution {
    private final int[][] mem = new int[101][101];

    private int count(int x, int y, int w, int h, boolean[][] isPuddle) {
        if (x > w || y > h) return 0;
        if (isPuddle[y][x]) return 0;

        if (mem[x][y] != -1) return mem[x][y];
        if (x == w && y == h) return 1;

        int total = count(x + 1, y, w, h, isPuddle)
                + count(x, y + 1, w, h, isPuddle);
        return mem[x][y] = total % 1000000007;
    }

    public int solution(int m, int n, int[][] puddles) {
        for (int[] row : mem) {
            Arrays.fill(row, -1);
        }

        boolean[][] isPuddle = new boolean[n + 1][m + 1];
        for (int[] p : puddles) {
            isPuddle[p[1]][p[0]] = true;
        }

        return count(1, 1, m, n, isPuddle);
    }
}
```
단순히 최단 거리를 구하기라면 어렵지 않았겠지만 최단 거리로 갈 수 있는 경우의 수를 찾는 문제라 어려웠음
첫 번째 풀이는 상향식, 두 번째 풀이는 하향식 풀이다.
여전히 상향식 풀이가 쉬운것을 보면 아직 재귀에 대한 이해도가 많이 떨어지는 듯하다.

# 2차 풀이
```java
class Solution {
    public int solution(int m, int n, int[][] puddles) {
        int mod = 1000000007;
        // 1. 배열 크기를 [n][m]으로 변경
        int[][] dp = new int[n][m];

        // 2. 웅덩이 좌표를 0-based 인덱스에 맞게 변환하여 표시
        // 문제에서 웅덩이 좌표는 [열, 행] 순서이므로 dp[행-1][열-1]에 표시합니다.
        for (int[] puddle : puddles) {
            dp[puddle[1] - 1][puddle[0] - 1] = -1; 
        }

        // 3. 시작점을 (0, 0)으로 설정
        dp[0][0] = 1;

        // 4. 반복문을 0부터 n-1, m-1까지 순회
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                // 현재 위치가 웅덩이면 0으로 만들고 건너뜀
                if (dp[i][j] == -1) {
                    dp[i][j] = 0;
                    continue;
                }

                // 5. 위쪽과 왼쪽에서 오는 경우의 수를 더함
                // i > 0, j > 0 조건을 추가하여 ArrayIndexOutOfBoundsException 방지
                if (i > 0) {
                    dp[i][j] += dp[i - 1][j] % mod;
                }
                
                if (j > 0) {
                    dp[i][j] += dp[i][j - 1] % mod;
                }
            }
        }
        
        // 6. 최종 결과는 dp[n-1][m-1]
        return dp[n - 1][m - 1] % mod;
    }
}
```
배열을 int\[n]\[m]으로 초기화해서 작업하려니 분기 처리를 어떻게 해야 하나 헷갈려서 틀림
