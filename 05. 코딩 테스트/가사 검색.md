---
플랫폼: 프로그래머스
문제 이름: 가사 검색
알고리즘: 트라이
tags:
  - 트라이
date: 2025-09-18
aliases:
  - 트라이
복습 풀이: 250918(X), 250922(X), 251004(X), 251011(O)
---
# 1차 풀이
```java
class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();

        for (String word : words) {
            normal.insert(word);
            reverse.insert(new StringBuilder(word).reverse().toString());
        }

        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = reverse.search(new StringBuilder(queries[i]).reverse().toString());
                continue;
            }

            results[i] = normal.search(queries[i]);
        }

        return results;
    }

    static class TrieNode {
        TrieNode[] children = new TrieNode[26]; // 알파벳 26자
        int[] count = new int[10001]; // 키워드의 최대 길이는 10,000
    }

    static class Trie {
        TrieNode root = new TrieNode();

        public void insert(String word) {
            int length = word.length();
            root.count[length]++;
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new TrieNode();
                }

                node = node.children[c - 'a'];
                node.count[length]++;
            }
        }

        public int search(String query) {
            TrieNode node = root;
            int length = query.length();
            for (int i = 0; i < length; i++) {
                char c = query.charAt(i);
                if (c == '?') {
                    return node.count[length];
                }

                if (node.children[c - 'a'] == null) {
                    return 0;
                }

                node = node.children[c - 'a'];
            }

            return node.count[length];
        }
    }
}
```
트라이 자료구조 자체는 어렵지 않다.
해당 자료구조를 알고 구현만 할 줄 안다면 어렵지 않게 풀어볼 수 있다. 
하지만 해당 풀이는 효율성 테스트에서 모두 메모리 초과가 발생한 코드다.(자식 노드마다 10001 길이의 배열을 생성하니 당연할지도..)

```java
import java.util.*;

class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();

        for (String word : words) {
            normal.insert(word);
            reverse.insert(new StringBuilder(word).reverse().toString());
        }

        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = reverse.search(new StringBuilder(queries[i]).reverse().toString());
                continue;
            }

            results[i] = normal.search(queries[i]);
        }

        return results;
    }

    static class TrieNode {
        Map<Character, TrieNode> children = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();
    }

    static class Trie {
        TrieNode root = new TrieNode();

        public void insert(String word) {
            int length = word.length();
            root.count.put(length, root.count.getOrDefault(length, 0) + 1);
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                Map<Character, TrieNode> children = node.children;
                if (!children.containsKey(c)) {
                    children.put(c, new TrieNode());
                }

                node = children.get(c);
                node.count.put(length, node.count.getOrDefault(length, 0 ) + 1);
            }
        }

        public int search(String query) {
            TrieNode node = root;
            int length = query.length();
            for (int i = 0; i < length; i++) {
                char c = query.charAt(i);
                if (c == '?') {
                    break;
                }

                if (!node.children.containsKey(c)) {
                    return 0;
                }

                node = node.children.get(c);
            }

            return node.count.getOrDefault(length, 0);
        }
    }
}
```
배열을 HashMap으로 바꿔 통과

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie ascTrie = new Trie();
        Trie descTrie = new Trie();
        for (String word : words) {
            ascTrie.insert(word);
            descTrie.insert(new StringBuilder(word).reverse().toString());
        }
        
        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = descTrie.search(new StringBuilder(queries[i]).reverse().toString());
                continue;
            }
            
            results[i] = ascTrie.search(queries[i]);
        }
        
        return results;
    }
    
    static class Trie {
        private Map<Character, Trie> children = new HashMap<>(); 
        private Map<Integer, Integer> count = new HashMap<>();
        
        public void insert(String word) {
            int length = word.length();
            count.put(length, count.getOrDefault(length, 0) + 1);
            Trie node = this;
            for (char c : word.toCharArray()) {
                if (!node.children.containsKey(c)) {
                    node.children.put(c, new Trie());
                }
                
                node = node.children.get(c);
                node.count.put(length, node.count.getOrDefault(length, 0) + 1);
            }
        }
        
        public int search(String target) {
            Trie node = this;
            for (char c : target.toCharArray()) {
                if (c == '?') {
                    return node.count.getOrDefault(target.length(), 0);
                }
                
                if (!node.children.containsKey(c)) {
                    return 0;
                }
                
                node = node.children.get(c);
            }
            
            return node.count.getOrDefault(target.length(), 0);
        }
    }
}
```
어렵지 않은 풀이지만 아직은 어색함

# 3차 풀이
```java
class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();
        for (String word : words) {
            normal.buildTree(word);
            reverse.buildTree(reverse(target));
        }
        
        for (String query : queries) {
            
        }
        
        return null;
    }
    
    static class Trie {
        Map<Character, Trie> tree = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();
        
        private void buildTree(String target) {
            int length = target.length();
            count.put(length, count.getOrDefault(length, 0) + 1);
            
            for (char c : target.toCharArray()) {
                Trie trie;
                if (!tree.containsKey(c)) {
                    trie = new Trie();
                    tree.put(c, trie);
                }
                
                
            }
        }
    }
    
    private String reverse(String target) {
        return new StringBuilder(target).reverse().toString()
    }
}
```
tree만드는 부분부터 막힘

```java
import java.util.*;

class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();
        for (String word : words) {
            normal.buildTree(word);
            reverse.buildTree(reverse(word));
        }
        
        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = reverse.search(reverse(queries[i]));
                continue;
            }
            
            results[i] = normal.search(queries[i]);
        }
        
        return results;
    }
    
    static class Trie {
        Map<Character, Trie> tree = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();
        
        private void buildTree(String target) {
            int length = target.length();
            count.put(length, count.getOrDefault(length, 0) + 1);
            
            Trie node = this;
            for (char c : target.toCharArray()) {
                if (!node.tree.containsKey(c)) {
                    node.tree.put(c, new Trie());
                }
                
                node = node.tree.get(c);
                node.count.put(length, node.count.getOrDefault(length, 0) + 1);
            }
        }
        
        private int search(String target) {
            Trie node = this;
            int length = target.length();
            for (char c : target.toCharArray()) {
                if (c == '?') {
                    return node.count.getOrDefault(length, 0);
                }
                
                if (!node.tree.containsKey(c)) {
                    return 0;
                }
                
                node = node.tree.get(c);
            }
            
            return count.getOrDefault(length, 0);
        }
    }
    
    private String reverse(String target) {
        return new StringBuilder(target).reverse().toString();
    }
}
```
문자열의 문자 반복에서 자식 노드를 추출하는 것이 핵심

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie ascTrie = new Trie();
        Trie descTrie = new Trie();
        
        for (String word : words) {
            ascTrie.insert(word);
            descTrie.insert(reverse(word));
        }
        
        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = descTrie.search(reverse(queries[i]));
            } else {
                results[i] = ascTrie.search(queries[i]);
            }
        }
        
        return results;
    }
    
    private String reverse(String target) {
        return new StringBuilder(target).reverse().toString();
    }
    
    static class Trie {
        Map<Character, Trie> child = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();
        
        public void insert(String target) {
            int length = target.length();
            count.put(length, count.getOrDefault(length, 0) + 1);
            Trie node = this;
            for (char c : target.toCharArray()) {
                if (!node.child.containsKey(c)) {
                    node.child.put(c, new Trie());
                }
                
                node = node.child.get(c);
                node.count.put(length, node.count.getOrDefault(length, 0) + 1);
            }
        }
        
        public int search(String target) {
            int length = target.length();
            
            Trie node = this;
            for (char c : target.toCharArray()) {
                if (c == '?') {
                    return node.count.getOrDefault(length, 0);
                }
                
                if (!node.child.containsKey(c)) {
                    return 0;
                }
                
                node = node.child.get(c);
            }
            
            
            return node.count.getOrDefault(length, 0);
        }
    }
}
```
전체적인 흐름은 충분함.
다만 세부적인 부분 특히 반복문을 순회하며 node 변수의 값을 child로 변경하는 과정에서 자꾸 실수가 발생함
해당 부분에 대한 디버깅이 어려워 시간을 많이 잡아 먹음
