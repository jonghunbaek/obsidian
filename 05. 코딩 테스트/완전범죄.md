---
플랫폼: 프로그래머스
알고리즘: dp
tags:
  - dp
date: 2026-02-18
복습 풀이: 260218(X), 260228()
---
# 1차 풀이
```java
// 완전탐색
// 1. a가 잡히지 않을 최소 흔적 개수를 파악하는 것이 핵심
// 2. 배열 크기가 길지 않으니 재귀로 탐색
// 3. a가 1개 훔친것부터 info.length - 1개 훔친것까지 모두 더하며 b가 통과하는 최소 흔적 개수 탐색
// 4. int find(int idx, List<Integer> sum, int count, int[][] info, int n, int m)
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        int answer = Integer.MAX_VALUE;
        for (int i = 0; i <= info.length; i++) {
            answer = Math.min(answer, find(0, new ArrayList<>(), i, info, n, m));
        }
        
        return answer == Integer.MAX_VALUE ? -1 : answer;
    }
    
    private int find(int idx, List<Integer> values, int count, int[][] info, int n, int m) {
        if (values.size() == count) {
            int aCount = values.stream()
                .mapToInt(value -> info[value][0])
                .sum();
            int bCount = 0;
            for (int i = 0; i < info.length; i++) {
                if (values.contains(i)) continue;
                bCount += info[i][1];
            }
            
            if (aCount < n && bCount < m) return aCount;
            return Integer.MAX_VALUE;
        }
        
        int min = Integer.MAX_VALUE;
        for (int i = idx; i < info.length; i++) {
            values.add(i);
            min = Math.min(min, find(i + 1, values, count, info, n, m));
            values.remove(values.size() - 1);
        }
        
        return min;
    }
}
```
최초에 완전탐색으로 접근했으나 시간초과 발생
- info의 길이가 최대 40
- 0개부터 조합 시
	- 0인 경우 1번
	- 1인 경우 40번
	- 2인 경우 40 x 39
	- ... 40인 경우 40! 이되므로 시간 초과임
- info길이만 보고 완탐이라고 착각한 것이 패착이며, 시간 복잡도 계산도 잘못됐음
- 해당 알고리즘에서 시간 복잡도는 순열이 아닌 조합으로 구해야 하며, 따라서 2의 40승이 됨
- 

그렇다고 아래와 같이 정렬, 그리디 방식으로 풀이하는 것은 접근 방식 자체가 잘못됐음
```java
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        Arrays.sort(info, (i1, i2) -> {
            if (i1[0] == i2[0]) return i1[1] - i2[1];
            return i1[0] - i2[0];
        });
        
        int answer = Integer.MAX_VALUE;
        for (int i = 0; i <= info.length; i++) {
            answer = Math.min(answer, count(i, info, n, m));
        }
        
        return anwer == Initeger.MAX_VALUE ? -1 : answer;
    }
    
    private int count(int limit, int[][] info, int n, int m) {
        int aCount = 0;
        for (int i = 0; i < limit; i++) {
            aCount += info[i][0];
        }
        
        int bCount = 0;
        for (int i = limit; i < info.length; i++) {
            bCount += info[i][1];
        }
        
        if (aCount < n && bCount < m) return aCount;
        return Integer.MAX_VALUE;
    }
}
```

결국 아래와 같이 DP로 접근해야 풀림(냅색 알고리즘이라고 하는데 맞는지 확인 필요)
```java
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        // dp[b]: B도둑의 흔적이 b일 때, A도둑의 최소 흔적
        int[] dp = new int[m];
        int INF = 1000000; // 절대 나올 수 없는 충분히 큰 값 (오버플로우 방지)
        
        Arrays.fill(dp, INF);
        dp[0] = 0; // 초기 상태: 훔친 물건이 없을 때, B의 흔적 0 / A의 흔적 0
        
        for (int[] item : info) {
            int aTrace = item[0];
            int bTrace = item[1];
            
            // 현재 물건을 훔친 후의 상태를 임시로 저장할 배열
            int[] nextDp = new int[m];
            Arrays.fill(nextDp, INF);
            
            for (int b = 0; b < m; b++) {
                if (dp[b] == INF) continue; // 도달 불가능한 상태는 건너뜀
                
                // [선택 1] A도둑이 훔치는 경우
                // B의 흔적(b)은 그대로 유지되고, A의 흔적만 증가함
                if (dp[b] + aTrace < n) {
                    nextDp[b] = Math.min(nextDp[b], dp[b] + aTrace);
                }
                
                // [선택 2] B도둑이 훔치는 경우
                // B의 흔적이 증가하고, A의 흔적은 이전 상태 유지
                if (b + bTrace < m) {
                    nextDp[b + bTrace] = Math.min(nextDp[b + bTrace], dp[b]);
                }
            }
            // 모든 상태 업데이트
            dp = nextDp;
        }
        
        // 탐색 종료 후, A가 남길 수 있는 최소 흔적 찾기
        int answer = INF;
        for (int b = 0; b < m; b++) {
            answer = Math.min(answer, dp[b]);
        }
        
        // 목표를 달성할 수 없는 경우 -1 반환
        return answer == INF ? -1 : answer;
    }
}
```

### 📌 [1단계] 알고리즘 선택: 왜 '완전 탐색'을 버려야 할까?
문제를 딱 마주쳤을 때 가장 먼저 해야 할 일은 **제한사항(데이터의 크기, $N$)**을 확인하는 거야.
- **조건 확인:** 훔칠 물건의 개수(`info`의 길이)는 최대 **40개**야.
- **경우의 수 계산:** 각 물건마다 'A가 훔친다' or 'B가 훔친다' 2가지 선택지가 있으므로, 모든 경우의 수를 확인하면 $2^{40}$(약 1조 번)의 탐색이 필요해.
- **결론:** 자바는 1초에 약 1억 번($10^8$) 연산하니까, 이건 무조건 **시간 초과(TLE)**다. 가지치기를 하더라도 $2^{40}$은 너무 크므로, **'상태를 압축해서 중복 계산을 없애는 동적 계획법(DP)'**으로 접근 방향을 바로 틀어야 해.

### 📌 [2단계] DP 배열 설계: 무엇을 인덱스로, 무엇을 값으로 할까?
DP 문제의 핵심은 **'배열의 인덱스와 값을 어떻게 정의할 것인가'**야. 보통 한계(Limit)가 정해진 제약 조건을 인덱스로 써.
- **제약 조건 1 (B의 한계):** B의 흔적 누적값은 $m$ 미만이어야 해. (이걸 인덱스로 쓰자!)
- **제약 조건 2 (A의 한계 & 목표):** A의 흔적 누적값은 $n$ 미만이어야 하고, 우리는 **A 흔적의 '최솟값'**을 구해야 해. (이걸 배열의 값으로 쓰자!)
> **정의:** `dp[b] = B의 흔적이 b일 때, A가 남긴 최소 흔적`
배열의 초기화는 다음과 같이 세팅해.
- 아직 아무 물건도 안 훔쳤을 때: `dp[0] = 0` (B 흔적 0일 때, A 흔적도 0)
- 나머지 도달하지 않은 상태: `dp[1] ~ dp[m-1] = INF` (1,000,000 같은 큰 값)

### 📌 [3단계] 상태 전이 (점화식): 물건을 훔칠 때 배열이 어떻게 변할까?
물건을 하나씩 순회하면서, 기존에 기록된 `dp` 배열을 바탕으로 **새로운 상태(`nextDp`)**를 만들어가는 과정이야.
기존 `dp` 배열에서 값이 `INF`가 아닌(즉, 도달 가능한) 모든 `b`(B의 흔적)에 대해 2가지 분기를 뻗어 나가면 돼.
1. **[선택 1] A가 훔치는 경우:**
    - B의 흔적(`b`)은 변하지 않아.
    - 대신 A의 흔적(`dp[b]`)에 현재 물건의 A 흔적(`aTrace`)이 더해져.
    - 단, 이 합이 $n$을 넘지 않아야 해!
    - **공식:** `nextDp[b] = Math.min(nextDp[b], dp[b] + aTrace)`
2. **[선택 2] B가 훔치는 경우:**
    - B의 흔적(`b`)에 현재 물건의 B 흔적(`bTrace`)이 더해져서 인덱스가 이동해.
    - 이때 A는 가만히 있었으니 A의 흔적(`dp[b]`)은 그대로 가져가.
    - 단, 이동할 인덱스(`b + bTrace`)가 $m$을 넘지 않아야 해!
    - **공식:** `nextDp[b + bTrace] = Math.min(nextDp[b + bTrace], dp[b])`

### 📌 [4단계] 전체 코드 완성 (가장 이해하기 쉬운 정석 버전)
나중에 다시 봤을 때 로직이 한눈에 들어오도록, 메모리를 조금 더 쓰더라도 **'어제의 기록(`dp`)'**과 **'오늘의 기록(`nextDp`)'**을 분리하는 방식으로 짠 참고용 코드야.

```java
import java.util.*;

class Solution {
    public int solution(int[][] info, int n, int m) {
        // 1. DP 배열 초기화
        int[] dp = new int[m];
        int INF = 1000000; // 절대 도달할 수 없는 큰 값
        Arrays.fill(dp, INF);
        dp[0] = 0; // 시작점: B흔적 0, A흔적 0
        
        // 2. 물건을 하나씩 확인하며 상태 업데이트
        for (int[] item : info) {
            int aTrace = item[0];
            int bTrace = item[1];
            
            // 이번 물건의 결과를 기록할 새 도화지 (중복 훔침 방지)
            int[] nextDp = new int[m];
            Arrays.fill(nextDp, INF);
            
            // 기존의 모든 B 흔적 상태(b)를 훑어봄
            for (int b = 0; b < m; b++) {
                // 아직 도달해 본 적 없는 상태면 건너뜀
                if (dp[b] == INF) continue; 
                
                // [선택 1] A가 훔친다 (B 흔적 유지, A 흔적 증가)
                if (dp[b] + aTrace < n) {
                    nextDp[b] = Math.min(nextDp[b], dp[b] + aTrace);
                }
                
                // [선택 2] B가 훔친다 (B 흔적 증가, A 흔적 유지)
                if (b + bTrace < m) {
                    nextDp[b + bTrace] = Math.min(nextDp[b + bTrace], dp[b]);
                }
            }
            // 오늘 쓴 새 도화지를 내일의 바탕으로 삼기 위해 덮어씌움
            dp = nextDp;
        }
        
        // 3. 탐색 종료 후 정답 찾기
        int answer = INF;
        for (int b = 0; b < m; b++) {
            // 모든 가능한 B의 흔적 상태 중에서, 가장 작은 A의 흔적을 찾음
            answer = Math.min(answer, dp[b]);
        }
        
        // 정답이 여전히 INF라면 불가능한 경우이므로 -1 반환
        return answer == INF ? -1 : answer;
    }
}
```

# 2차 풀이
```java

```