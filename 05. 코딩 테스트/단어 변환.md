---
플랫폼: 프로그래머스
문제 이름: 단어 변환
알고리즘: DFS, BFS
tags:
  - BFS
  - DFS
date: 2025-10-06
aliases:
  - DFS, BFS
복습 풀이: 251006(O), 251011(O), 251019(O)
---
# 1차 풀이
```java
class Solution {
    
    static int result = Integer.MAX_VALUE;
    
    public int solution(String begin, String target, String[] words) {
        boolean[] visited = new boolean[words.length];
        count(0, begin, target, words, visited);
        
        return result == Integer.MAX_VALUE ? 0 : result;
    }
    
    private void count(int depth, String begin, String target, String[] words, boolean[] visited) {
        if (begin.equals(target)) {
            result = Math.min(result, depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            if (visited[i]) {
                continue;
            }
            
            String value = convert(begin, words[i]);
            if (value == "") {
                continue;
            }
            
            visited[i] = true;
            count(depth + 1, value, target, words, visited);
            visited[i] = false;
        }
    }
    
    private String convert(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return "";
        }
  
        int count = 0;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                count++;
            }
            
            if (count > 1) {
                return "";
            }
        }
 
        return s2;
    }
}
```
디버깅을 굉장히 오래하여 풀었음
다음 풀이에선 다음 부분을 고려해서 풀어보기.
- BFS로 풀기
- 정적 변수를 사용하지 않고 풀기

# 2차 풀이
```java
// 1. words 길이의 방문 배열을 만들어 한번 변환한 단어는 다시 사용하지 못하도록 만들기
// 2. words를 모두 순회했음에도 찾지 못했다면 0
// 3. 찾았다면 값을 저장
// 4. 저장된 값을 정렬해 최솟값을 반환
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        boolean[] visited = new boolean[words.length];
        List<Integer> results = new ArrayList<>();
        find(0, begin, target, words, visited, results);
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .min()
            .orElse(0);
    }
    
    private void find(int depth, String from, String target, String[] words, boolean[] visited, List<Integer> results) {
        if (target.equals(from)) {
            results.add(depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            String value = convert(from, words[i]);
            if (visited[i] || value.isEmpty()) {
                continue;
            }
            
            visited[i] = true;
            find(depth + 1, value, target, words, visited, results);
            visited[i] = false;
        }
    }
    
    private String convert(String origin, String target) {
        if (origin.length() != target.length()) {
            return "";
        }
        
        int count = 0;
        for (int i = 0; i < origin.length(); i++) {
            if (origin.charAt(i) != target.charAt(i)) {
                count++;
            }
        }
        
        return count > 1 ? "" : target;
    }
}
```
살짝 더듬으며 푼듯 
bfs 풀이를 보니 visited를 다시 false로 바꿔주지 않는데 어떤 차이인지 확인필요함
다음 풀이에 BFS를 활용해보기.

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        PriorityQueue<Integer> result = new PriorityQueue<>();
        convertToTarget(result, 0, begin, target, words, new boolean[words.length]);
        
        return result.isEmpty() ? 0 : result.poll();
    }
    
    private void convertToTarget(PriorityQueue<Integer> result, int depth, String from, String target, String[] words, boolean[] visited) {
        if (from.equals(target)) {
            result.offer(depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            String value = convert(from, words[i]);
            if (visited[i] || value.isEmpty()) continue;
            
            visited[i] = true;
            convertToTarget(result, depth + 1, value, target, words, visited);
            visited[i] = false;
        }
    }
    
    private String convert(String from, String target) {
        if (from.length() != target.length()) return "";
        
        int count = 0;
        for (int i = 0; i < from.length(); i++) {
            if (target.charAt(i) != from.charAt(i)) count++;
        }
        
        return count == 1 ? target : "";
    }
}
```
- bfs로 풀어보기
- 우선 순위 큐 사용하지 않기