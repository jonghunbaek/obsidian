# 1. 문제점
서버가 어떤 작업을 수행하기로 했으면 장애로 인해 메모리의 데이터가 휘발되어도 재작업할 수 있어야 한다. 
이 문제는 사실 분산 시스템만의 문제가 아니다. 
단일 서버에서도 장애 발생하여, 실제로 요청을 받았음에도 작업이 수행되지 않을 수 있다. 
# 2. 해결책
이러한 문제를 해결하기 위해 쓰기 전 로그(Write-Ahead Logging) 방식을 사용한다.
방식은 단순하다.
- **데이터를 실제 변경하기 전에 먼저 로그를 기록**
- **각각의 상태 변화를 명령어 형태로 하드디스크의 파일에 저장**(메모리 데이터 휘발 대응)
- **단일 로그는 각 서버 프로세스에 유지 관리하고, 순차적으로 덧붙여짐**(작업 단순화)
- **각 로그 엔트리엔 고유 식별자 부여**(분할 로그, 로우 워터마크에 활용)
이렇게 작성된 **로그는 서버 재시작 시, 상태 복구에 활용**된다.

### 로그 엔트리의 일반적 구성
```java
class WALEntry ... 
	
	private final Long entryIndex;
	private final byte[] data;
	private final EntryType entryType;
	private final long timeStamp;
```
### 고려사항
- **로그 파일에 실제로 엔트리가 기록되었는가?**
	- 일반적으로 OS는 디스크 I/O 비용을 줄이기 위해, 일정량의 데이터를 모아서 한 번에 디스크에 동기화하는 버퍼 방식을 사용
	- 때문에 프로그래머 입장에선 저장되었다고 생각했어도 실제론 디스크에 저장되지 않는 경우가 존재
		- 이를 해결하기 위해 직접 플러시를 할 수는 있지만 명령어 한 번만다 디스크 I/O가 발생하므로 성능 저하로 병목 현상이 발생할 수 있음
		- 하지만 데이터의 지속성을 위해선 어느정도는 필요함
	- 이러한 문제로 인해 대부분의 구현체는 배치 작업 등의 기법을 사용해 플러시 작업의 충격을 완화
- **로그 엔트리가 손상되었는가?**
	- CRC(Cyclic Redundancy Check) 레코드와 함께 로그 엔트리를 기록해 읽을 때 손상 여부 검증
	- 엔트리 종료 마커와 같은 기법도 활용 가능
- **단일 로그로 충분히 관리할 수 있는가?**
	- 단일 로그의 파일이 커지면 관리가 어려워지고, 읽기 속도 또한 저하될 수 밖에 없음
	- 분할 로그([[패턴2 - 분할 로그]]), 로우 워터마크 등의 기법으로 해결 가능
- **로그 엔트리는 중복되지 않는가?**
	- WAL은 덧붙이기 전용이므로 멱등하지 않다면 요청에 고유 식별자를 부여해 중복 감지 메커니즘이 필요
- **로그 저장소는 안전한가?**
	- 저장 매체가 실패하면 쓰기 전 로그 자체를 잃어버릴 수 있음
	- 복제 로그 패턴을 사용해 해결

### 트랜잭션 저장소에서의 활용법
트랜잭션은 ACID를 보장해야 한다.
WAL은 이중에 **A(Atomic)과 D(Durability)을 지원하는데 도움**을 줄 수 있다.
I(Isolation) 과 C(Consistency)는 락을 활용한 동시성 제어 메커니즘으로 제공되어야 한다.