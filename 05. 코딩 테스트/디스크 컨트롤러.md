---
플랫폼: 프로그래머스
문제 이름: 디스크 컨트롤러
알고리즘: 우선순위큐
tags:
  - 우선순위큐
date: 2025-09-11
aliases:
  - 우선순위큐
복습 풀이: 250911(X), 250915(X), 250920(O)
---
# 1차 풀이
```java
class Solution {
    public int solution(int[][] jobs) {
        PriorityQueue<Task> tasks = new PriorityQueue<>();
        for (int i = 0; i < jobs.length; i++) {
            tasks.add(new Task(i, jobs[i][0], jobs[i][1]));
        }

        int startTime = 0;
        List<Task> results = new ArrayList<>();
        while (!tasks.isEmpty()) {
            Task current = tasks.poll();

            int completedTime = startTime + current.duration;
            startTime += current.duration;
            current.complete(completedTime);

            results.add(current);
        }

        int returnTime = 0;
        for (Task task : results) {
            returnTime += task.completedTime - task.requestTime;
        }
        
        return returnTime / results.size();
    }

    static class Task implements Comparable<Task> {
        private int no;
        private int requestTime;
        private int duration;
        private int completedTime;

        public Task(int no, int requestTime, int duration) {
            this.no = no;
            this.requestTime = requestTime;
            this.duration = duration;
        }

        public void complete(int time) {
            this.completedTime = time;
        }

        @Override
        public int compareTo(Task o) {
            if (this.duration == o.duration) {
                return this.requestTime - o.requestTime;
            }

            return this.duration - o.duration;
        }
    }
}
```
위 풀이는 틀린 풀이.
지금은 소요 시간이 빠른 순으로 우선 정렬하는데, 소요 시간이 아무리 빨라도 요청 시간에 도달하지 못했으면 실행할 수 없음
이 부분이 전혀 고려되지 않고 설계되어 틀림

하지만 해당 부분을 알아도 여전히 구현이 어려움
여러번 풀어보며 익히기

# 2차 풀이
```java
// 1. 다리를 지나는 트럭과 마찬가지로 기준이 시간이 되어야 함
// 2. 도착 시간을 기준으로 jobs배열을 정렬해 큐에 저장
// 3. 최초에 도착 시간을 기준으로 작업을 시작하고, 소요 시간만큼 시간을 더함
// 4. 소요 시간 기준으로 도착 시간이 작은 task들을 우선순위 큐에 넣어 소요 시간이 짧은 작업부터 작업
import java.util.*;

class Solution {
    public int solution(int[][] jobs) {
        List<Task> tasks = new ArrayList<>();
        for (int[] job : jobs) {
            tasks.add(new Task(job[0], job[1]));
        }
        
        tasks.sort((t1, t2) -> t1.requestTime - t2.requestTime);
        Queue<Task> q = new LinkedList<>(tasks);
        
        int currentTime = 0;
        int totalReturnTime = 0;
        PriorityQueue<Task> pq = new PriorityQueue<>((t1, t2) -> t1.duration - t2.duration);
        while (!q.isEmpty()) {
            while(!q.isEmpty() && q.peek().requestTime <= currentTime) {
                pq.offer(q.poll());
            }
            
            if (pq.isEmpty()) { // 반복문을 통과해도 우선순위 큐가 비어있다면 현재 시간에 해당하는 작업이 없는 것이므로 가장 빨리 도착하는 작업을 뽑아냄
                Task next = q.poll();
                pq.offer(next); // 같은 도착하나, 소요시간이 다른경우엔 어떻게?
                
                while (!q.isEmpty() && q.peek().requestTime == next.requestTime) {
                    pq.offer(q.poll());
                }
            }
            
            Task currentTask = pq.poll();
            currentTime += currentTask.duration;                      // 3
            totalReturnTime += currentTime - currentTask.requestTime; // 3
        }
        
        while (!pq.isEmpty()) {
            Task currentTask = pq.poll();
            currentTime += currentTask.duration;                      
            totalReturnTime += currentTime - currentTask.requestTime; 
        }
        
        return totalReturnTime / tasks.size();
    }
    
    static class Task {
        private int requestTime;
        private int duration;
        
        public Task (int requestTime, int duration) {
            this.requestTime = requestTime;
            this.duration = duration;
        }
    }
}
```

```java
// 1. 다리를 지나는 트럭과 마찬가지로 기준이 시간이 되어야 함
// 2. 도착 시간을 기준으로 jobs배열을 정렬해 큐에 저장
// 3. 최초에 도착 시간을 기준으로 작업을 시작하고, 소요 시간만큼 시간을 더함
// 4. 소요 시간 기준으로 도착 시간이 작은 task들을 우선순위 큐에 넣어 소요 시간이 짧은 작업부터 작업
import java.util.*;

class Solution {
    public int solution(int[][] jobs) {
        List<Task> tasks = new ArrayList<>();
        for (int[] job : jobs) {
            tasks.add(new Task(job[0], job[1]));
        }
        
        tasks.sort((t1, t2) -> t1.requestTime - t2.requestTime);
        Queue<Task> q = new LinkedList<>(tasks);
        
        int currentTime = 0;
        int totalReturnTime = 0;
        PriorityQueue<Task> pq = new PriorityQueue<>((t1, t2) -> t1.duration - t2.duration);
        while (!q.isEmpty()) {
            while(!q.isEmpty() && q.peek().requestTime <= currentTime) {
                pq.offer(q.poll());
            }
            
            if (pq.isEmpty()) { // 반복문을 통과해도 우선순위 큐가 비어있다면 현재 시간에 해당하는 작업이 없는 것이므로 가장 빨리 도착하는 작업을 뽑아냄
                Task next = q.poll();
                pq.offer(next); // 같은 시간에 도착하나, 소요시간이 다른경우엔 어떻게?
                currentTime = next.requestTime;
                
                while (!q.isEmpty() && q.peek().requestTime == next.requestTime) {
                    pq.offer(q.poll());
                }
            }
            
            Task currentTask = pq.poll();
            currentTime += currentTask.duration;                      // 3
            totalReturnTime += currentTime - currentTask.requestTime; // 3
        }
        
        // while (!pq.isEmpty()) {
        //     Task currentTask = pq.poll();
        //     currentTime += currentTask.duration;                      
        //     totalReturnTime += currentTime - currentTask.requestTime; 
        // }
        
        return totalReturnTime / tasks.size();
    }
    
    static class Task {
        private int requestTime;
        private int duration;
        
        public Task (int requestTime, int duration) {
            this.requestTime = requestTime;
            this.duration = duration;
        }
    }
}
```
거의 맞췄지만 
```java
if (pq.isEmpty()) { 
	Task next = q.poll();
	pq.offer(next);
	currentTime = next.requestTime; // 이 부분이 추가되어야 함
	
	while (!q.isEmpty() && q.peek().requestTime == next.requestTime) {
		pq.offer(q.poll());
	}
}
```
이 조건문에서 현재 시간에 도착할 수 없었던 작업들인 경우 작업 도착 시간으로 현재 시간을 갱신해줘야 했음
코드를 천천히 읽어보며 확인했으면 충분히 인지 가능했던 엣지 케이스이기도함.

추가적으로 이 조건문 내부의 반복문은 아래 반복문에서 함께 해결하도록 만들 수 있음
```java
while(!q.isEmpty() && q.peek().requestTime <= currentTime) {
	pq.offer(q.poll());
}
```
다음 풀이때는 이 부분을 고려해서 풀어보기

# 3차 풀이
```java
// 1. jobs를 순회하며 Task로 변환
// 2. 해당 데이터를 큐에 담기
// 3. 큐에서 하나씩 꺼내며 우선순위 큐에 담아 소요 시간 짧은 순으로 정렬

import java.util.*;
import java.util.stream.*;

class Solution {
    public int solution(int[][] jobs) {
        List<Task> values = Arrays.stream(jobs)
            .map(job -> new Task(job[0], job[1]))
            .sorted((t1, t2) -> t1.requestTime - t2.requestTime)
            .collect(Collectors.toList());
        
        Queue<Task> tasks = new LinkedList<>(values);
        PriorityQueue<Task> pq = new PriorityQueue<>((t1, t2) -> t1.duration - t2.duration);
        
        int totalReturnTime = 0;
        int currentTime = 0;
        while (!tasks.isEmpty() || !pq.isEmpty()) {
            while (!tasks.isEmpty() && tasks.peek().requestTime <= currentTime) { // 작업 요청 시간이 현재 시간보다 작다면
                pq.offer(tasks.poll());
            }
            
            if (pq.isEmpty()) { // 그럼에도 작업 대기 pq가 비어있다면 가장 빨리오는 작업 하나를 꺼냄
                currentTime = tasks.peek().requestTime;
                continue;
            }
            
            Task task = pq.poll();
            currentTime += task.duration;
            totalReturnTime += currentTime - task.requestTime;
        }
             
        return totalReturnTime / jobs.length;
    }
    
    static class Task {
        int requestTime;
        int duration;
        
        public Task(int requestTime, int duration) {
            this.requestTime = requestTime;
            this.duration = duration;
        }
    }
}
```
한 번 더 풀어서 익숙해지기