# 1. 스레드 안정성
일반적으로 스레드 안전성의 정의에 대해 다음과 같이 설명한다.
> 어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있다면 그 객체는 스레드 안전하다.

하지만 이는 실제로 적용하는데 필요한 정보가 빠져있다. 좀 더 자세히 정의하자면 다음과 같다.
> 여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서
> 객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면, "그 객체는 스레드 안전하다"라고 말한다.
> - 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 없다.
> - 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.

이러한 정의와 함께 자바 언어의 스레드 안정성에 대해 알아보자.
## 1.1 자바의 스레드 안정성
스레드의 안정성은 이분법적 사고에서 벗어나 아래처럼 안전함의 정도에 따라 다섯 단계로 구분할 수 있다.
- **불변**
	- 불변 객체는 객체 자체의 메서드 구현과 호출자 모두에서 아무런 안전장치 없이도 스레드 안전
- **절대적 스레드 안전**
	- 앞선 정의에 따르면 실제로 절대적 스레드 안전을 구현하는 것은 매우 많은 비용이 들거나 비현실적
	- 자바 API에서 스레드 안전하다고 표시된 클래스 대부분이 절대적 스레드 안전을 의미하지 않음
- **조건부 스레드 안전**
	- 일반적으로 스레드 안전하다고 말할 때의 안전 수준을 의미
	- 단일한 작업은 스레드 안전하게 수행되나, 특정 순서로 연달아 호출하는 작업에선 호출자에서 추가 동기화 작업이 필요
- **스레드 호환**
	- 객체 자체는 스레드 안전하지 않으나 호출자가 적절히 조치하면 스레드 안전하게 사용할 수도 있음 
- **스레드 적대적**
	- 호출자가 동기화 조치를 취해도 멀티스레드 환경에서 안전하게 사용할 수 없음

## 1.2 스레드 안전성의 구현
### 상호 배제 동기화
자바에서 상호 배제 동기화를 구현하는 가장 기본적인 수단은 syncronized 키워드다.
syncronized를 통해 락을 얻으면 다른 스레드는 락을 얻은 스레드가 락을 해제할 때까지 블록된다. 
즉, 락을 해제할 때까지 다른 스레드의 진입을 무조건 차단한다. 그러므로 락 소유 스레드가 락을 해제하도록 강제할 방법이 없다.
이 과정에서 스레드를 정지하거나 깨워야 하는데, Java 스레드는 커널 스레드와 매핑된 스레드이기 때문에 비용이 많이 발생한다. 

이러한 문제에 대한 해결책으로 JDK 5부터 Lock인터페이스가 추가되었다.
Lock 인터페이스는 논블록 구조의 상호배제 동기화를 구현한다.
