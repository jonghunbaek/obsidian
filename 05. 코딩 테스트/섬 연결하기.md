---
ÌîåÎû´Ìèº: ÌîÑÎ°úÍ∑∏ÎûòÎ®∏Ïä§
Î¨∏Ï†ú Ïù¥Î¶Ñ: ÏÑ¨ Ïó∞Í≤∞ÌïòÍ∏∞
ÏïåÍ≥†Î¶¨Ï¶ò: Ïú†ÎãàÏò®ÌååÏù∏Îìú, Í∑∏Î¶¨Îîî
tags:
  - Ïú†ÎãàÏò®ÌååÏù∏Îìú
  - Í∑∏Î¶¨Îìú
date: 2025-09-16
aliases:
  - Ïú†ÎãàÏò®ÌååÏù∏Îìú
Î≥µÏäµ ÌíÄÏù¥: 250916(X), 250921(X), 251004(X), 251011(X), 251017(O), 251024(O), 251107(O), 251112(O)
---
# 1Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Edge[] edges = Arrays.stream(costs)
            .map(cost -> new Edge(cost[0], cost[1], cost[2]))
            .sorted((e1, e2) -> e1.cost - e2.cost)
            .toArray(Edge[]::new);
        
        Node[] nodes = new Node[n];
        for (int i = 0; i < nodes.length; i++) {
            nodes[i] = new Node();
        }
        
        int totalCost = 0;
        for (Edge edge : edges) {
            Node from = nodes[edge.from];
            Node to = nodes[edge.to];
            
            if (from.isConnected(to)) {
                continue;
            }
            
            from.connect(to);
            totalCost += edge.cost;
        }
        
        return totalCost;
    }
    
    static class Edge {
        int from;
        int to;
        int cost;
        
        public Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }
    
    static class Node {
        int depth = 1;
        Node parent;
        
        public void connect(Node other) {
            if (isConnected(other)) {
                return;
            }
            
            Node root1 = root();
            Node root2 = other.root();
            
            if (root1.depth > root2.depth) {
                root2.parent = root1;
            } else if (root1.depth < root2.depth) {
                root1.parent = root2;
            } else {
                root2.parent = root1;
                root1.depth++;
            }
        }
        
        public boolean isConnected(Node other) {
            return root() == other.root();
        }
        
        public Node root() {
            return parent == null ? this : parent.root();
        }
        
    }
}
```
Ïú†ÎãàÏò® ÌååÏù∏Îìú ÏïåÍ≥†Î¶¨Ï¶òÏùÑ ÏïåÏïÑÏïº ÏâΩÍ≤å Ìë∏Îäî Î¨∏Ï†ú.
Ïú†ÎãàÏò® ÌååÏù∏ÎìúÏùò ÌïµÏã¨ÏùÄ Ìïú ÏßëÌï©Ïùò ÏöîÏÜåÎì§ÏùÑ ÌïòÎÇòÏùò ÎåÄÌëúÎ°úÎ∂ÄÌÑ∞ Ï∞æÍ∏∞ ÏâΩÍ≤å ÎßåÎìúÎäî Í≤É.
Ïù¥Î•º ÌÜµÌï¥ ÍπäÏùÄ ÌÉêÏÉâÏùÑ ÌïòÏßÄ ÏïäÍ≥†ÎèÑ Îëê ÏöîÏÜåÍ∞Ä Í∞ôÏùÄ ÏßëÌï©Ïóê ÏÜçÌï¥ÏûàÎäîÏßÄ ÌôïÏù∏Ìï† Ïàò ÏûàÏùå
ÎπÑÏö©ÏùÑ Ï†ÅÏùÄ ÏàúÏúºÎ°ú Ï†ïÎ†¨Ìï¥ ÎÜìÏïòÍ∏∞ ÎïåÎ¨∏Ïóê Í∑∏ÎåÄÎ°ú ÎçîÌïòÍ∏∞Îßå ÌïòÎ©¥Îê®.
ÎÇòÏ§ëÏóê Îã§Î•∏ Ïú†ÎãàÏò® ÌååÏù∏Îìú Î¨∏Ï†úÎ•º ÌíÄÏñ¥Î≥¥Í∏∞.

# 2Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Edge[] edges = Arrays.stream(costs)
            .map(cost -> new Edge(cost[0], cost[1], cost[2]))
            .sorted((e1, e2) -> e1.cost - e2.cost)
            .toArray(Edge[]::new);
        
        Node[] nodes = new Node[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = new Node();
        }
        
        int totalCost = 0;
        for (Edge edge : edges) {
            Node n1 = nodes[edge.from];
            Node n2 = nodes[edge.to];
            
            if (n1.isConnected(n2)) continue;
            
            n1.merge(n2);
            totalCost += edge.cost;
        }
        
        return totalCost;
    }
    
    static class Node {
        int depth = 1;
        Node parent = null;
        
        public boolean isConnected(Node other) {
            return root() == other.root();
        }
        
        public void merge(Node other) {
            if (isConnected(other)) {
                return;
            }
            
            Node r1 = root();
            Node r2 = other.root();
            
            if (r1.depth > r2.depth) {
                r2.parent = r1;
            } else if (r1.depth < r2.depth) {
                r1.parent = r2;
            } else {
                r2.parent = r1;
                r1.depth++;
            }
        }
        
        private Node root() {
            if (this.parent == null) {
                return this;
            }
            
            return this.parent.root();
        }
    }
    
    static class Edge {
        int from;
        int to;
        int cost;
        
        public Edge(int from, int to, int cost) {
            this.from = from;
            this.to = to;
            this.cost = cost;
        }
    }
}
```
Ïú†ÎãàÏò® ÌååÏù∏Îìú Íµ¨ÌòÑÏù¥ ÏïÑÏßÅ ÏâΩÏßÄ ÏïäÏùå

# 3Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]); // ÎÇÆÏùÄ ÎπÑÏö©ÏàúÎåÄÎ°ú Ï†ïÎ†¨
        int[] nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = i; // ÏûêÍ∏∞ ÏûêÏã†ÏùÑ Ï¥àÍπÉÍ∞íÏúºÎ°ú ÏÑ§Ï†ï
        }
        
        int totalCost = 0;
        for (int[] cost : costs) {
            int from = cost[0];
            int to = cost[1];
            
            if (find(from, nodes) != find(to, nodes)) { // Îëê ÏÑ¨Ïù¥ Ïó∞Í≤∞ÎêòÏñ¥ ÏûàÏßÄ ÏïäÎã§Î©¥
                union(from, to, nodes); // Îëê ÏÑ¨ÏùÑ Ïù¥Ïñ¥Ï§å
                totalCost += cost[2]; // ÎπÑÏö©ÏùÑ ÎçîÌï¥Ï§å
            }
        }
        
        return totalCost;
    }
    
    private int find(int start, int[] nodes) {
        if (nodes[start] == start) { // Ï¥àÍπÉÍ∞í Í∑∏ÎåÄÎ°úÍ±∞ÎÇò, ÏûêÏã†Ïù¥ Î£®Ìä∏Ïù∏ Í≤ΩÏö∞
            return start;    
        }
        
        return find(nodes[start], nodes);
    }
    
    private void union(int from, int to, int[] nodes) {
        int r1 = find(from, nodes);
        int r2 = find(to, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }
}
```

Í∏∞Ï°¥ Ï±ÖÏóê ÎÇòÏôÄÏûàÎäî ÌíÄÏù¥Îäî ÏïÑÎ¨¥ÎûòÎèÑ ÏßÅÍ¥ÄÏ†ÅÏúºÎ°ú Ïù¥Ìï¥ÌïòÍ∏∞ Ïñ¥Î†µÍ≥†, ÏâΩÍ≤å Í∏∞ÏñµÌïòÍ∏∞ Ïñ¥Î†§ÏõÄ
ÎåÄÏã† ÎÇòÎßåÏùò ÌíÄÏù¥Î°ú ÌíÄÏñ¥ Í∏∞ÏñµÌï† Í≤É

# 4Ï∞® ÌíÄÏù¥
```java
// 1. ÏµúÏÜå ÎπÑÏö©ÏúºÎ°ú Í≥ÑÏÇ∞Ìï† Ïàò ÏûàÎèÑÎ°ù ÎπÑÏö© Í∏∞Ï§Ä Ïò§Î¶ÑÏ∞®ÏàúÏúºÎ°ú Ï†ïÎ†¨
// 2. costs Î∞∞Ïó¥ÏùÑ ÏàúÌöåÌïòÎ©∞ ÏÑ¨ Î∞©Î¨∏ Î∞∞Ïó¥ÏùÑ ÌëúÏãú
// 3. Î∞©Î¨∏Ìï† Ïàò ÏûàÏùÑ ÎïåÎßàÎã§ ÎπÑÏö©ÏùÑ ÎçîÌïòÍ∏∞
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int i = 0; i < n; i++) {
            if (isConnected(costs[i][0], costs[i][1], nodes)) {
                continue;
            }
            
            connect(costs[i][0], costs[i][1], nodes);
            totalCost += costs[i][2];
        }
        
        return totalCost;
    }
    
    private void connect(int from, int to, int[] nodes) {
        if (isConnected(from, to, nodes)) {
            return;
        }
        
        if (from < to) {
            nodes[to] = from;
        } else {
            nodes[from] = to;
        }
    }
                
    private boolean isConnected(int from, int to, int[] nodes) {
        return nodes[from] == nodes[to];
    }
}
```
Ï≤òÏùåÏóî Î¨¥ÏùòÏãùÏ†ÅÏúºÎ°ú Ïú†ÎãàÏò® ÌååÏù∏ÎìúÎ•º ÏÉùÍ∞ÅÌïòÏßÄ Î™ªÌïòÍ≥† Î∞©Î¨∏ Î∞∞Ïó¥ÏùÑ Ïù¥Ïö©Ìï¥ ÌíÄÏù¥ÌïòÎ†§Í≥† Ìï®.
ÌïòÏßÄÎßå Ï†ÑÏ≤¥Ï†ÅÏù∏ Íµ¨Ï°∞Îäî Ïú†ÎãàÏò® ÌååÏù∏ÎìúÏôÄ Ïú†ÏÇ¨ÌñàÍ≥†, Í≤∞Íµ≠ ÌíÄÏñ¥ÎÇ¥ÏßÄ Î™ªÌï®

```java
// 1. ÏµúÏÜå ÎπÑÏö©ÏúºÎ°ú Í≥ÑÏÇ∞Ìï† Ïàò ÏûàÎèÑÎ°ù ÎπÑÏö© Í∏∞Ï§Ä Ïò§Î¶ÑÏ∞®ÏàúÏúºÎ°ú Ï†ïÎ†¨
// 2. costs Î∞∞Ïó¥ÏùÑ ÏàúÌöåÌïòÎ©∞ ÏÑ¨ Î∞©Î¨∏ Î∞∞Ïó¥ÏùÑ ÌëúÏãú
// 3. Î∞©Î¨∏Ìï† Ïàò ÏûàÏùÑ ÎïåÎßàÎã§ ÎπÑÏö©ÏùÑ ÎçîÌïòÍ∏∞
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int[] cost : costs) {
            int from = cost[0];
            int to = cost[1];
            if (find(from, nodes) == find(to, nodes)) {
                continue;
            }
            
            connect(from, to, nodes);
            totalCost += cost[2];
        }
        
        return totalCost;
    }
    
    private void connect(int from, int to, int[] nodes) {
        int r1 = find(from, nodes);
        int r2 = find(to, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }

    private int find(int no, int[] nodes) {
        if (nodes[no] == no) {
            return no;
        }
        
        return find(nodes[no], nodes);
    }
}
```

# 5Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int[] nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        int totalCost = 0;
        for (int i = 0; i < costs.length; i++) {
            if (findRoot(costs[i][0], nodes) == findRoot(costs[i][1], nodes)) continue;
            
            totalCost += costs[i][2];
            connect(costs[i][0], costs[i][1], nodes);
        }
        
        return totalCost;
    }
    
    private int findRoot(int node, int[] nodes) {
        if (nodes[node] == node) {
            return node;
        }
        
        return findRoot(nodes[node], nodes);
    }
    
    private void connect(int n1, int n2, int[] nodes) {
        int r1 = findRoot(n1, nodes);
        int r2 = findRoot(n2, nodes);
        
        if (r1 < r2) {
            nodes[r2] = r1;
        } else {
            nodes[r1] = r2;
        }
    }
}
```
Ïù¥Ï†úÏïº Ïú†ÎãàÏò® ÌååÏù∏ÎìúÏóê ÏùµÏàôÌï¥ÏßÑÎìØ

# 6Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        int[] nodes = new int[n];
        for (int i = 0; i < nodes.length; i++) {
            nodes[i] = i;
        }
        
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int totalCost = 0;
        for (int[] cost : costs) {
            if (find(cost[0], nodes) == find(cost[1], nodes)) continue;
            
            connect(cost[0], cost[1], nodes);
            totalCost += cost[2];
        }
        
        return totalCost;
    }
    
    private int find(int node, int[] nodes) {
        if (nodes[node] == node) {
            return node;
        }
        
        return find(nodes[node], nodes);
    }
    
    private void connect(int node1, int node2, int[] nodes) {
        int root1 = find(node1, nodes);
        int root2 = find(node2, nodes);
        
        if (root1 < root2) {
            nodes[root2] = root1;
        } else {
            nodes[root1] = root2;
        }
    }
}
```
Ïú†ÎãàÏò® ÌååÏù∏ÎìúÎäî Ï¢Ä Îçî Îã§ÏñëÌïú Î¨∏Ï†úÎ•º ÌíÄÏñ¥Î¥êÏïºÌï† ÎìØ

# 7Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        int[] islands = new int[n];
        for (int i = 0; i < islands.length; i++) {
            islands[i] = i;
        }
        
        Arrays.sort(costs, (i1, i2) -> i1[2] - i2[2]);
        
        int totalCost = 0;
        for (int[] cost : costs) {
            if (find(cost[0], islands) == find(cost[1], islands)) continue;
            
            union(cost[0], cost[1], islands);
            totalCost += cost[2];
        }
        
        return totalCost;
    }
    
    private int find(int node, int[] islands) {
        if (islands[node] == node) {
            return node;
        }
        
        return find(islands[node], islands);
    }
    
    private void union(int node1, int node2, int[] islands) {
        int root1 = find(node1, islands);
        int root2 = find(node2, islands);
        
        if (root1 < root2) {
            islands[root2] = root1;
        } else {
            islands[root1] = root2;
        }
    }
}
```
Î¨∏Ï†úÎäî ÎßûÏ∑ÑÏßÄÎßå, Ï≤òÏùå Î¨∏Ï†úÎ•º Ï†ëÍ∑ºÌï† Îïå Ïú†ÎãàÏò® ÌååÏù∏ÎìúÎ•º ÏÇ¨Ïö©Ìï¥Ïïº ÌïúÎã§Îäî ÏÉùÍ∞ÅÏù¥ Ï†ÑÌòÄ ÏïàÎì§ÏóàÏùå
Ïñ¥Îñ§ ÏºÄÏù¥Ïä§ÏóêÏÑú Ïú†ÎãàÏò® ÌååÏù∏ÎìúÎ•º Ïç®ÏïºÌï†ÏßÄ Î™ÖÌôïÌïòÍ≤å Ïù¥Ìï¥Ìï† ÌïÑÏöîÍ∞Ä ÏûàÏùå

### üí° Ïú†ÎãàÏò®-ÌååÏù∏Îìú ÏïåÍ≥†Î¶¨Ï¶òÏùò ÌïµÏã¨ Ïó≠Ìï†
Ïú†ÎãàÏò®-ÌååÏù∏Îìú ÏïåÍ≥†Î¶¨Ï¶òÏùÄ Í∏∞Î≥∏Ï†ÅÏúºÎ°ú ÏõêÏÜåÎì§ÏùÑ Ïó¨Îü¨ Í∞úÏùò ÏßëÌï©ÏúºÎ°ú ÎÇòÎàÑÏñ¥ Í¥ÄÎ¶¨ÌïòÎ©∞, Îã§Ïùå Îëê Í∞ÄÏßÄ Ïó∞ÏÇ∞ÏùÑ Ìö®Ïú®Ï†ÅÏúºÎ°ú ÏàòÌñâÌïòÎäî Îç∞ Î™©Ï†ÅÏù¥ ÏûàÏäµÎãàÎã§.
1. **Find (Ï∞æÍ∏∞):** ÌäπÏ†ï ÏõêÏÜåÍ∞Ä ÏÜçÌïú ÏßëÌï©Ïùò **ÎåÄÌëú ÏõêÏÜå(Î£®Ìä∏ ÎÖ∏Îìú)**Î•º Ï∞æÎäî Ïó∞ÏÇ∞. Ïù¥Î•º ÌÜµÌï¥ Îëê ÏõêÏÜåÍ∞Ä **Í∞ôÏùÄ ÏßëÌï©**Ïóê ÏÜçÌïòÎäîÏßÄ Îπ†Î•¥Í≤å ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.
2. **Union (Ìï©ÏπòÍ∏∞):** Îëê ÏõêÏÜåÍ∞Ä ÏÜçÌïú ÏßëÌï©ÏùÑ **ÌïòÎÇòÎ°ú Ìï©ÏπòÎäî** Ïó∞ÏÇ∞.
Í≤ΩÎ°ú ÏïïÏ∂ï(Path Compression) Î∞è Îû≠ÌÅ¨(Rank)ÎÇò ÌÅ¨Í∏∞(Size) Í∏∞Î∞òÏùò Ìï©ÏπòÍ∏∞ ÏµúÏ†ÅÌôîÎ•º Ï†ÅÏö©ÌïòÎ©¥ Í±∞Ïùò $O(\alpha(N))$Ïùò ÏÉÅÏàò ÏãúÍ∞ÑÏóê Í∞ÄÍπåÏö¥ Ìö®Ïú®Ï†ÅÏù∏ Ïó∞ÏÇ∞ÏùÑ ÏàòÌñâÌï† Ïàò ÏûàÏäµÎãàÎã§. ($\alpha$Îäî ÏïÑÏª§Îßå Ìï®ÏàòÏùò Ïó≠Ìï®ÏàòÎ°ú, Îß§Ïö∞ ÎäêÎ¶¨Í≤å Ï¶ùÍ∞ÄÌï©ÎãàÎã§.)
---
### üíª ÏΩîÎî© ÌÖåÏä§Ìä∏ Ï∂úÏ†ú Ïú†Ìòï (ÌïµÏã¨ ÌôúÏö© ÏÇ¨Î°Ä)

Ïú†ÎãàÏò®-ÌååÏù∏Îìú ÏïåÍ≥†Î¶¨Ï¶òÏùÄ Ï£ºÎ°ú **Ïó∞Í≤∞ Í¥ÄÍ≥Ñ, Í∑∏Î£πÌôî, ÎòêÎäî ÏÇ¨Ïù¥ÌÅ¥ Ïó¨Î∂Ä**Î•º ÌåêÎã®Ìï¥Ïïº ÌïòÎäî Î¨∏Ï†úÏóêÏÑú Î™ÖÌôïÌïòÍ≤å ÌôúÏö©Îê©ÎãàÎã§.

| **Ïú†Ìòï**                | **ÏÑ§Î™Ö**                                                                                                                   | **ÌïµÏã¨ ÌÇ§ÏõåÎìú**                  |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------ | --------------------------- |
| **1. ÏµúÏÜå Ïã†Ïû• Ìä∏Î¶¨ (MST)** | **ÌÅ¨Î£®Ïä§Ïπº(Kruskal) ÏïåÍ≥†Î¶¨Ï¶ò**ÏóêÏÑú ÏÇ¨Ïö©Îê©ÎãàÎã§. Í∞ÑÏÑ†ÏùÑ ÌïòÎÇòÏî© Ï∂îÍ∞ÄÌï† Îïå, Îëê Ï†ïÏ†êÏù¥ Ïù¥ÎØ∏ Í∞ôÏùÄ ÏßëÌï©Ïóê ÏÜçÌï¥ ÏûàÎã§Î©¥ (Find Ïó∞ÏÇ∞ Í≤∞Í≥ºÍ∞Ä Í∞ôÎã§Î©¥) **ÏÇ¨Ïù¥ÌÅ¥Ïù¥ ÌòïÏÑ±**ÎêòÎØÄÎ°ú Ìï¥Îãπ Í∞ÑÏÑ†ÏùÑ Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏäµÎãàÎã§. | ÌÅ¨Î£®Ïä§Ïπº ÏïåÍ≥†Î¶¨Ï¶ò, ÏÇ¨Ïù¥ÌÅ¥ ÌåêÎ≥Ñ, ÏµúÏÜå ÎπÑÏö© Ïó∞Í≤∞ |
| **2. Ïó∞Í≤∞ ÏöîÏÜå Î∞è Í∑∏Î£π ÌåêÎ≥Ñ**  | Ï£ºÏñ¥ÏßÑ ÎÖ∏ÎìúÎì§ Í∞ÑÏùò Í¥ÄÍ≥ÑÎ•º Î∞îÌÉïÏúºÎ°ú **ÏÑúÎ°ú Ïó∞Í≤∞Îêú Í∑∏Î£π(ÏßëÌï©)**Ïùò Í∞úÏàòÎ•º ÏÑ∏Í±∞ÎÇò, ÌäπÏ†ï Îëê ÎÖ∏ÎìúÍ∞Ä **Í∞ôÏùÄ Í∑∏Î£πÏóê ÏÜçÌïòÎäîÏßÄ** Ïó¨Î∂ÄÎ•º ÌåêÎã®ÌïòÎäî Î¨∏Ï†úÏûÖÎãàÎã§.                                 | Í∑∏Î£πÌôî, ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞, ÏπúÍµ¨ Í¥ÄÍ≥Ñ, Ïó¨Ìñâ Í≤ΩÎ°ú  |
| **3. Í∑∏ÎûòÌîÑÏùò ÏÇ¨Ïù¥ÌÅ¥ ÌåêÎ≥Ñ**    | Î¨¥Î∞©Ìñ• Í∑∏ÎûòÌîÑÏóêÏÑú Í∞ÑÏÑ†ÏùÑ ÌïòÎÇòÏî© Ï∂îÍ∞ÄÌï† Îïå, Ïú†ÎãàÏò®-ÌååÏù∏Îìú Ïó∞ÏÇ∞ÏùÑ ÌÜµÌï¥ Ï∂îÍ∞ÄÌïòÎ†§Îäî Îëê ÎÖ∏ÎìúÏùò ÎåÄÌëú ÏõêÏÜåÍ∞Ä Ïù¥ÎØ∏ Í∞ôÎã§Î©¥ **ÏÇ¨Ïù¥ÌÅ¥**Ïù¥ Ï°¥Ïû¨ÌïúÎã§Í≥† ÌåêÎã®Ìï©ÎãàÎã§. (MSTÏùò ÏõêÎ¶¨ÏôÄ Ïú†ÏÇ¨)                    | Î¨¥Î∞©Ìñ• Í∑∏ÎûòÌîÑ, ÏÇ¨Ïù¥ÌÅ¥ Ïó¨Î∂Ä ÌôïÏù∏          |

Ïù¥Îü¨Ìïú Î¨∏Ï†úÎì§ÏùÑ Ï†ëÌñàÏùÑ Îïå, "Ïñ¥Îñ§ ÏõêÏÜåÎì§Ïù¥ ÏÑúÎ°ú Ïó∞Í≤∞ÎêòÏñ¥ ÌïòÎÇòÏùò ÏßëÌï©ÏùÑ Ïù¥Î£®ÎäîÍ∞Ä?"ÎùºÎäî ÏßàÎ¨∏Ïóê ÎãµÌï¥Ïïº ÌïúÎã§Î©¥ Ïú†ÎãàÏò®-ÌååÏù∏ÎìúÎ•º Îñ†Ïò¨Î¶¨ÏãúÎ©¥ Îê©ÎãàÎã§.

---
Ïú†ÎãàÏò® ÌååÏù∏Îìú ÏïåÍ≥†Î¶¨Ï¶òÏóê ÎåÄÌïú ÏûêÏÑ∏Ìïú Í∞úÎÖêÍ≥º Íµ¨ÌòÑ Î∞©Î≤ïÏùÑ [ÏïåÍ≥†Î¶¨Ï¶ò ÏΩîÎî©ÌÖåÏä§Ìä∏ ÌïµÏã¨Ïù¥Î°† Í∞ïÏùò - Ïú†ÎãàÏò® ÌååÏù∏Îìú](https://www.youtube.com/watch?v=klBh4ZglHYo) ÏòÅÏÉÅÏóêÏÑú ÌôïÏù∏ÌïòÏã§ Ïàò ÏûàÏäµÎãàÎã§.

# 8Ï∞® ÌíÄÏù¥
```java
import java.util.*;

class Solution {
    public int solution(int n, int[][] costs) {
        int[] nodes = new int[n];
        for (int i = 0; i < n; i++) {
            nodes[i] = i;
        }
        
        Arrays.sort(costs, (c1, c2) -> c1[2] - c2[2]);
        int totalCost = 0;
        for (int[] info : costs) {
            int node1 = info[0];
            int node2 = info[1];
            int cost = info[2];
            
            if (find(node1, nodes) == find(node2, nodes)) continue;
            
            union(node1, node2, nodes);
            totalCost += cost;
        }
        
        return totalCost;
    }
    
    private int find(int node, int[] nodes) {
        if (nodes[node] == node) {
            return node;
        }
        
        return find(nodes[node], nodes);
    }
    
    private void union(int node1, int node2, int[] nodes) {
        int root1 = find(node1, nodes);
        int root2 = find(node2, nodes);
        
        if (root1 < root2) {
            nodes[root2] = root1;
        } else {
            nodes[root1] = root2;
        }
    }
}
```