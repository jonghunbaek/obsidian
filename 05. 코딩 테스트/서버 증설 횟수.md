---
플랫폼: 프로그래머스
알고리즘: 구현, 그리디
tags:
  - 구현
  - 그리디
date: 2026-02-19
복습 풀이: 260219(O), 260226(O)
---
# 1차 풀이
```java
// 구현?  
// 1. 서버 대수를 기록하는 int[] 생성(길이는 24)// 2. 시간대별로 player 원소를 확인하여 서버 대수 갱신  
// 3. 갱신할 때 전체 증설 개수 카운트  
// - 플레이어의 수가 m보다 작으면 스킵  
// - 현 시간대에 존재하는 서버의 수가 m
class Solution {
    public int solution(int[] players, int m, int k) {
        int[] servers = new int[players.length];
        int result = 0;
        for (int i = 0; i < players.length; i++) {
            if (players[i] < m) continue;
            if (servers[i] >= players[i] / m) continue;

            int needed = (players[i] / m) - servers[i];
            for (int j = i; j < Math.min(i + k, players.length); j++) {
                servers[j] += needed;
            }

            result += needed;
        }

        return result;
    }
}
```
players의 길이가 24라 구간합 방식이 필요 없었음
만약 길이가 더 길어졌다면 구간합이 필수?

# 2차 풀이
```java
class Solution {
    public int solution(int[] players, int m, int k) {
        int result = 0;
        int[] servers = new int[players.length];
        for (int i = 0; i < players.length; i++) {
            if (players[i] < m) continue;
            
            int needed = (players[i] - (servers[i] * m)) / m;
            if (needed <= 0) continue;
            
            for (int j = i; j < i + k; j++) {
                if (j >= players.length) break;
                servers[j] += needed;
            }
            
            result += needed;
        }
        
        return result;
    }
}
```
needed가 0미만이 되는 예외 케이스를 찾지 못해 오래걸림

```java
class Solution {
    public int solution(int[] players, int m, int k) {
        int answer = 0;
        // 각 시간대(0~23시)에 증설된 서버 대수를 기록하는 배열
        int[] addedAt = new int[24];
        int currentActiveServers = 0;

        for (int i = 0; i < 24; i++) {
            // 1. 만료된 서버 처리: i시간 기준으로 k시간 전에 증설된 서버는 소멸
            if (i >= k) {
                currentActiveServers -= addedAt[i - k];
            }

            // 2. 현재 시간에 필요한 총 서버 대수 계산
            int totalNeeded = players[i] / m;

            // 3. 현재 가동 중인 증설 서버가 부족한 경우
            if (totalNeeded > currentActiveServers) {
                int diff = totalNeeded - currentActiveServers;
                answer += diff; // 증설 횟수 누적
                addedAt[i] = diff; // i시에 증설된 대수 기록
                currentActiveServers += diff; // 현재 가동 서버 수 업데이트
            }
        }

        return answer;
    }
}
```