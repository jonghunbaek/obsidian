---
플랫폼: 프로그래머스
문제 이름: 다리를 지나는 트럭
알고리즘: 큐
tags:
  - 큐
date: 2025-09-03
aliases:
  - 큐
복습 풀이: 250903(X), 250907(X), 250913(X), 250920(O)
---
# 1차 풀이
```java
class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {  
    Queue<Integer> bridgeQueue = initBridge(bridge_length);  
    int weightOnBridge = 0;  
    int countOnBridge = 0;  
    int seconds = 0;  
    for (int truckWeight : truck_weights) {  
        while ((weightOnBridge + truckWeight >= weight || countOnBridge + 1 >= bridge_length) && !bridgeQueue.isEmpty()) {  
            int carWeight = bridgeQueue.poll();  
            if (carWeight == 0) {  
                bridgeQueue.add(0);  
                seconds++;  
                continue;  
            }  
  
            weightOnBridge -= carWeight;  
            countOnBridge -= carWeight;  
            seconds++;  
        }  
  
        if (!bridgeQueue.isEmpty() && bridgeQueue.peek() == 0) {  
            bridgeQueue.poll();  
        } else if (!bridgeQueue.isEmpty()) {  
            weightOnBridge -= bridgeQueue.poll();  
            countOnBridge--;  
        }  
  
        bridgeQueue.offer(truckWeight);  
        weightOnBridge += truckWeight;  
        countOnBridge++;  
        seconds++;  
    }  
  
    while (!bridgeQueue.isEmpty()) {  
        bridgeQueue.poll();  
        seconds++;  
    }  
  
    return seconds;  
}
}
```

```java
import java.util.*;

class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Integer> bridge = new LinkedList<>();
        for (int i = 0; i < bridge_length; i++) {
            bridge.offer(0); // 다리를 빈 공간(0)으로 초기화
        }

        int seconds = 0;
        int currentWeightOnBridge = 0;
        int truckIndex = 0; // 대기 트럭을 가리키는 인덱스

        // 대기 트럭이 모두 다리에 올라갈 때까지 반복
        while (truckIndex < truck_weights.length) {
            seconds++;

            // 1. 다리에서 트럭(또는 0)이 하나 빠져나옴
            currentWeightOnBridge -= bridge.poll();

            // 다음 트럭이 올라올 수 있는지 확인
            int nextTruckWeight = truck_weights[truckIndex];
            if (currentWeightOnBridge + nextTruckWeight <= weight) {
                // 2a. 다음 트럭이 다리에 올라옴
                bridge.offer(nextTruckWeight);
                currentWeightOnBridge += nextTruckWeight;
                truckIndex++;
            } else {
                // 2b. 다음 트럭이 못 올라오므로, 빈 공간(0)을 채워넣음
                bridge.offer(0);
            }
        }

        // 마지막 트럭이 다리를 건너는 시간을 더해줌
        return seconds + bridge_length;
    }
}
```
접근 방식 자체는 나쁘지 않았음.
다만 반복을 어떤 기준으로 수행할 지에 대한 명확한 기준이 존재하지 않아 틀림

### 1. 잘못된 메인 루프 구조
```
for (int truckWeight : truck_weights) {
    // ...
}
```
코드의 가장 큰 문제는 `for-each` 문으로 대기 중인 트럭을 하나씩 처리하려 한다는 점입니다. 이 구조에서는 한 트럭이 다리에 올라간 후에야 다음 트럭을 고려하게 됩니다. 하지만 실제로는 여러 트럭이 동시에 다리 위를 움직이고 있으며, 시간은 모든 트럭에게 동일하게 흘러갑니다.

올바른 구조는 `while`문을 사용해 **시간(초)이 1초씩 흐르는 것을 시뮬레이션**해야 합니다.
### 2. 부정확한 시간 계산
```
// while 루프 안
seconds++;

// ...

// while 루프 밖
seconds++;
```
한 트럭을 다리에 올리는 과정에서 `seconds`가 여러 번, 불규칙하게 증가합니다. 예를 들어, 다리에 자리가 날 때까지 `while` 루프 안에서 `seconds`가 여러 번 증가하고, 트럭을 다리에 올린 후 또 `seconds`가 증가합니다. 시간은 이렇게 계산되면 안 되고, 다리에서 무언가 빠져나오고 들어가는 **한 사이클이 정확히 1초**가 되어야 합니다.
### 3. 명백한 버그 (Bug) 🐛
```
countOnBridge -= carWeight; // ❌ 버그!
```
다리를 건넌 트럭이 발생했을 때, 다리 위 트럭의 개수(`countOnBridge`)에서 트럭의 무게(`carWeight`)를 빼고 있습니다. 트럭의 개수는 무게와 상관없이 1씩 줄어들어야 합니다. 올바른 코드는 다음과 같습니다.

```
countOnBridge--; // ✅ 수정
```

이 버그 하나만으로도 정확한 답을 낼 수 없습니다.

### 4. 불필요하고 복잡한 로직
내부 `while`문과 그 뒤에 나오는 `if-else`문은 "다음 트럭이 들어갈 자리를 만든다"는 하나의 목적을 위해 너무 복잡하게 구현되어 있습니다. 이로 인해 로직을 이해하기 어렵고 오류가 발생할 가능성이 커집니다.

## 올바른 해결 전략 ✅
이 문제는 **큐(Queue)를 이용한 시뮬레이션**으로 접근하는 것이 가장 좋습니다.
1. `bridge_length` 크기의 큐를 만들어 다리를 표현하고, 0으로 채워 빈 다리를 만듭니다.
2. 시간(`seconds`)을 1초씩 증가시키는 `while` 루프를 만듭니다.
3. **매초(루프 1회)마다 다음 작업**을 수행합니다.
    - **트럭 이탈**: 큐에서 맨 앞의 요소를 `poll()` 합니다. 이것이 다리를 막 건넌 트럭(또는 빈 공간)입니다.
    - **무게 갱신**: `poll()`한 값이 트럭 무게였다면, 현재 다리 위 총 무게에서 빼줍니다.
    - **트럭 진입**: 대기 중인 다음 트럭이 다리에 올라갈 수 있는지 확인합니다. (조건: `현재 다리 위 무게 + 새 트럭 무게 <= weight`)
    - **진입 결정**
        - **가능하면**: 새 트럭을 큐에 `offer()`하고, 다리 위 총 무게에 더해줍니다.
        - **불가능하면**: 빈 공간을 의미하는 `0`을 큐에 `offer()`하여 다리 길이를 유지합니다.
4. 마지막 트럭이 다리에 진입한 후, 다리의 길이(`bridge_length`)만큼의 시간이 더 지나야 해당 트럭이 다리를 완전히 건너게 됩니다. 따라서, **마지막 트럭이 다리에 올라간 시점에서 `seconds + bridge_length`가 최종 결과**가 됩니다.

# 2차 풀이
```java

// 1. 다리를 큐로 설정하고, 다리 길이만큼 0을 채워 넣기
// 2. 총 트럭 수, 총 무게를 초과하지 않는다면 트럭을 큐에 넣고, 가장 앞의 값을 빼기
// 3. 큐의 모든 요소가 빌때까지 반복
class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Integer> bridge = new LinkedList<>();
        for (int i = 0; i < bridge_length; i++) {
            bridge.add(0);
        }
        
        int totalWeight = 0;
        int time = 0;
        for (int i = 0; i < truck_weights.length; i++) {
            while(!bridge.isEmpty() && totalWeight + truck_weights[i] > weight) {
                totalWeight -= bridge.poll();
                time++;
                bridge.add(0);
            }
            
            bridge.poll();
            bridge.add(truck_weights[i]);
            totalWeight += truck_weights[i];
            time++;
        }
        
        while (!bridge.isEmpty()) {
            bridge.poll();
            time++;
        }
        
        return time;
    }
}
```
반복문의 기준을 뭐로 둘 것인지가 핵심인 문제

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Integer> bridge = new LinkedList<>();
        for (int i = 0; i < bridge_length; i++) {
            bridge.add(0);
        }
        
        int totalWeight = 0;
        int time = 0;
        int idx = 0;
        while (idx < truck_weights.length) {
            int truckWeight = bridge.poll();
            totalWeight -= truckWeight;
            
            if (totalWeight + truck_weights[idx] > weight) {
                bridge.add(0);
            } else {
                bridge.add(truck_weights[idx]);
                totalWeight += truck_weights[idx];
                idx++;    
            }
            
            time++;
        }
        
        return time + bridge_length;
    }
}
```
총 무게가 제한을 넘지 않는 경우에 큐에 다음 트럭의 무게를 넣어줘야 하는데, 안 넣어서 틀림
전체적인 풀이 과정은 이해한 듯

# 4차 풀이
```java
import java.util.*;


// 1. 큐를 이용해 다리를 만들기. 0으로 채워넣어 무게가 없음을 명시
// 2. 다리 하중을 고려하며 트럭을 한 대씩 넣기
// 3. 무게를 초과한다면 다리 위 트럭이 빠져나갈 때까지 0을 계속 넣기
class Solution {
    public int solution(int bridge_length, int weight, int[] truck_weights) {
        Queue<Integer> bridge = new LinkedList<>();
        for (int i = 0; i < bridge_length; i++) {
            bridge.offer(0);
        }
        
        //   3 | 3, 0, 0 | 1  - 4
        // 3 3 | 0, 0, 1 | 
        int truckIdx = 0;
        int time = 0;
        int totalWeight = 0;
        while (truckIdx < truck_weights.length) {
            int next = truck_weights[truckIdx];
            int outWeight = bridge.poll();
            totalWeight -= outWeight;
            
            if (totalWeight + next > weight) {
                bridge.offer(0);
            } else {
                bridge.offer(next);
                truckIdx++;
                totalWeight += next;
            }
            
            time++;
        }
        
        return time + bridge_length;
    }
}
```
반복문 구현에 꽤 애를 먹음
다리위 트럭 무게와 다음 트럭 무게의 합이 무게 제한 이하일 경우 트럭 무게 더해주는 것을 깜빡해 틀릴뻔함

또한 조건문 분기전에 트럭 무게를 미리 빼줘야 함. 해당 부분에 대한 내용은 반복문 위에 주석을 보면 알 수 있음