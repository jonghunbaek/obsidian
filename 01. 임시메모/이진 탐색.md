```java
// 1단계: 탐색 범위 설정
int start = 가능한 답의 최솟값;
int end = 가능한 답의 최댓값;
int answer = 0; // 답을 저장할 변수

// 2단계: 반복문 조건 설정
while (start <= end) {
    int mid = (start + end) / 2; // 중앙값 (Integer overflow 방지)

    // 3단계: 결정 함수 호출
    if (isPossible(mid)) {
        // 4단계: 범위 좁히기
        // (문제 유형에 따라 이 부분의 로직이 달라짐)
    } else {
        // (문제 유형에 따라 이 부분의 로직이 달라짐)
    }
}
return answer;
```
### 1단계: 탐색 범위 설정 (`start`, `end`)
문제에서 요구하는 답이 될 수 있는 **가장 작은 값**과 **가장 큰 값**을 `start`와 `end`로 설정
- **징검다리 문제 예시**:
    - 돌 사이의 최소 거리는 `1`. -> `start = 1;`
    - 최대 거리는 출발점에서 도착점까지의 거리(`distance`)입니다. -> `end = distance;`
### 1-1단계: answer 변수 설정 유무 확인
- 필요한 경우(파라메트릭 서치) : [[퍼즐 게임 챌린지]], [[징검다리]], [[입국 심사]]
- 필요 없는 경우(lower, upper bound) : [[순위 검색]]

### 2단계: 반복문 조건 설정 (`while (start <= end)`)
이 조건은 **`start`부터 `end`까지 모든 값을 후보로 탐색하겠다**는 의미입니다. `start`와 `end`가 같아지는 마지막 순간까지 검사해야 하므로 `<=`를 사용하는 것이 가장 안전하고 직관적입니다. 루프는 `start`가 `end`를 넘어서는 순간, 즉 탐색할 범위가 없어지면 종료됩니다.

### 3단계: 결정 함수 작성 (`isPossible(mid)`)
가장 중요한 단계입니다. `mid`값이 주어진 문제의 조건을 만족하는지 **"Yes" or "No"**로 판별하는 함수를 만듭니다.

- **징검다리 문제 예시**: `isPossible(mid)`
    - **질문**: "돌 사이의 최소 거리를 `mid`로 만들 수 있는가? (n개 이하의 돌만 제거해서)"
    - **답변**: 가능하다면 `true`, 불가능하다면 `false`를 반환합니다.

### **4-1단계: 범위 좁히기 (최댓값 찾기)**
**문제에서 "조건을 만족하는 값의 최댓값"을 요구할 때의 로직입니다. (e.g., 징검다리)
`isPossible(mid)`가 `true`라면, `mid`는 일단 답이 될 수 있습니다. 하지만 우리는 **더 큰 값**도 가능한지 확인해야 합니다.

```java
// 징검다리 문제 적용 예시 (최댓값 찾기)
if (isPossible(mid)) { // "mid라는 거리가 가능하다!"
    // 1. 현재 mid는 정답 후보이므로 저장한다.
    answer = mid;
    // 2. 더 큰 값도 가능한지 알아보기 위해 탐색 범위를 위로 올린다.
    start = mid + 1;
} else { // "mid라는 거리는 너무 커서 불가능하다!"
    // 1. 더 작은 값에서 정답을 찾아야 한다.
    end = mid - 1;
}
```

### **4-2단계: 범위 좁히기 (최솟값 찾기)**
문제에서 **"조건을 만족하는 값의 최솟값"**을 요구할 때의 로직입니다. (e.g., 블루레이 만들기, 공유기 설치)
`isPossible(mid)`가 `true`라면, `mid`는 답이 될 수 있습니다. 하지만 우리는 **더 작은 값**도 가능한지 확인해야 합니다.

```java
// 가상 문제 적용 예시 (최솟값 찾기)
if (isPossible(mid)) { // "mid라는 값으로 가능하다!"
    // 1. 현재 mid는 정답 후보이므로 저장한다.
    answer = mid;
    // 2. 더 작은 값도 가능한지 알아보기 위해 탐색 범위를 아래로 내린다.
    end = mid - 1;
} else { // "mid라는 값은 너무 작아서 불가능하다!"
    // 1. 더 큰 값으로 시도해야 한다.
    start = mid + 1;
}
```

## 별첨
answer 사용 유무에 따라 두 개의 템플릿으로 나뉘는 것을 하나로 통합할 수 있다고 함. 검토 필요
### 💡 하지만, 템플릿을 '하나로' 통일할 수도 있습니다!
여기서 헷갈림을 완전히 종결시킬 수 있는 팁을 하나 드릴게요. 사실 **두 번째 경우(배열 인덱스 찾기)에서도 지금의 `answer` 백업 템플릿을 똑같이 사용할 수 있습니다.** 템플릿을 두 개로 나눌 필요 없이 하나로 모든 것을 방어할 수 있다는 뜻입니다.

대표적으로 말씀하신 **'순위 검색'** 문제를 예로 들어볼게요. 이 문제의 핵심은 정렬된 점수 배열에서 `목표 점수(target) 이상을 받은 첫 번째 사람의 인덱스(Lower Bound)`를 찾는 것입니다.
이때도 똑같이 `answer`를 사용해서 이렇게 풀 수 있습니다.
```java
// 순위 검색 (Lower Bound) - target 점수 이상인 최초의 인덱스 찾기
int start = 0;
int end = list.size() - 1;

// target 이상인 값이 없을 경우를 대비해 기본값을 배열의 크기로 설정
int answer = list.size(); 

while (start <= end) {
    int mid = (start + end) / 2;
    
    // 1. 중간값이 목표 점수 이상인가? (조건 만족)
    if (list.get(mid) >= target) {
        answer = mid;    // 일단 정답 후보로 인덱스를 백업해 둠!
        end = mid - 1;   // 더 앞쪽(작은 인덱스)에도 목표 점수 이상인 사람이 있는지 탐색
    } else {
        start = mid + 1; // 점수가 모자라므로 더 뒤쪽(큰 인덱스)을 탐색
    }
}

// 전체 인원수에서 최초 인덱스를 빼면, target 점수 이상을 받은 사람의 수가 나옴
return list.size() - answer; 
```

### 왜 사람들은 인덱스를 찾을 때 answer를 안 쓸까요?
수학적으로 `while(start <= end)` 루프가 끝났을 때의 `start` 변수 값이, 방금 우리가 `answer`에 정성스럽게 백업해 둔 값과 **항상 100% 일치**하기 때문입니다. 그래서 코드를 한 줄이라도 줄이려고 `answer`를 빼버리고 마지막에 `return start;`를 던지는 것이죠.
하지만 앞서 말씀드렸듯, 사람이 실전의 압박감 속에서 코드를 짤 때는 "루프가 끝나면 start가 어디에 멈춰있지?"를 상상하는 것보다, **"조건에 맞으면 answer에 인덱스 복사해 둬야지"**라고 직관적으로 짜는 것이 훨씬 안전합니다.

---
### 🎯 결론 및 추천 전략
- **현재 방식 유지 (O):** 지금처럼 값 찾기(`answer` 사용)와 인덱스 찾기(`answer` 미사용)를 머릿속에서 명확히 구분해서 쓰고 계시고 그게 편하다면, 훌륭한 무기이므로 그대로 밀고 나가셔도 좋습니다.
- **완전한 단일화 (강력 추천):** 만약 "아, 인덱스 찾을 때 `start`를 리턴해야 하나 `end`를 리턴해야 하나 가끔 헷갈리는데?" 라는 생각이 1%라도 드신다면, 위 코드처럼 **모든 이진 탐색 문제에 무조건 `answer` 변수를 선언해서 백업하는 방식**으로 템플릿을 완전히 하나로 통합해 보세요.
    

어느 쪽을 선택하시든, 이진 탐색의 본질을 완벽하게 파악하고 계신 상태입니다. 혹시 '순위 검색' 문제에서 이 단일화된 템플릿을 어떻게 접목하면 좋을지 전체적인 로직 구조를 한 번 같이 짜볼까요?