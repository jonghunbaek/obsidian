# 1. MySQL의 전체 구조

![[RM 1장 - MySQL 아키텍처.png]]
MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특하다.
이러한 구조 덕분에 타 DBMS와는 다른 장, 단점을 가지게 된다.
**MySQL Server는 크게 MySQL Engine과 Storage Engine으로 구분**할 수 있다.

**MySQL Engine은 DBMS의 두뇌 역할을, Storage Engine은 손, 발의 역할**을 한다.
두뇌 역할의 MySQL Engine은 SQL 분석, 파싱, 최적화 등을 수행하고,
손, 발 역할의 Storage Engine은 저장 장치에 데이터를 저장, 수정, 조회 작업을 수행한다.

### 그렇다면 MySQL Engine과 Storage Engine은 어떻게 요청을 주고 받을까?

바로 핸들러 API를 사용한다.
Storage Engine에선 핸들러 API를 통해 핸들러 요청을 받게 된다.
![[RM 1장 - 핸들러 변수.png]]
value에 적힌 값은 작업 횟수를 나타낸다.

# 2. MySQL의 스레딩 구조
## 2-1. MySQL의 스레드
MySQL 서버는 프로세스 기반이 아닌 스레드 기반으로 작동한다.
그리고 MySQL 서버의 스레드는 크게 포그라운드와 백그라운드 스레드로 구분할 수 있다.
![[RM1장 - 백그라운드 스레드.png]]
pc에 설치된 MySQL이 5.7버전이라 책과는 다소 차이가 있다.

thread_id 88번인 **thread/sql/one_connection이 실제 사용자의 요청을 처리하는 스레드이다.**
MySQL설정에 따라 백그라운드 스레드의 개수는 변할 수 있다.
같은 이름의 스레드가 존재하는 이유는 여러 스레드가 동일 작업을 병렬로 처리하기 때문이다.

이 또한 MySQL 서버 설정에 따라 다르다.
>[!NOTE]
>전통적 스레드 모델 vs 스레드풀
**전통적 스레드 모델에선 커넥션과 포그라운드 스레드가 1:1 관계다. 스레드풀에선 커넥션과 포그라운드 스레드는 N:1 관계다.**
참고로 MySQL의 커뮤니티 에디션에선 스레드풀을 지원하지 않는다.

## 2-2. 포그라운드 스레드

포그라운드 스레드는 말 의미에서 유추할 수 있듯, 클라이언트(사용자)와 관련이 있다.
**포그라운드 스레드의 최소 갯수는 MySQL 서버에 접속한 클라이언트의 수와 같다.**
MySQL 서버에 두 클라이언트가 접속하면 one_connection이 두 개로 늘어난다.

클라이언트가 작업을 마치고 커넥션을 종료하면 커넥션을 담당하는 스레드는 다시 스레드 캐시로 돌아간다. 스레드 캐시는 ‘thread_cache_size’ 변수의 값을 설정해 크기를 조정할 수 있다. **이 때, 변수의 값은 정수 형태이고 캐싱될 수 있는 스레드의 개수를 의미한다.**
→ thread_cache_size개수만큼 스레드 캐시가 가득찼다면 이후 생성되는 스레드는 종료됨

### 스레드 캐시와 스레드 풀
둘 다 미리 생성해둔 스레드를 관리한다는 점은 같다.
**결정적인 차이는 스레드의 ‘생성 시점**’이다.
스레드 풀은 MySQL 서버가 시작할 때 스레드를 미리 생성해두는 것이고, 스레드 캐시는 요청이 들어와 생성된 스레드를 캐시에 저장하는 것이다.
그래서 이후 요청이 들어오면 스레드 캐시에서 먼저 생성된 스레드를 꺼내게 된다.

### 포그라운드 스레드의 역할 범위
스토리지 엔진의 종류에 따라 포그라운드 스레드의 역할 범위가 달라질 수 있다.
클라이언트의 요청에 따라 쿼리를 처리할 때,
**MyISAM의 경우 디스크의 쓰기 작업까지 포그라운드 스레드가 처리한다.**
**InnoDB의 경우 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리한다.** (나머지는 백그라운드 스레드가 처리)

## 2-3. 백그라운드 스레드
앞서 말했듯 MyISAM의 경우 디스크 쓰기 작업을 포그라운드 스레드가 처리한다.
하지만 **InnoDB에선 디스크 쓰기 작업을 포함해 다양한 작업을 백그라운드 스레드가 처리한다.**
### InnoDB의 백그라운드 스레드
- 인서트 버퍼 병합 스레드
- 로그 디스크 쓰기 스레드
- InnoDB 버퍼 풀 데이터 디스크 쓰기 스레드
- 버퍼에서 데이터 읽는 스레드
- 락, 데드락을 모니터링하는 스레드
이 중에서 **가장 중요한 스레드는 ‘쓰기 스레드’**이다.
‘innodb_write_io_threads’, ‘innodb_read_io_threads’ 변수 설정을 통해 쓰기, 읽기 스레드의 개수를 조절할 수 있다.

### InnoDB, MyISAM의 쓰기 작업
InnoDB는 대부분의 상용 DBMS처럼 쓰기 작업을 지연하여 일괄 처리한다.
**하지만 MyISAM은 포그라운드 스레드가 쓰기 작업을 처리하기 때문에 지연 처리를 할 수 없다.**
즉, InnoDB는 쓰기 작업을 백그라운드 스레드가 처리하기 때문에 사용자의 요청과는 별개로 작업을 수행할 수 있다. 이를 통해서 쓰기 지연을 가능하게 한다. 하지만 MyISAM은 포그라운드 스레드가 처리하기에 사용자의 요청과 별개로 작업을 수행할 수 없다.

# 3. MySQL 메모리 구조
![[RM 1장 - 메모리 구조.png]]
MySQL 서버의 메모리 구조는 크게 글로벌 영역, 세션(커넥션) 영역으로 구분할 수 있다.
**글로벌, 세션 영역을 구분 짓는 기준은 스레드의 메모리 영역 공유 여부다.**

### 글로벌 메모리
필요에 따라 다수의 메모리 공간을 할당 받을 수 있지만 이는 포그라운드 스레드의 개수(사용자의 커넥션 개수)와는 무관하다.
예를 들어 3개의 클라이언트가 MySQL의 서버에 접속해 3개의 커넥션이 생긴 경우 글로벌 메모리 영역 개수는 커넥션의 개수와 무관하다.

### 세션 메모리
로컬, 세션, 커넥션, 클라이언트 메모리 영역 등 다양한 이름으로 불리며
**포그라운드 스레드가 쿼리를 처리하는 데 사용되는 메모리 영역이다.**
클라이언트의 쿼리 처리에 사용되기 때문에 각 스레드 별로 독립적인 공간을 할당 받는다.
**글로벌 메모리와는 다르게 쿼리 처리에 필요한 경우에만 메모리 공간이 할당되고 필요하지 않은 경우는 할당조차 되지 않을 수도 있다.** 위 그림에서 볼 수 있는 모든 종류의 세션 메모리가 그렇진 않다. 대표적으로 조인, 정렬 버퍼가 이러하다.

# 4. 쿼리 실행 구조
![[RM 1장 - 쿼리 실행구조.png]]
### 쿼리 파서
요청으로 들어온 쿼리를 토큰으로 분리해 트리 형태의 구조로 만드는 과정이다.
기본적인 문법 오류는 이 단계에서 발견되어 사용자에게 전달된다.
>[!NOTE]
>MySQL의 토큰이란? MySQL이 인식할 수 있는 최소 단위의 어휘나 기호를 의미한다.

### 전처리기
쿼리 파서를 거친 후 만들어진 파서 트리를 기반으로 쿼리 문장의 구조적인 문제점을 검사한다.
각 토큰을 테이블, 컬럼 이름 또는 내장 함수 같은 개체와 매핑해 해당 객체의 존재 여부와 객체의 접근 권한 등을 확인하는 과정이다.

### 옵티마이저
**쿼리 문장을 최적의 조건(저렴한 비용, 빠른 속도)에서 처리할 수 있도록 결정하는 역할을 한다.**

### 쿼리 실행기
**옵티마이저와 스토리지 엔진 사이에서 중간 관리자 역할을 한다.**
옵티마이저에서 만들어진 쿼리 실행 계획을 토대로 핸들러 요청을 보내고 응답 받은 결과를 입력으로 또 다른 요청을 보내는 역할을 한다.

# 5. 기타 MySQL 구성 요소

Replication(복제), 쿼리 캐시, 스레드 풀, 트랜잭션 지원 메타데이터 등이 있다.
이 중 몇 가지만 알아보자.
### 쿼리 캐시
SQL의 실행 결과를 캐싱한다.
캐싱된 결과에 영향을 주는 데이터의 수정이 있을 경우 심각한 성능 저하, 버그를 야기할 수 있다.
8.0 버전부터 쿼리 캐시와 관련된 기능, 시스템 변수는 모두 제거되었다.
### Percona 스레드 풀
앞서 말했듯 커뮤니티 에디션에선 지원하지 않는다.
대신 커뮤니티 에디션에선 Percona Server의 스레드 풀을 플러그인 형태로 사용할 수 있다.
Percona의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성한다.

**스레드 그룹의 개수를 변경할 수 있지만 기본적으로 코어 개수와 맞추는 것이 프로세서 친화도를 높이는데 좋다.**

또한 선순위, 후순위 큐를 제공해 특정 트랜잭션, 쿼리의 우선순위를 지정해 처리할 수 있다.

>[!NOTE]
>**프로세서 친화도란?** 
>**특정 프로세스나 스레드가 특정 CPU 코어에서 실행되도록 바인딩(고정)하는 기술**이다. 이 기술을 통해 운영체제는 해당 프로세스나 스레드가 특정 코어에서만 실행되도록 강제할 수 있으며, 이는 성능 최적화와 관련된 여러 이점을 제공 
>- **캐시 성능 향상**(같은 코어를 사용하기 때문에 캐시 미스가 줄어듦) 
>- **컨텍스트 스위칭 비용 감소** 
>- **예측 가능성**(특정 코어에서만 실행되므로 프로세스, 스레드의 실행 시간 예측이 쉬움) 
>- **균등한 자원 활용**
### **Percona 스레드 풀 관련 설정 변수**
![[RM 1장 - Percona 스레드풀.png]]
- **thread_pool_size(기본 값 CPU 코어 개수)**
    - 스레드 그룹의 개수
- **thread_pool_oversubscribe(기본 값 3)**
    - 스레드 풀이 작업을 처리하는 경우 해당 변수의 개수만큼 작업을 받아들임
    - 값이 너무 크면 스케줄링해야 할 스레드가 많아져 스레드 풀이 비효율적으로 작동할 수 있음
- **thread_pool_stall_limit**
    - 스레드가 해당 변수에 정의된 시간(ms)이내에 작업을 처리하지 못하면 새로운 스레드를 생성해서 그룹에 추가
    - 해당 변수가 의미하는 바는 스레드 풀이 ‘정체 상태’임을 판단하기 위함. 즉, 해당 시간이 지나면 정체 상태라고 판단하고 스레드를 생성.
    - **만약 모든 스레드가 작업 중이라면 해당 시간이 지난 뒤 ‘정체 상태’라고 판단해 작업을 독점하고 있는 스레드를 교체. 바꿔말하면 이 시간 동안은 스레드가 하나의 작업을 독점할 수 있음**
- **thread_pool_max_threads**
    - 스레드 풀의 최대 스레드 개수

### 트랜잭션 지원 메타데이터
MySQL 5.7버전 까지는 파일(.FRM, .TRN 등)기반으로 메타데이터를 저장했다.
파일 기반의 저장은 트랜잭션을 지원하지 않기에 서버가 비정상 종료되면 일관되지 않은 상태로 저장되는 문제점이 존재했다.(보통 이 현상을 DB나 테이블이 깨졌다고 표현)
8.0버전부터 이 문제를 해결하기 위해 **메타데이터를 InnoDB의 테이블에 저장하도록 변경**했다.
더불어 **시스템 테이블 또한 InnoDB 엔진을 사용하도록 변경**하고, 시스템 테이블, 데이터 딕셔너리 정보를 모두 모아 mysql DB에 저장한다.(mysql.ibd라는 이름의 테이블 스페이스 저장됨)
이러한 변경을 통해 **스키마 변경 작업 중 서버가 비정상 종료되도 스키마 변경이 원자성을 갖도록 만들었다.**
InnoDB를 제외한 다른 스토리지 엔진을 사용할 경우 SDI(FRM과 같은 역할)라는 형식의 파일에 메타 데이터를 저장한다.

# 6. MySQL 확장(플러그인, 컴포넌트)
### 플러그인
MySQL에선 플러그인 모델을 제공해 필요한 기능을 외부에서 끌어다 쓸 수 있다.
이러한 플러그인 모델엔 스토리지 엔진 뿐만 아니라 인증/인가, 검색어 파서 등 다양한 형태로 존재한다.
이 중 스토리지 엔진 플러그인에 대해 자세히 알아보자.
앞서 알아 봤듯 MySQL의 구조는 크게 MySQL엔진과 스토리지 엔진 두 개로 구분할 수 있다.
또한 스토리지 엔진의 핸들러 API로 요청을 보내 두 엔진이 정보를 주고 받는다는 것도 알아봤다.
그렇기에 **적절한 핸들러 API만 구현된다면 어떠한 스토리지 엔진을 사용해도 상관 없다**.
MySQL 서버가 가지고 있는 스토리지 엔진, 플러그인에 대한 정보가 궁금하다면 아래 명령어를 입력해보자.
```sql
SHOW ENGINES;
SHOW PLUGINS;
```
### 컴포넌트
플러그인에 대한 설명을 들어보면 MySQL에서 플러그인은 마법의 도구와 같다.
하지만 이러한 플러그인에는 몇몇 단점이 존재하기에 컴포넌트가 해당 역할을 대체하기 시작했다.(8.0버전부터)

그렇다면 플러그인은 어떤 단점을 가지고 있을까?
- 플러그인은 플러그인끼리 통신할 수 없다.(MySQL서버만 통신)
- 플러그인은 MySQL 서버의 변수, 함수를 직접 호출하기에 안전하지 않음(캡슐화가 안됨)
- 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다.