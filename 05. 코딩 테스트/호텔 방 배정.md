---
플랫폼: 프로그래머스
문제 이름: 호텔 방 배정
알고리즘: 유니온파인드,
tags:
  - 유니온파인드
date: 2025-09-17
aliases:
  - 유니온파인드
복습 풀이: 250917(X)
---
# 1차 풀이
```java
import java.util.*;
// 1. 방번호를 키로 Room을 값으로 Map 생성
    // 2. 키가 존재하지 않는다면 방 선택
    // 3. 키가 존재한다면 더 큰 번호의 방을 찾아야 함.
    //  3-1. 방번호를 합칠 땐, 가장 큰 숫자를 부모로 변경해줌
    //  3-2. 가장 큰 숫자가 부모로 변경될 땐, Map애 그 다음 숫자가 키로 존재하는지 확인하고 존재한다면 해당 방과 합침
class Solution {
    
    public long[] solution(long k, long[] room_number) {
        List<Long> results = new ArrayList<>();
        Map<Long, Room> roomByNo = new HashMap<>();
        for (long no : room_number) {
            long next = no;
            if (roomByNo.containsKey(no)) { // 방이 이미 선택됐다면 숫자가 더 큰 방번호 선택
                next = roomByNo.get(no).rootNo() + 1;
            }

            Room room = new Room(next);
            roomByNo.put(next, room);
            if (roomByNo.containsKey(next - 1)) {
                room.merge(roomByNo.get(next - 1));
            }

            if (roomByNo.containsKey(next + 1)) {
                room.merge(roomByNo.get(next + 1));
            }

            results.add(next);
        }

        return results.stream()
                .mapToLong(Long::longValue)
                .toArray();
    }

    static class Room {
        int depth;
        long no;
        Room parent;

        public Room(long no) {
            this.no = no;
            this.depth = 1;
            this.parent = null;
        }

        public long rootNo() {
            return root().no;
        }

        public Room root() {
            if (parent == null) {
                return this;
            }

            return parent.root();
        }

        public void merge(Room other) {
            if (root() == other.root()) {
                return;
            }

            Room room1 = root();
            Room room2 = other.root();

            if (room1.depth > room2.depth) {
                room2.parent = room1;
            } else if (room1.depth < room2.depth) {
                room1.parent = room2;
            } else {
                room2.parent = room1;
                room1.depth++;
            }

            room1.no = room2.no = Math.max(room1.no, room2.no);
        }
    }
}
```
전체적인 접근은 괜찮았지만 구현을 못해 틀림
유니온 파인드에 익숙하지 않은 것도 한 몫함

아래처럼 간단하게도 풀이 가능함(유니온 파인드가 아닌 일종의 DP - 메모이제이션을 활용한 재귀)
```java
import java.util.*;

class Solution {
    Map<Long, Long> map = new HashMap<>();

    public long[] solution(long k, long[] room_number) {
        int n = room_number.length;
        long[] answer = new long[n];

        for (int i = 0; i < n; i++) {
            answer[i] = findEmptyRoom(room_number[i]);
        }

        return answer;
    }
    
    private long findEmptyRoom(long room) {
        if (!map.containsKey(room)) {
            map.put(room, room + 1);
            return room;
        }
        
        long nextRoom = map.get(room);
        long emptyRoom = findEmptyRoom(nextRoom);
        map.put(room, emptyRoom);
        return emptyRoom;
    }
}
```