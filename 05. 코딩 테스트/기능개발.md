---
í”Œë«í¼: í”„ë¡œê·¸ë˜ë¨¸ìŠ¤
ë¬¸ì œ ì´ë¦„: ê¸°ëŠ¥ê°œë°œ
ì•Œê³ ë¦¬ì¦˜: í
tags:
  - í
date: 2025-09-02
aliases:
  - í
ë³µìŠµ í’€ì´: 250902(X), 250907(O), 250913(O), 250920(O), 251104(O), 251111(O)
---
# 1ì°¨ í’€ì´
### ìµœì´ˆ í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Double> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer(Math.ceil(((double) 100 - progresses[i]) / speeds[i]));
        }

        List<Integer> results = new ArrayList<>();
        int count = 0;
        int previous = Integer.MAX_VALUE;
        while (!q.isEmpty()) {
            if (previous >= q.peek()) {
                count++;
                previous = q.poll().intValue();
                continue;
            }

            results.add(count);
            count = 0;
            previous = Integer.MAX_VALUE;
        }

        results.add(count);

        return results.stream()
                .mapToInt(Integer::intValue)
                .toArray();
    }
}
```
ì ‘ê·¼ ë°©í–¥ì€ ì¢‹ì•˜ìœ¼ë‚˜ ì„¸ë¶€ì ì¸ êµ¬í˜„ì´ ì˜ëª»ë¨
ì´ìœ ëŠ” ì•„ë˜ì™€ ê°™ìŒ
```text
ë‹¤ìŒê³¼ ê°™ì´ ê° ê¸°ëŠ¥ì˜ ë°°í¬ê¹Œì§€ ë‚¨ì€ ì¼ìˆ˜ê°€ `[10, 5, 8]`ì¼ ê²½ìš°ë¥¼ ìƒê°í•´ ë³´ê² ìŠµë‹ˆë‹¤.
- ì˜¬ë°”ë¥¸ ë¡œì§:
    1. ì²« ë²ˆì§¸ ê¸°ëŠ¥ì´ **10ì¼** ê±¸ë¦¬ë¯€ë¡œ ê¸°ì¤€ì¼ì€ `10`ì¼ì´ ë©ë‹ˆë‹¤.
    2. ë‘ ë²ˆì§¸ ê¸°ëŠ¥ì€ 5ì¼ ê±¸ë¦½ë‹ˆë‹¤. (`5 <= 10` ì´ë¯€ë¡œ í•¨ê»˜ ë°°í¬)
    3. ì„¸ ë²ˆì§¸ ê¸°ëŠ¥ì€ 8ì¼ ê±¸ë¦½ë‹ˆë‹¤. (`8 <= 10` ì´ë¯€ë¡œ í•¨ê»˜ ë°°í¬)
    4. ê²°ê³¼: `[3]` (ì„¸ ê¸°ëŠ¥ ëª¨ë‘ í•œ ë²ˆì— ë°°í¬)
        
- í˜„ì¬ ì½”ë“œì˜ ë¡œì§:
    1. `previous`ëŠ” ì´ˆê¹ƒê°’(`Integer.MAX_VALUE`), íì˜ ì²« ê°’ì€ `10`ì…ë‹ˆë‹¤. `MAX_VALUE >= 10`ì´ë¯€ë¡œ ë°°í¬ ë¬¶ìŒì— í¬í•¨ì‹œí‚µë‹ˆë‹¤.
        - `count`ëŠ” 1ì´ ë©ë‹ˆë‹¤.
        - `previous`ëŠ” **10**ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤.
    2. `previous`ëŠ” `10`, íì˜ ë‹¤ìŒ ê°’ì€ `5`ì…ë‹ˆë‹¤. `10 >= 5`ì´ë¯€ë¡œ ë°°í¬ ë¬¶ìŒì— í¬í•¨ì‹œí‚µë‹ˆë‹¤.
        - `count`ëŠ” 2ê°€ ë©ë‹ˆë‹¤.
        - `previous`ëŠ” **5**ë¡œ ì—…ë°ì´íŠ¸ë©ë‹ˆë‹¤. **<-- ğŸš¨ ë¬¸ì œ ë°œìƒ ì§€ì **
    3. `previous`ëŠ” `5`, íì˜ ë‹¤ìŒ ê°’ì€ `8`ì…ë‹ˆë‹¤. `5 >= 8`ì€ ê±°ì§“ì´ë¯€ë¡œ ë°°í¬ê°€ ì—¬ê¸°ì„œ ëŠê¹ë‹ˆë‹¤.
        - ê²°ê³¼ ë¦¬ìŠ¤íŠ¸ì— `count` ê°’ì¸ `2`ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
    4. ì´í›„ ë‚¨ì€ `8`ì´ ìƒˆë¡œìš´ ë°°í¬ ë¬¶ìŒìœ¼ë¡œ ì²˜ë¦¬ë˜ì–´ ê²°ê³¼ì— `1`ì´ ì¶”ê°€ë©ë‹ˆë‹¤.
    5. ìµœì¢… ê²°ê³¼: `[2, 1]` (ì˜ëª»ëœ ê²°ê³¼)
        
ì´ì²˜ëŸ¼ ê¸°ì¤€ì´ ë˜ëŠ” `previous` ê°’ì„ ë¬¶ìŒ ë‚´ì—ì„œ ë” ì‘ì€ ê°’ìœ¼ë¡œ ê°±ì‹ í•´ë²„ë¦¬ê¸° ë•Œë¬¸ì—, ì›ë˜ í•¨ê»˜ ë°°í¬ë˜ì–´ì•¼ í•  ê¸°ëŠ¥(`8`ì¼)ì´ ëˆ„ë½ë˜ëŠ” ë¬¸ì œê°€ ë°œìƒí•©ë‹ˆë‹¤.
```

### ì˜¬ë°”ë¥¸ í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }

        List<Integer> results = new ArrayList<>();
        while (!q.isEmpty()) {
            int deployDay = q.poll();
            int count = 1;

            while (!q.isEmpty() && q.peek() <= deployDay) {
                q.poll();
                count++;
            }
            results.add(count);
        }

        return results.stream()
                .mapToInt(Integer::intValue)
                .toArray();
    }
}
```

# 2ì°¨ í’€ì´
```java
class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        int[] completions = new int[progresses.length];
        for (int i = 0; i < progresses.length; i++) {
            completions[i] = (int) Math.ceil((100.0 - progresses[i]) / speeds[i]);
        }
        
        Queue<Integer> q = new LinkedList<>();
        List<Integer> results = new ArrayList<>();
        int count = 0;
        for (int i = 0; i < completions.length; i++) {
            if (!q.isEmpty() && q.peek() < completions[i]) {
                int limit = q.peek();
                while (!q.isEmpty() && completions[i] > limit) {
                    q.poll();
                    count++;
                }
                
                results.add(count);
                count = 0;
            }
            
            q.add(completions[i]);
        }
        
        while (!q.isEmpty()) {
            q.poll();
            count++;
        }
        
        if (count != 0) {
            results.add(count);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
ì§€ë‚œ í’€ì´ ë°©ë²•ì„ í™•ì¸í•˜ê³ , ì¡°ê¸ˆ ë” ê°„ë‹¨í•˜ê³  ê¹”ë”í•˜ê²Œ í’€ì–´ë³´ê¸°

# 3ì°¨ í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> tasks = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            tasks.add((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }
        
        List<Integer> results = new ArrayList<>();
        while (!tasks.isEmpty()) {
            int count = 1;
            int current = tasks.poll();
            while (!tasks.isEmpty() && tasks.peek() <= current) {
                tasks.poll();
                count++;
            }
            
            results.add(count);
            count = 1;
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
ìŠ¤íƒ/í ê´€ë ¨ ë¬¸ì œëŠ” ì—¬ëŸ¬ë²ˆ í’€ì–´ë„ ë§¤ë²ˆ ë‚¯ì„¤ìŒ
ê·¼ë° ë˜ í‘¸ëŠ”ê±´ ì˜ í’€ê²Œ ë¨
êµ¬í˜„ ê³¼ì •ì„ ì²œì²œíˆ ê³±ì”¹ì–´ ë³´ë©° í•œ ë²ˆ ë” í’€ì–´ ë³¼ê²ƒ

# 4ì°¨ í’€ì´
```java
import java.util.*;

// 1. ì‘ì—… ì¼ìˆ˜ë¥¼ ê³„ì‚°í•˜ì—¬ íì— ë„£ê¸°
// 2. íê°€ ë¹„ì–´ìˆì§€ ì•Šê³  íì˜ ë‹¤ìŒ ê°’ì´ í˜„ì¬ ê°’ë³´ë‹¤ ì‘ë‹¤ë©´ count++
// 3. í° ê°’ì´ ë‚˜ì˜¤ë©´ ê²°ê³¼ ê°’ì„ Listì— ë„£ê³  countì´ˆê¸°í™”
class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            q.offer((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }
        
        int count = 1;
        List<Integer> results = new ArrayList<>();
        while (!q.isEmpty()) {
            int current = q.poll();
            while (!q.isEmpty() && q.peek() <= current) {
                q.poll();
                count++;
            }
            
            results.add(count);
            count = 1;
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```

# 5ì°¨ í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        List<Integer> results = new ArrayList<>();
        List<Integer> jobs = new ArrayList<>();
        for (int i = 0; i < progresses.length; i++) {
            jobs.add((int) (Math.ceil((100.0 - progresses[i]) / speeds[i])));
        }
        
        Stack<Integer> stack = new Stack<>();
        int count = 1;
        for (int i = 1; i < jobs.size(); i++) {
            while (i < jobs.size() && !stack.isEmpty() && stack.peek() >= jobs.get(i)) {
                count++;
                i++;
            }
            
            results.add(count);
            stack.push(jobs.get(i));
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```

ìœ„ í’€ì´ëŠ” í‹€ë¦° í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        List<Integer> results = new ArrayList<>();
        Queue<Integer> jobs = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            jobs.offer((int) (Math.ceil((100.0 - progresses[i]) / speeds[i])));
        }
        
        // 7, 3, 9
        // 5, 10, 1, 1, 20, 1
        Stack<Integer> stack = new Stack<>();
        int count = 1;
        while(!jobs.isEmpty()) {
            int current = jobs.poll();
            stack.push(current);
            while (!stack.isEmpty() && !jobs.isEmpty() && stack.peek() >= jobs.peek()) {
                jobs.poll();
                count++;
            }
            
            stack.pop();
            results.add(count);
            count = 1;
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```
ì–´ì°Œì €ì°Œ ë§ì·„ìœ¼ë‚˜ ì™„ì „ ì–´ê±°ì§€ë¡œ ë§ì¶˜ ëŠë‚Œ
ì´ì „ í’€ì´ë¥¼ ë³´ë‹ˆ êµ³ì´ Stackì„ ì•ˆì¨ë„ ëìŒ.
ì´ì „ì— í’€ì—ˆë˜ ê²½í—˜ë“¤ì´ ì˜¤íˆë ¤ ë…ì´ëœ ëŠë‚Œ
- ë¬´ì¡°ê±´ Stackì„ ì‚¬ìš©í•´ì•¼ë§Œ í•œë‹¤ê³  ì°©ê°í•¨

ë˜í•œ ë‹¤ìŒ ë¶€ë¶„ì—ì„œë„ ì‹¤ìˆ˜ê°€ ìˆì—ˆìŒ
- Math.ceil()í•  ë•Œ, int íƒ€ì…ì´ë©´ ì´ë¯¸ ë²„ë¦¼ì´ ë°œìƒí•œ ìƒíƒœì—ì„œ ìˆ˜í–‰í•˜ê²Œë¨

# 6ì°¨ í’€ì´
```java
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        Queue<Integer> tasks = new LinkedList<>();
        for (int i = 0; i < progresses.length; i++) {
            tasks.offer((int) Math.ceil((100.0 - progresses[i]) / speeds[i]));
        }
        
        List<Integer> results = new ArrayList<>();
        while(!tasks.isEmpty()) {
            int deploy = tasks.poll();
            int count = 1;
            while(!tasks.isEmpty() && tasks.peek() <= deploy) {
                count++;
                tasks.poll();
            }
            
            results.add(count);
        }
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .toArray();
    }
}
```