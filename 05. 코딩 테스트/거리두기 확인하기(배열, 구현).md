---
플랫폼: 프로그래머스
문제 이름: 거리두기 확인하기
알고리즘: 배열
tags:
  - 배열
  - 구현
date: 2025-07-14
aliases:
  - 배열
복습 풀이: 250714(X), 250721(O), 251013(X), 251021(O)
---
# 1차 풀이
```java
class Solution {
    private static final int[] dx = {1, 0, -1, 0};
    private static final int[] dy = {0, -1, 0, 1};
    
    public int[] solution(String[][] places) {
        char[][][] maps  = new char[5][5][5];
        for (int i = 0; i < places.length; i++) {
            for (int j = 0; j < places[i].length; j++) {
                char[] chars = places[i][j].toCharArray();
                maps[i][j] = chars;
            }
        }

        int[] result = new int[5];
        for (int i = 0; i < maps.length; i++) {
            boolean isUnsafe = isUnsafe(maps[i]);
            if (isUnsafe) {
                result[i] = 0;
            } else {
                result[i] = 1;
            }
        }

        return result;
    }

    private boolean isUnsafe(char[][] map) {
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                if (map[i][j] != 'P') {
                    continue;
                }

                boolean isExists = isExistsNearByVolunteer(map, i, j);

                if (isExists) {
                    return true;
                }
            }
        }

        return false;
    }

    private boolean isExistsNearByVolunteer(char[][] map, int y, int x) {
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[i].length || map[ny][nx] == 'X') {
                continue;
            }

            if (map[ny][nx] == 'P') {
                return true;
            }

            if (oneMoreCheckNearByVolunteer(map, ny, nx, (i + 2) % 4)) {
                return true;
            }
        }

        return false;
    }

    private boolean oneMoreCheckNearByVolunteer(char[][] map, int y, int x, int direction) {
        for (int i = 0; i < 4; i++) {
            if (i == direction) {
                continue;
            }

            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx < 0 || nx >= map.length || ny < 0 || ny >= map[i].length || map[ny][nx] == 'X') {
                continue;
            }

            if (map[ny][nx] == 'P') {
                return true;
            }
        }

        return false;
    }
}
```

풀이 방식은 dfs 접근과 유사하지만 뎁스를 계속 늘릴 필요가 없음
맨해튼 거리가 2이하인 케이스만 검사하면 되기 때문
단순 구현에 가깝지만 의외로 까다로운 조건들이 존재해 여러번 풀어보는 편이 좋을듯

# 2차 풀이
```java
// 응시자 == P, 빈 테이블 == O, 파티션 == X
// 대기실별로 모두 거리두기를 지키면 1, 지키지 않으면 0을 배열로 반환(5 고정)
class Solution {
    
    private static final int[] dx = {1, 0, -1, 0};
    private static final int[] dy = {0, 1, 0, -1};
    
    public int[] solution(String[][] places) {
        int[] result = new int[5];
        for (int i = 0; i < places.length; i++) { // 전체 대기실별 순회
            result[i] = isSafeZone(places[i]) ? 1 : 0;
        }
        
        return result;
    }
    
    private boolean isSafeZone(String[] place) {
        for (int i = 0; i < place.length; i++) {
            for (int j = 0; j < place[i].length(); j++) { 
                if (place[i].charAt(j) != 'P') { // 응시자가 아니면 건너뜀
                    continue;
                }

                for (int d = 0; d < dx.length; d++) {
                    int nx = j + dx[d];
                    int ny = i + dy[d];

                    if (isOutOfBoundary(nx, ny, place)) {
                        continue;
                    }

                    if (place[ny].charAt(nx) == 'P') {
                        return false;
                    }
                    
                    if (isVolunteerInManhattan(nx, ny, place, (d + 2) % 4)) {
                        return false;
                    }
                }
            }                
        }
        
        return true;
    }
    
    private boolean isVolunteerInManhattan(int x, int y, String[] place, int from) {
        for (int d = 0; d < dx.length; d++) {
            if (d == from) {
                continue;
            }
            
            int nx = x + dx[d];
            int ny = y + dy[d];
            
            if (isOutOfBoundary(nx, ny, place)) {
                continue;
            }
            
            if (place[ny].charAt(nx) == 'P') {
                return true;
            }
        }
        
        return false;
    }
    
    private boolean isOutOfBoundary(int x, int y, String[] place) {
        return x >= 5 || x < 0 || y >= 5 || y < 0 || place[y].charAt(x) == 'X';
    }
}
```

두 번째 풀이라 훨씬 매끄럽게 풀었음
하지만 실패에 대한 원인 분석이 쉽지 않았음
isVolunteerInManhattan()에서 ny 값을 초기화할 때, dy[y]로 작성해서 디버깅이 쉽지 않았음
매우 간단한 오류지만 찾기가 쉽지 않은데 이런 경우에 대해 침착하게 접근하는 방법을 연구해야 함

# 3차 풀이
```java
class Solution {
    private static int[] dx = new int[] {1, -1, 0, 0};
    private static int[] dy = new int[] {0, 0, 1, -1};
    
    public int[] solution(String[][] places) {
        int[] answer = new int[places.length];
        for (int i = 0; i < places.length; i++) {
            answer[i] = findManhattanDistance(toCharPlace(places[i]));
        }
        
        return answer;
    }
    
    private char[][] toCharPlace(String[] place) {
        char[][] charPlace = new char[place.length][place[0].length()];
        for (int i = 0; i < place.length; i++) {
            charPlace[i] = place[i].toCharArray();
        }
        
        return charPlace;
    }
    
    private int findManhattanDistance(char[][] place) {
        for (int y = 0; y < place.length; y++) {
            for (int x = 0; x < place[y].length; x++) {
                if (place[y][x] == 'O' || place[y][x] == 'X') continue;
                
                for (int i = 0; i < 4; i++) {
                    int nx = dx[i] + x;
                    int ny = dy[i] + y;
                    
                    if (isOutOfRange(nx, ny, place)) continue;
                    if (place[ny][nx] == 'P') return 0;
                    if (!hasManhattanDistance(nx, ny, x, y, place)) return 0;
                }
            }
        }
        
        return 1;
    }
    
    private boolean hasManhattanDistance(int nx, int ny, int x, int y, char[][] place) {
        for (int i = 0; i < 4; i++) {
            int nnx = nx + dx[i];
            int nny = ny + dy[i];
            
            if (isOutOfRange(nnx, nny, place)) continue;
            if (nnx == x && nny == y) continue;
            if (place[nny][nnx] == 'P') return false;
        }
        
        return true;
    }
    
    private boolean isOutOfRange(int x, int y, char[][] place) {
        return x >= place[0].length || y >= place.length || x < 0 || y < 0 || place[y][x] == 'X';
    }
}
```
역시나 카카오 문제. 오랜만에 풀려고 하니 그냥 틀려버렸다.
오른쪽과 아래만 탐색하면 될거라고 잔머리 굴리다가 틀림.
문제를 천천히 곱씹으며 풀어보기

# 4차 풀이
```java
class Solution {
    private int[] dx = new int[] {1, -1, 0, 0};
    private int[] dy = new int[] {0, 0, 1, -1};
    
    // 0 1
    // 1 0
    // 2 3
    // 3 2
    public int[] solution(String[][] places) {
        int[] results = new int[places.length];
        for (int i = 0; i < places.length; i++) {
            char[][] map = toCharMap(places[i]);
            results[i] = hasManhattanDistance(map);
        }
        
        return results;
    }
    
    private char[][] toCharMap(String[] place) {
        char[][] map = new char[place.length][place[0].length()];
        for (int i = 0; i < place.length; i++) {
            map[i] = place[i].toCharArray();
        }
        
        return map;
    }
    
    private int hasManhattanDistance(char[][] map) {
        for (int y = 0; y < map.length; y++) {
            for (int x = 0; x < map[y].length; x++) {
                if (map[y][x] != 'P') continue;
                
                for (int d = 0; d < 4; d++) {
                    int nx = dx[d] + x;
                    int ny = dy[d] + y;
                    
                    if (isOutOfRange(nx, ny, map) || map[ny][nx] == 'X') continue;
                    if (map[ny][nx] == 'P') return 0;
                    if (hasPInManhattanDistance(nx, ny, map, d % 2 == 0 ? d + 1 : d - 1)) return 0;
                }
            }
        }
        
        return 1;
    }
    
    private boolean hasPInManhattanDistance(int x, int y, char[][] map, int from) {
        for (int d = 0; d < 4; d++) {
            if (d == from) continue;
            int nx = dx[d] + x;
            int ny = dy[d] + y;
            
            if (isOutOfRange(nx, ny, map)) continue;
            if (map[ny][nx] == 'P') return true;
        }
        
        return false;
    }

    
    private boolean isOutOfRange(int x, int y, char[][] map) {
        return x < 0 || x >= map[0].length || y < 0 || y >= map.length;
    }
}
```
뭔가 어색어색하게 풀음
다른 풀이도 찾아볼 것