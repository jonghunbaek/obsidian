레디스의 데이터는 기본적으로 메모리에 저장되기에 여러 장애 상황이 발생해 서버가 다운되면 데이터가 유실될 가능성이 존재한다.
이러한 문제를 해결하기 위해 레디스에선 두 가지 백업 방식을 제공한다.
- **RDB**
	- 일정 시점에 메모리에 저장된 데이터 전체를 저장(스냅숏 방식)
	- 바이너리 형태로 저장
- **AOF**
	- 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록,  복원 시에는 파일을 다시 읽어가며 데이터 셋 구성
	- RESP 형태로 저장

>[!RESP(REdis Serialization Protocol)]
>
>Redis 클라이언트와 서버가 통신할 때 사용되는 프로토콜로 단순하고 빠른 파싱이 장점이다. 또한 사람이 읽을 수 있는 형태를 지향한다.
>**타입 구분 기호 + 요소에 대한 정보 + 줄바꿈 + 실제 데이터와 같은 구조**로 이뤄진다.
>타입 구분 기호는 총 5개(+, -, :, $, \*)로 각각 단순 문자열, 에러, 정수, 벌크 문자열, 배열을 뜻한다.
>구조가 단순하지만 명령어와 데이터의 분리가 명확해 파싱이 빠르다.
>또한 문자열의 길이를 명시하기에 NULL, \0과 같은 문자가 들어와도 잘못 읽지 않는다.
>**즉, prefixed-length를 활용해 바이너리 안전하게 데이터를 읽는다.**
>RESP 또한 TCP 기반에서 작동하며, HTTP와 같이 애플리케이션 계층에서 이뤄진다.

두 백업 방식을 동시에 사용하는 것이 가능하며, 데이터의 안정성을 위해서 함께 사용되는 것이 권장된다.
레디스에서 해당 방식들을 이용해 복구하는 것은 레디스 서버가 재시작될 때뿐이며, 실행 도중에 복원할 수 있는 방법은 없다.

# 1. RDB 백업 방식
RDB 방식으로 백업 파일을 생성하는 방법은 다음과 같다.
- **특정 조건을 활용해 자동 저장**
- **사용자가 원하는 시점에 커맨드를 활용해 수동 저장**
- **복제 기능 활용**

## 1.1 특정 조건에 자동으로 RDB 파일 생성
Redis의 설정 파일을 수정하여 자동 생성
```text
save <기간(초)> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>   // 기본 값은 dump.rdb
dir <RDB 파일이 저장될 경로> // 파일 저장 경로 지정

save 900 1    // 900초 동안 1개 이상의 키가 변경된 경우
save ""       // 비활성화
```

>[!주의점]
> save 60 10과 같은 설정을 적용했다고 가정
> 1. 11개의 키가 변경되어 RDB 파일이 생성 완료되고 나면 카운팅은 초기화 됨
> 2. 시간은 초기화되지 않음
> 3. RDB 파일이 생성되는 도중에 키 11개가 또 변경된다면 추가적으로 RDB 파일을 만드는 것이 아니라 무시됨

| 시간  | 변경 수               | 설명                         |
| --- | ------------------ | -------------------------- |
| 0초  | 11개 변경 → RDB 저장 시작 | 백그라운드로 RDB 저장 진행중          |
| 10초 | 5개 추가 변경           | 조건 충족하지만 **이미 저장 중**이므로 무시 |
| 30초 | 10개 추가 변경          | 역시 무시                      |
| 50초 | RDB 저장 완료          |                            |
| 70초 | 또 변경 감지            | 새롭게 RDB 저장 가능해짐            |

### 실행 중인 레디스 인스턴스에 설정을 적용하려면?
redis-cli에 직접 아래와 같은 명령어를 입력한다.
```
> CONFIG SET save ""
OK

> CONFIG REWRITE
OK
```

## 1.2 수동으로 RDB 파일 생성
아래와 같은 방식으로 사용자가 원하는 시점에 RDB 파일을 생성할 수 있다.
- **SAVE**
	- 동기 방식으로 파일 저장
	- 때문에 파일 생성 완료까지 모든 클라이언트의 명령이 차단됨
- **BGSAVE**
	- 백그라운드에서 파일 생성
	- fork를 호출해 자식 프로세스가 파일 생성
	- SCHEDULE 옵션을 함께 사용할 수 있음
RDB 파일의 정상 저장 여부는 LASTSAVE 커맨드로 확인할 수 있음

## 1.3 복제를 활용한 RDB 파일 자동 생성
**REPLICAOF 명령어를 이용해 복제를 요청하면 마스터 노드에서 RDB 파일을 생성해 복제본에게 전달**한다.
네트워크 장애와 같은 이슈가 발생해 순단 현상이 생기는 경우에도 자동으로 복제본에게 RDB 파일을 전달한다. 

# 2. AOF 백업 방식
설정 파일에서 아래와 같은 옵션을 사용해 AOF 파일에 주기적으로 데이터를 저장할 수 있다.
```text
appendonly yes                  // aof 사용 여부
appendfilename "appendonly.aof" // 저장될 파일 이름
appenddirname "appendonlydir"   // 파일 저장 경로
```

AOF 방식에서 저장되는 명령어와 사용자가 직접 입력한 명령어가 반드시 일치하지는 않는다. 
AOF 파일상에는 **메모리의 데이터가 변경되는 명령어만 기록되기 때문에 그 외 부가적인 작업들은 저장되지 않는다.**
→ ex) BRPOP과 같은 블로킹 기능

하지만 메모리가 변경될 때마다 명령어가 저장된다면 INCR 명령어를 사용해 값을 1씩 1000번 증가시키면 1000번의 명령어가 모두 저장되게 된다.
이러한 단점을 해결하기 위해 파일을 재구성하는 방법이 필요하다.
### AOF 파일 재구성 
AOF 파일 재구성이란 압축과도 같으며 7버전 전/후로 다른 방식이 사용된다.
#### 7버전 이전
