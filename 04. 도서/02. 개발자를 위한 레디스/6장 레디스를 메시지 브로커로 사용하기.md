# 1. 메시지 브로커
메시지 브로커의 형태는 다음과 같이 나눌 수 있다.
- **메시징 큐**(1:1)
- **이벤트 스트림**(n:n)

메시징 큐와 이벤트 스트림은 비슷하지만 몇 가지 차이점이 존재한다.
- **데이터 생성자/수신자**
	- 메시징 큐에서 데이터를 생성하는 쪽을 'Producer', 데이터를 수신하는 쪽을 'Consumer'라고 한다. 
	- 이벤트 스트림에선 데이터를 생성하는 쪽을 'Publisher', 데이터를 수신하는 쪽을 'Subscriber'라고 한다.
- **방향성**
	- 메시징 큐에선 소비자의 큐로 데이터를 직접 푸시(소비자의 큐가 여러개라면 여러번 푸시)
	- 이벤트 스트림에선 스트림 저장소에 메시지를 푸시, 소비자는 해당 저장소에서 메시지를 풀
- **영속성**
	- 메시징 큐에선 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제
	- 이벤트 스트림에선 소비자가 읽어도 저장소 설정에 따라 삭제 여부/기간이 달라짐

# 2. 레디스의 메시지 브로커
레디스가 제공하는 pub/sub을 사용해 메시지 브로커를 구현할 수 있다.
### 레디스 pub/sub
![[Redis - pub,sub.png|500]] 출처 - https://oliveyoung.tech/2023-08-07/async-process-of-coupon-issuance-using-redis/
레디스의 pub/sub은 일회성이다. 
즉, 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다. 
그러므로 **데이터 정합성이 중요한 프로젝트에선 적합하지 않다**.

레디스 노드에 접근할 수 있는 모든 클라이언트는 publisher/subscriber가 될 수 있다.
또한 매우 가볍기 때문에 **최소한의 메시지 전달 기능만 제공**한다.
그러므로 **어떤 구독자가 메시지를 읽어가는지, 정상적으로 수신 되었는 지 확인할 수 없다.**
또한 메시지 발행 정보와 같은 **메타 데이터도 확인할 수 없다**.

한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지의 통로 역할만 한다. 
