---
플랫폼: 프로그래머스
문제 이름: 디스크 컨트롤러
알고리즘: 우선순위큐
tags:
  - 우선순위큐
date: 2025-09-11
aliases:
  - 우선순위큐
복습 풀이: 250911(X)
---
# 1차 풀이
```java
class Solution {
    public int solution(int[][] jobs) {
        PriorityQueue<Task> tasks = new PriorityQueue<>();
        for (int i = 0; i < jobs.length; i++) {
            tasks.add(new Task(i, jobs[i][0], jobs[i][1]));
        }

        int startTime = 0;
        List<Task> results = new ArrayList<>();
        while (!tasks.isEmpty()) {
            Task current = tasks.poll();

            int completedTime = startTime + current.duration;
            startTime += current.duration;
            current.complete(completedTime);

            results.add(current);
        }

        int returnTime = 0;
        for (Task task : results) {
            returnTime += task.completedTime - task.requestTime;
        }
        
        return returnTime / results.size();
    }

    static class Task implements Comparable<Task> {
        private int no;
        private int requestTime;
        private int duration;
        private int completedTime;

        public Task(int no, int requestTime, int duration) {
            this.no = no;
            this.requestTime = requestTime;
            this.duration = duration;
        }

        public void complete(int time) {
            this.completedTime = time;
        }

        @Override
        public int compareTo(Task o) {
            if (this.duration == o.duration) {
                return this.requestTime - o.requestTime;
            }

            return this.duration - o.duration;
        }
    }
}
```
위 풀이는 틀린 풀이.
지금은 소요 시간이 빠른 순으로 우선 정렬하는데, 소요 시간이 아무리 빨라도 요청 시간에 도달하지 못했으면 실행할 수 없음
이 부분이 전혀 고려되지 않고 설계되어 틀림

하지만 해당 부분을 알아도 여전히 구현이 어려움
여러번 풀어보며 익히기