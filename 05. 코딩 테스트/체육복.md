---
플랫폼: 프로그래머스
문제 이름: 체육복
알고리즘: 그리디
tags:
  - 그리디
date: 2025-10-08
aliases:
  - 그리디
복습 풀이: 251009(X), 251012(O), 251020(O), 251025(O), 251117(O), 260123(O)
---
# 1차 풀이
```java
import java.util.*;

// 2 0 2 0 2
class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] array = new int[n];
        Arrays.fill(array, 1);
        
        for (int l : lost) {
            array[l - 1]--;
        }
        
        for (int r : reserve) {
            array[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] >= 1) {
                count++;
                continue;
            }
            
            if (array[i] == 0 && i > 0 && i < n - 1) {
                if (array[i - 1] < 2 && array[i + 1] < 2) {
                    continue;
                }
                
                if (array[i - 1] >= 2) {
                    count++;
                    array[i - 1]--;
                    continue;
                }
                
                if (array[i + 1] >= 2) {
                    count++;
                    array[i + 1]--;
                }
            }
        }
        
        return count;
    }
}
```
경계 조건을 잘못 설정해 틀림.
배열의 첫번째와 마지막에 대한 요소도 조건문 안에 포함되도록 변경해야 함
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] array = new int[n];
        Arrays.fill(array, 1);
        
        for (int l : lost) {
            array[l - 1]--;
        }
        
        for (int r : reserve) {
            array[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            if (array[i] >= 1) {
                count++;
                continue;
            }
            
            if (array[i] == 0) {
                // 왼쪽 학생에게 빌리기
                if (i > 0 && array[i - 1] >= 2) {
                    count++;
                    array[i - 1]--;
                    continue;
                }
                
                // 오른쪽 학생에게 빌리기
                if (i < n - 1 && array[i + 1] >= 2) {
                    count++;
                    array[i + 1]--;
                }
            }
        }
        
        return count;
    }
}
```
단순 구현 느낌으로 풀었는데, 책을 보니 다른 풀이가 존재하니 참고할 것

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] students = new int[n];
        Arrays.fill(students, 1);
        for (int l : lost) {
            students[l - 1]--;
        }
        
        for (int r : reserve) {
            students[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (students[i] >= 1) {
                count++;
                continue;
            }
            
            if (i > 0 && students[i - 1] > 1) {
                students[i - 1]--;
                count++;
                continue;
            }
            
            if (i < n - 1 && students[i + 1] > 1) {
                students[i + 1]--;
                count++;
            }
        }
        
        return count;
    }
}
```
1차 풀이와 달리 경계 값을 제대로 명시해 첫 번째, 마지막 원소도 검사할 수 있도록 수정

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] clothes = new int[n];
        Arrays.fill(clothes, 1);
        for (int l : lost) {
            clothes[l - 1]--;
        }
        
        for (int r : reserve) {
            clothes[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (clothes[i] >= 1) {
                count++;
                continue;
            }
            
            if (i > 0 && clothes[i - 1] > 1) {
                clothes[i - 1]--;
                clothes[i]++;
                count++;
                continue;
            } 
            
            if (i < n - 1 && clothes[i + 1] > 1) {
                clothes[i + 1]--;
                clothes[i]++;
                count++;
            }
        }
        
        
        return count;
    }
}
```

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] clothes = new int[n];
        Arrays.fill(clothes, 1);
        
        for (int l : lost) {
            clothes[l - 1]--;
        }
        
        for(int r : reserve) {
            clothes[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (clothes[i] > 0) {
                count++;
                continue;
            }
            
            if (i > 0 && clothes[i - 1] > 1) {
                clothes[i - 1]--;
                count++;
            } else if (i < n - 1 && clothes[i + 1] > 1) {
                clothes[i + 1]--;
                count++;
            }
        }
        
        return count;
    }
}
```

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] clothes = new int[n];
        for (int l : lost) {
            clothes[l - 1]--;
        }
        
        for (int r : reserve) {
            clothes[r - 1]++;
        }
        
        for (int i = 0; i < n; i++) {
            if (clothes[i] >= 0) continue;
            
            if (i > 0 && clothes[i - 1] > 0) {
                clothes[i]++;
                clothes[i - 1]--;
                continue;
            }
            
            if (i < n - 1 && clothes[i + 1] > 0) {
                clothes[i]++;
                clothes[i + 1]--;
            }
        }
        
        return (int) Arrays.stream(clothes)
            .filter(c -> c >= 0)
            .count();
    }
}
```

# 6차 풀이
```java
class Solution {
    public int solution(int n, int[] lost, int[] reserve) {
        int[] students = new int[n];
        for (int l : lost) {
            students[l - 1]--;
        }
        
        for (int r : reserve) {
            students[r - 1]++;
        }
        
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (students[i] >= 0) {
                count++;
                continue;
            }
            
            if (i > 0 && students[i] == -1 && students[i - 1] == 1) {
                students[i]++;
                students[i - 1]--;
                count++;
                continue;
            }
            
            if (i < n - 1 && students[i] == -1 && students[i + 1] == 1) {
                students[i]++;
                students[i + 1]--;
                count++;
                
            } 
        }
        
        return count;
    }
}
```
2번 실패 후 3번째에 통과
- 수정하면서 조건 값 잘못 설정 ` if (i < n - 1 && students[i] == -1 && students[i + 1] == -1`
- 앞번호 학생부터 남는 체육복이 존재하는지 검사해야 하는데 뒤에 학생부터 검사해서 틀림
	- 그리디이므로 앞에서부터 찾아야 함
- 