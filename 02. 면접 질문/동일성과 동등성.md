- **동일성**
	- 참조하는 메모리 주소가 같음(== 으로 비교)
- **동등성**
	- 두 객체가 논리적으로 같은 값을 가지고 있음(equals메서드를 오버라이딩하여 비교)

### 두 객체가 같은 클래슬 생성된 인스턴스이고, 내부 필드의 값이 모두 같은 경우 두 객체의 동등성을 어떻게 판별할까요?
- 최상위 객체인 Object의 equals()와 hashcode를 오버라이딩
- 오버라이딩하여 두 객체가 같은 값을 가지는지 확인
- 두 메서드는 기본적으로 객체의 주소값을 기반으로 비교, 생성됨

### "두 객체의 hashCode()가 다르면 equals()는 항상 false를 반환한다"는 명제는 참일까요?

네, 참입니다. 이는 `equals()`와 `hashCode()`의 관계를 규정하는 매우 중요한 원칙 중 하나입니다.
이 명제는 **"equals() 비교 결과가 true인 두 객체는 반드시 동일한 hashCode 값을 가져야 한다"**는 핵심 규약의 **대우(contrapositive)** 명제입니다.
- **원본 규약**: `a.equals(b)`가 `true`이면, `a.hashCode() == b.hashCode()`는 반드시 `true`이다.
- **대우 명제**: `a.hashCode() != b.hashCode()`이면, `a.equals(b)`는 반드시 `false`이다.
**이유**: `HashMap`, `HashSet` 등 해시 기반 컬렉션은 성능 최적화를 위해 이 원칙을 사용합니다. 키를 찾을 때 먼저 `hashCode()`를 비교하고, 이 값이 다르면 비용이 더 비싼 `equals()` 비교는 실행조차 하지 않고 즉시 두 객체가 다르다고 판단합니다.

---
### equals()에서 instanceof와 getClass()의 차이점

`equals()` 메서드 내에서 객체의 타입을 비교할 때 `instanceof`와 `getClass()`는 **상속 관계**에 있는 클래스 간의 동등성 비교에서 중요한 차이를 만듭니다.
- `if (!(obj instanceof MyClass))`: `obj`가 `MyClass`이거나 **`MyClass`를 상속받은 자식 클래스**의 인스턴스이면 `true`를 반환합니다.
- `if (this.getClass() != obj.getClass())`: 두 객체의 **런타임 클래스 타입이 정확히 일치**할 때만 `true`가 됩니다.

| 비교 방식            | 장점                                                                                      | 단점                                                                                                                           |
| ---------------- | --------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------- |
| **`instanceof`** | 유연함. 자식 클래스가 부모 클래스의 필드만으로 동등성을 만족할 경우, 자식과 부모 객체가 같다고 판단할 수 있음.                        | `equals` 규약 중 **대칭성(`symmetry`)**을 위반할 가능성이 있음. (e.g., `parent.equals(child)`는 true인데 `child.equals(parent)`는 false가 될 수 있음) |
| **`getClass()`** | `equals` 규약(특히 대칭성)을 깨뜨리지 않고 더 엄격하고 안전하게 동등성을 비교할 수 있음. "같은 클래스의 객체끼리만 같다"는 명확한 기준을 제시. | 유연성이 떨어짐. 상속을 통해 확장된 클래스는 부모 클래스와 절대 같아질 수 없음.                                                                               |

**결론**: `Effective Java`와 같은 서적에서는 `equals` 규약을 깨뜨릴 위험 때문에 **`getClass()`를 사용하는 것을 더 권장**합니다.

---
### equals() 메서드의 5가지 일반 규약

`Object` 클래스 명세에 따르면, `equals()` 메서드를 오버라이딩할 때는 반드시 다음 5가지 규약을 지켜야 합니다.
1. **반사성 (Reflexivity)**: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(x)`는 항상 `true`여야 합니다. (객체는 자기 자신과 같아야 한다.)
2. **대칭성 (Symmetry)**: `null`이 아닌 모든 참조 값 `x`, `y`에 대해, `x.equals(y)`가 `true`이면 `y.equals(x)`도 `true`여야 합니다. (A와 B가 같다면, B와 A도 같아야 한다.)
3. **추이성 (Transitivity)**: `null`이 아닌 모든 참조 값 `x`, `y`, `z`에 대해, `x.equals(y)`가 `true`이고 `y.equals(z)`도 `true`이면 `x.equals(z)`도 `true`여야 합니다. (A=B이고 B=C이면, A=C여야 한다.)
4. **일관성 (Consistency)**: `null`이 아닌 모든 참조 값 `x`, `y`에 대해, `equals` 비교에 사용되는 정보가 변경되지 않는 한, `x.equals(y)`를 반복해서 호출해도 결과는 항상 같아야 합니다.
5. **null-아님 (Non-nullity)**: `null`이 아닌 모든 참조 값 `x`에 대해, `x.equals(null)`은 항상 `false`여야 합니다.
---
### 원시 타입과 참조 타입에서 == 연산자의 동작 차이

`==` 연산자는 **변수에 저장된 값을 비교**한다는 점에서는 동일하지만, 변수에 무엇이 저장되느냐에 따라 동작 방식이 달라집니다.
- **원시 타입 (Primitive Type)**: `int a = 10;`
    - 변수 `a`의 메모리 공간에는 **실제 값 `10`**이 직접 저장됩니다.
    - `a == b`는 두 변수의 **실제 값**을 비교하므로 **동등성(equality)**을 비교합니다.
- **참조 타입 (Reference Type)**: `Object obj = new Object();`
    - 실제 객체는 힙(Heap) 메모리에 저장되고, 변수 `obj`에는 힙에 있는 **객체의 메모리 주소(참조 값)**가 저장됩니다.
    - `obj1 == obj2`는 두 변수에 저장된 **메모리 주소**를 비교하므로 **동일성(identity)**을 비교합니다.
---
### String Constant Pool과 동일성/동등성

Java는 메모리 효율을 위해 **문자열 상수 풀(String Constant Pool)**이라는 특별한 공간을 운영합니다.
- `**String s1 = "hello";**`
    - 문자열 리터럴로 생성 시, JVM은 String Constant Pool에서 `"hello"`를 찾습니다.
    - 없으면 새로 생성하고, 있으면 기존 객체의 주소를 재사용합니다.
    - 이 때문에 `String s1 = "hello";`와 `String s3 = "hello";`는 `s1 == s3` 비교 시 `true`를 반환합니다.
- `**String s2 = new String("hello");**`
    - `new` 키워드는 **무조건 힙 메모리에 새로운 `String` 객체**를 만듭니다.
    - 이 객체는 String Constant Pool에 있는 객체와는 별개입니다.
**결론**:
- `s1 == s2`는 서로 다른 메모리 주소를 비교하므로 `false` (동일하지 않음)입니다.
- `s1.equals(s2)`는 두 객체의 문자열 값 "hello"를 비교하므로 `true` (동등함)입니다.
---
### record 타입이 equals()와 hashCode()를 해결하는 방식

**`record`**는 Java 14에서 도입된, 불변(immutable) 데이터를 쉽게 다루기 위한 새로운 유형의 클래스입니다. `record`를 선언하면 컴파일러가 `equals()`, `hashCode()`, `toString()`, 생성자, 접근자 메서드 등을 **자동으로 생성**해 줍니다.
- **자동 생성 `equals()`**: `record`를 구성하는 **모든 필드의 값이 같은지**를 비교하도록 구현됩니다.
- **자동 생성 `hashCode()`**: `record`를 구성하는 **모든 필드의 값을 기반으로** 해시 코드를 생성하도록 구현됩니다.

**장점**:
- **보일러플레이트 코드 감소**: 개발자가 `equals()`, `hashCode()` 등을 직접 작성하는 수고를 덜어줍니다.
- **휴먼 에러 방지**: 필드 변경 시 관련 메서드를 수정하는 것을 잊어서 발생하는 버그를 원천적으로 차단합니다.
- **가독성 및 유지보수성 향상**: 클래스의 목적이 '데이터 전달'임을 명확하게 표현할 수 있습니다.
