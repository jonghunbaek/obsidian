---
플랫폼: 프로그래머스
문제 이름: 스킬트리
알고리즘: 구현
tags:
  - 구현
date: 2025-09-22
aliases:
  - 구현
복습 풀이: 250922(O), 251005(O), 251011(O)
---
# 1차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public int solution(String skill, String[] skill_trees) {
        char[] skills = skill.toCharArray();

        int answer = 0;
        for (String tree : skill_trees) {
            List<Character> characters = new ArrayList<>();
            for (char c : tree.toCharArray()) {
                for (int i = 0; i < skills.length; i++) {
                    if (skills[i] == c) {
                        characters.add(c);
                    }
                }
            }

            String target = characters.stream()
                    .map(String::valueOf)
                    .collect(Collectors.joining());

            if (isValid(target, skills)) {
                answer++;
            }

        }

        return answer;
    }

    private boolean isValid(String target, char[] skills) {
        for (int i = 0; i < target.length(); i++) {
            if (skills[i] != target.charAt(i)) {
                return false;
            }
        }

        return true;
    }
}
```
깔끔하게 푼 느낌은 없지만 맞췄음

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String skill, String[] skill_trees) {
        return (int) Arrays.stream(skill_trees)
            .map(tree -> tree.replaceAll("[^" + skill + "]", ""))
            .filter(tree -> skill.startsWith(tree))
            .count();
    }
}
```
정규 표현식을 이용해 깔끔하게 풀이.
정규 표현식은 기본 정도는 푸는 것이 여러모로 도움되는 듯

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String skill, String[] skill_trees) {
        return (int) Arrays.stream(skill_trees)
            .map(tree -> tree.replaceAll("[^" + skill + "]", ""))
            .filter(tree -> skill.startsWith(tree))
            .count();
    }
}
```
간간히 정규표현식 연습하기