---
플랫폼: 프로그래머스
문제 이름: 가사 검색
알고리즘: 트라이
tags:
  - 트라이
date: 2025-09-18
aliases:
  - 트라이
복습 풀이: 250918()
---
# 1차 풀이
```java
class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();

        for (String word : words) {
            normal.insert(word);
            reverse.insert(new StringBuilder(word).reverse().toString());
        }

        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = reverse.search(new StringBuilder(queries[i]).reverse().toString());
                continue;
            }

            results[i] = normal.search(queries[i]);
        }

        return results;
    }

    static class TrieNode {
        TrieNode[] children = new TrieNode[26]; // 알파벳 26자
        int[] count = new int[10001]; // 키워드의 최대 길이는 10,000
    }

    static class Trie {
        TrieNode root = new TrieNode();

        public void insert(String word) {
            int length = word.length();
            root.count[length]++;
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                if (node.children[c - 'a'] == null) {
                    node.children[c - 'a'] = new TrieNode();
                }

                node = node.children[c - 'a'];
                node.count[length]++;
            }
        }

        public int search(String query) {
            TrieNode node = root;
            int length = query.length();
            for (int i = 0; i < length; i++) {
                char c = query.charAt(i);
                if (c == '?') {
                    return node.count[length];
                }

                if (node.children[c - 'a'] == null) {
                    return 0;
                }

                node = node.children[c - 'a'];
            }

            return node.count[length];
        }
    }
}
```
트라이 자료구조 자체는 어렵지 않다.
해당 자료구조를 알고 구현만 할 줄 안다면 어렵지 않게 풀어볼 수 있다. 
하지만 해당 풀이는 효율성 테스트에서 모두 메모리 초과가 발생한 코드다.(자식 노드마다 10001 길이의 배열을 생성하니 당연할지도..)

```java
import java.util.*;

class Solution {
    public int[] solution(String[] words, String[] queries) {
        Trie normal = new Trie();
        Trie reverse = new Trie();

        for (String word : words) {
            normal.insert(word);
            reverse.insert(new StringBuilder(word).reverse().toString());
        }

        int[] results = new int[queries.length];
        for (int i = 0; i < queries.length; i++) {
            if (queries[i].startsWith("?")) {
                results[i] = reverse.search(new StringBuilder(queries[i]).reverse().toString());
                continue;
            }

            results[i] = normal.search(queries[i]);
        }

        return results;
    }

    static class TrieNode {
        Map<Character, TrieNode> children = new HashMap<>();
        Map<Integer, Integer> count = new HashMap<>();
    }

    static class Trie {
        TrieNode root = new TrieNode();

        public void insert(String word) {
            int length = word.length();
            root.count.put(length, root.count.getOrDefault(length, 0) + 1);
            TrieNode node = root;
            for (char c : word.toCharArray()) {
                Map<Character, TrieNode> children = node.children;
                if (!children.containsKey(c)) {
                    children.put(c, new TrieNode());
                }

                node = children.get(c);
                node.count.put(length, node.count.getOrDefault(length, 0 ) + 1);
            }
        }

        public int search(String query) {
            TrieNode node = root;
            int length = query.length();
            for (int i = 0; i < length; i++) {
                char c = query.charAt(i);
                if (c == '?') {
                    break;
                }

                if (!node.children.containsKey(c)) {
                    return 0;
                }

                node = node.children.get(c);
            }

            return node.count.getOrDefault(length, 0);
        }
    }
}
```
배열을 HashMap으로 바꿔 통과