동시성 문제를 제대로 처리하는 것은 많은 지식과 경험을 필요로 한다. 
다행히 Java와 JVM은 동시성 문제 해결을 위한 진입 장벽을 상당히 낮춰준다. 

# 1. 물리 머신의 메모리 모델
물리 머신에서 발생하는 동시성 문제는 가상 머신의 동시성 문제와 비슷한 점이 많다.
그러므로 해결책 또한 차용할 수 있는 경우가 많다.
![[JVM 12장 - 물리 머신 메모리 모델.png|500]]
물리 머신에서 프로세서의 연산 처리 속도는 메모리에 접근하는 속도보다 훨씬 빠르다.
이를 해결하기 위해 다음과 같은 방식들을 사용한다.
- **레지스터와 같은 캐시 계층**
	- 캐시 일관성과 같은 새로운 문제가 발생하며, 프로토콜을 활용해 이를 해결
- **비순차 실행 최적화**
	- 결과는 같지만 실제 실행 과정은 입력된 코드와 다를 수 있음

# 2. 자바 메모리 모델
## 2.1 메인 메모리와 작업 메모리
자바 메모리 모델의 주된 목적은 메모리에서 변수에 값을 저장하고 가져오는 저수준의 세세한 규칙을 정하는 것에 있다. 
→ 여기서 변수의 범위에 지역 변수, 매개 변수는 제외된다. (스레드별 고유 공간이므로 동기화가 필요 없음)
즉, **자바 메모리 모델은 스레드간 데이터 동기화를 위한 일종의 프로토콜**이라고 볼 수 있다.

![[JVM 12장 - JVM 메모리 모델.png|500]]
자바 메모리 모델은 **모든 변수가 메인 메모리(가상 머신)에 저장된다고 규정**한다. 
각 스레드는 자체 작업 메모리를 가진다. 
**작업 메모리엔 해당 스레드가 사용하는 변수의 복사본(메인 메모링 저장되어 있음)이 존재**한다. 
스레드가 변수를 읽고 쓰는 모든 연산은 작업 메모리에서 수행되며 메인 메모리의 데이터를 직접 읽고 쓸 수 없다. 
또한 스레드끼리는 서로의 작업 메모리에 있는 변수에 직접 접근할 수 없다. 

메인 메모리, 작업 메모리 각각은 물리 머신에서 하드웨어 메모리, 레지스터/캐시에 대응된다. 
실제로 성능 최적화를 위해 작업 메모리를 레지스터나 캐시에 미리 저장하기도 한다. 
## 2.2 메모리 간 상호 작용
자바 메모리 모델에서 메인 메모리와 작업 메모리 간 데이터 동기화에 대한 구체적인 방법을 다음과 같이 정의한다.
 JVM은 각 단계의 연산이 원자적으로 수행되도록 보장해야 한다. 
 - **잠금(lock)**
	 - 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만듦
 - **잠금 해제(unlock)**
	 - 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있음
 - **읽기(read)**
	 - 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 **전송**
 - **적재(load)**
	 - 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 **복사해 넣음**
 - **사용(use)**
	 - 작업 메모리의 변숫값을 실행 엔진으로 전달.
	 - VM이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행
 - **할당(assign)**
	 - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
	 - VM이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행
 - **저장(store)**
	 - 작업 메모리의 변숫값을 메인 메모리로 전송
 - **쓰기(write)**
	 - 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록

이 중 읽기/적재, 저장/쓰기는 각각 순서대로 수행되어야 한다.
하지만 순서대로만 수행된다면 사이에 다른 연산이 수행되어도 문제가 발생하지 않는다.

이러한 연산들을 수행할 때 지켜야 할 규칙들도 존재한다. 
- **읽기/적재, 저장/쓰기는 단독으로 수행될 수 없음**
- **스레드는 최근 할당 연산을 버릴 수 없음**
	- 할당이 됐다는 것은 변수의 값이 변한 것이므로 반드시 메인 메모리에 동기화 되어야 함
- **스레드는 작업 메모리의 데이터를 아무 이유 없이(할당 없이) 메인 메모리로 동기화할 수 없음**
- **변수는 메인 메모리에서만 새로 생겨날 수 있으며, 작업 메모리에 있는 초기화 되지 않은 변수를 곧바로 사용할 수 없음**
	- 변수를 사용/저장하기 전에 할당과 적재과 이뤄져야 함
- **변수는 한 번에 한 스레드만 잠글 수 있음**
- **변수를 잠그면 작업 메모리의 변숫값은 지워진다.** 
- **잠겨 있지 않은 변수나 다른 스레드가 잠근 변수에 대해서는 잠금 해제 연산을 수행할 수 없음**
- **잠금 해제를 하려면 변수를 메인 메모리에 동기화해야 함**

이 복잡하고 추상적인 규칙들을 자바 설계진에서 네 가지 유형(읽기, 쓰기, 잠금, 잠금 해제)로 단순화 했다.
→ 언어 설명 차원의 이야기이지, 실제 메모리 모델이 달라지는 것은 아님

## 2.3 volatile 변수용 특별 규칙
volatile 키워드는 JVM이 제공하는 가장 가벼운 동기화 메커니즘이다.
volatile로 선언된 변수의 읽기 성능은 일반 변수와 비슷하지만 쓰기는 더 느릴 수 있다. 
➡️ 명령어 재정렬을 방지하기 위해 네이티브 코드에 메모리 장벽 명령어를 다수 삽입하기 때문
변수가 volatile로 정의되면 다음 두 가지 특성을 갖게 된다.
- **모든 스레드에서 이 변수를 투명하게 볼 수 있음**
- **명령어 재정렬 최적화를 방지**
### 모든 스레드에서 변수를 투명하게 볼 수 있음
이 말은 다른 말로 '가시성을 보장한다'라고 할 수 있다. 
작업 메모리에서 volatile 변수의 일관성은 문제가 없지만 **자바의 산술 연산자가 원자적이지 않아 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하진 않다.**
```java
public stataic volatile int race = 0;

public static void increase() {
	race++;
}
```
이 자바 코드는 컴파일 후 5줄의 바이트코드로 파싱된다. 이 과정에서 값을 가져오고, 갱신하기 때문에 일관성이 깨질 수 있다. 

**이러한 특징을 가진 volatile 변수는 가시성만 보장한다고 볼 수 있다.** 
때문에 다음 두 규칙을 충족할 때만 volatile은 멀티스레드 환경에서 안전하다고 말할 수 있다. 
- **연산 결과가 변수의 현재 값과는 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장**
	- 즉, 연산에 현재의 값이 필요한 경우라고 볼 수 있음
- **다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않음**
	- 다른 상태 변수들과 논리적으로 묶이지 않아야 함

### 명령어 재정렬 최적화 방지
명령어 재정렬은 동시성 프로그래밍에서 가장 혼란스러운 영역이다. 
다음 예제를 통해 volatile 키워드가 명령어 재정렬을 막는 방식을 알아보자.
```java
public class Singlton {
	private volatile static Singleton instance;

	public static Singleton getInstance() {
		if (instance == null) {https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b
			syncronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}

	public static void main(String[] args) {
		Singleton.getInstance();
	}
}
```
이 코드가 컴파일 되면 volatile 때문에 'lock addl $0x0, ( %esp)' 작업이 추가로 수행된다. 
이 작업은 메모리 장벽과도 같은 기능을 하는데, 장벽 뒤의 명령어를 장벽 앞으로 재정렬할 수 없도록 만든다.
addl $0x0, ( %esp) 명령은 ESP 레지스터 값에 0을 추가하라는 뜻이며, 노옵을 뜻한다. 
**lock 접두어는 프로세서의 캐시를 메인 메모리에 쓰는 기능을 하며, 다른 프로세서가 자신의 캐시를 무효화하게 한다.** 
그러므로 이 노옵 명령 덕분에 이전 volatile 변수의 수정 사항을 다른 프로세서에서 즉시 볼 수 있다. 
더불어, 이 명령어가 수행 되어 메모리에 동기화할 때는 **이전의 모든 작업이 수행 되었음을 뜻**하므로 이 명령어 앞으로 재정렬을 할 수 없게 되는 효과도 존재한다.

>[!노옵]
>노옵이란  아무 일도 하지 않는 명령이란 뜻이다. 

>[!volatile의 메모리 장벽]
>해당 답변은 GPT 답변이므로 검증이 필요함.
>책에선 addl $0x0, ( %esp) 명령어 자체에 힘을 실어 설명했지만 GPT에선 lock 접두어에 집중했다.
>현대 CPU의 내부 구조가 x86 아키텍처일 때, lock 명령어를 발견하면 해당 명령어 앞의 모든 적재/저장이 반드시 수행되도록 강제한다. 
>즉, lock 접두어가 붙은 경우 해당 명령어 앞의 모든 명령어 수행을 끝낸다고 볼 수 있다.

## 2.4 long과 double 변수용 특별 규칙
64비트 데이터 타입인 두 키워드는 가상 머신에 따라 원자성이 보장될 수도 안될 수도 있다. 
64비트 상용 가상머신에선 원자적이지 않아도 데이터가 반만 수정되는 이상 현상은 거의 발생하지 않는다.
하지만 32비트 JVM에선 long 타입 데이터를 비원자적으로 처리할 위험이 존재한다. 
## 2.5 자바 메모리 모델의 주요 특징
### 원자성
자바 메모리 모델이 직접 보장하는 원자적 연산은 다음과 같다.
- 읽기
- 적재
- 할당
- 사용
- 저장
- 쓰기
잠금/잠금 해제 연산은 애플리케이션 수준에서 원자성을 더 넓은 범위로 제공하기 위해 사용된다. 
다만 사용자에게 직접 제공하지는 않고, 바이트 코드 명령어 monitorenter와 monitorexit을 이용 하도록 한다. 
➡️ syncronized 키워드로 사용된 블록
### 가시성
volatile은 자바에서 가시성을 보장하는 키워드다. 
volatile로 선언된 변수는 일반 변수와 달리 새로운 값을 즉시 메모리로 동기화하고, 이를 사용할 때마다 즉시 메인 메모리에서 새로 고치도록 한다. 
➡️ 일반 변수도 이러한 과정을 수행하긴 하지만 항상/즉시 수행되진 않음

volatile외에도 syncronized와 final 또한 가시성을 보장한다.
syncronized 블록의 가시성은 '**변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화해야 한다**'는 규칙으로 확보된다.
final 키워드의 가시성은 final로 선언된 변수가 생성자에서만 초기화 된다는 규칙으로 확보된다.
➡️ 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없음
### 실행 순서
자바 프로그램의 명령어 실행 순서는 다음처럼 요약할 수 있다.
```text
현재 스레드에서 보면 모든 연산이 순서대로 수행된다. 하지만 다른 스레드에서 보면 순서가 다를 수 있다.
```
여기서 두 번째 문장은 '명령어 재정렬'과 '작업 메모리와 메인 메모리 사이의 동기화 지연 현상'을 의미한다. 

## 2.6 선 발생 원칙
선 발생 원칙은 데이터 경합 발생 여부와 스레드 안정성을 확인하는 데 매우 유용한 수단이다.
즉, 몇 가지 간단한 규칙으로 자바 메모리 모델의 복잡한 정의에 얽매이지 않을 수 잇다. 

선 발생 원칙에서 '선 발생'은 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다. 
a, b 두 작업이 존재하고, a가 b보다 선 발생했다면 작업 b가 수행되기 전에 작업 a의 수행 결과를 작업 b에서 관찰할 수 있다.

다음은 자연스러운 선 발생 관계다. 동기화 장치의 지원 없이 이루어지며, 코드에서 활용할 수 있다.
만약 **두 작업 사이의 관계가 다음 목록에 없고, 이로부터 추론할 수도 없다면** 이는 **JVM에서 명령어 순서를 마음대로 바꿀 수 있다는 뜻**이다.
- **프로그램 순서 규칙**
	- 한 스레드 안에서는 '제어 흐름 순서'에 따라 앞의 연산이 뒤따르는 연산보다 선 발생한다. 
- **모니터 락 규칙**
	- 잠금 해제 연산은 '같은 락'에 대한 잠금 연산보다 선 발생한다. 순서는 시간 순서다.
- **휘발성 변수 규칙**
	- volatile 변수의 쓰기 연산은 같은 변수에 대한 읽기 연산보다 선 발생한다. 순서는 시간 순서다.
- **스레드 시작 규칙**
	- Thread 객체의 start()메서드는 해당 스레드의 어떤 작업보다도 선 발생한다.
- **스레드 종료 규칙**
	- 스레드의 모든 작업은 해당 스레드의 종료 감지보다 선 발생한다.
- **스레드 인터럽트 규칙**
	- Thread의 interrupt() 메서드 호출은 인터럽트되는 스레드가 인터럽트 이벤트 발생 감지보다 선 발생한다.
- **종료자 규칙**
	- 객체 초기화는 finalize()메서드 시작 보다 선 발생한다.
- **전이성**
	- 연산 a가 연산 b보다 선 발생하고, 연산 b가 연산 c보다 선 발생한다면 연산 a가 c보다 선 발생한다고 결론지을 수 있다.

# 3. 자바와 스레드
## 3.1 다양한 스레드 구현 방식
자원 할당과 실행 스케줄링 측면에서 스레드와 프로세스는 차이가 있다.
스레드 각각은 프로세스 자원을 공유할 수 있으며, 독립적으로 스케줄링된다. 

이러한 스레드는 구현 방식에 따라 크게 세 가지로 구분될 수 있다.
 - **커널 스레드 구현(1:1 구현)**
 - **사용자 스레드 구현(1:N 구현)**
 - **하이브리드 구현(M:N)**
### 커널 스레드 구현
![[JVM 12장 - 커널 스레드 구현.jpeg|400]]
커널 스레드는 말 그대로 OS에서 직접 지원하는 스레드이며, 스레드의 작업을 각 프로세서에 매핑하는 역할을 한다. 
**즉, 커널 스레드 각각은 커널의 복제본으로 생각할 수 있다.**

프로그램은 일반적으로 커널 스레드를 직접 사용하지 않고, 커널 스레드의 고수준 인터페이스인 경량 프로세스를 이용한다. 
커널 스레드의 도움으로 경량 프로세스 각각은 독립된 단위로 스케줄링된다.
이 방식엔 다음과 같은 단점이 존재한다.
- **상대적으로 높은 실행 비용**
- **일정량의 커널 자원을 소모하므로 시스템이 지원할 수 있는 경량 프로세스 개수에 제한이 존재**
### 사용자 스레드 구현
![[JVM 12장 - 사용자 스레드 구현.jpg|400]]
사용자 스레드를 이용하는 구현을 1:N 구현이라고도 한다.
넓은 의미에서 커널 스레드외엔 모두 사용자 스레드로 볼 수 있으므로 경량 프로세스 또한 사용자 스레드에 속한다.
좁은 의미에선 사용자 공간에서 구현되는 스레드 라이브러리를 가리킨다.
즉, **커널의 도움 없이 스레드의 생성, 소멸, 동기화, 스케줄링 모두 사용자 공간에서 처리**된다. 

장점과 단점 모두 커널을 사용하지 않는 것에서 비롯된다.
커널을 사용하지 않기 때문에 비용이 저렴하고, 빠르다.
하지만 **스레드 관련 모든 작업을 사용자 공간에서 처리하기에 일부 해결하기 어려운 문제들이 존재**하며, 매우 복잡하다.
 ➡️ 블로킹 처리와 멀티 프로세서 시스템에서 스레드를 특정 프로세서에 매핑하는 문제가 존재
### 하이브리드 구현
![[JVM 12장 - 하이브리드 스레드 구현.jpg|400]]
커널 스레드와 사용자 스레드를 함께 이용하는 것이 하이브리드 구현이며, N:M 구현이라고도 한다. 
이 구현은 OS의 경량 프로세스가 사용자 스레드와 커널 스레드 사이에서 가교 역할을 한다. 

## 3.2 자바의 스레드
JDK 1.3부터 주류 가상 머신들은 OS의 기본 스레드 모델을 사용하는 방식으로 스레드를 사용했다.
때문에 **OS가 제공하는 스레드 모델은 JVM의 스레드가 매핑되는 방식 지대한 영향**을 준다.
**21부터는 가상 스레드가 도입되며, 하이브리드 형태로 발전**했다. 

### 자바 스레드 스케줄링
스레드 스케줄링은 곧 프로세서 사용 권한을 스레드에 할당하는 일이다. 
주요 방식은 협력적 스케줄링과 선점형 스케줄링이 존재한다.
- **협력적 스케줄링**
	- 스레드 실행 시간을 스스로 제어(일을 마친 스레드가 다른 스레드로 전환되도록 시스템에 적극적으로 알려야 함)
	- 구현이 쉽고, 동기화 문제가 발생하지 않음
	- 스레드 실행 시간을 제어할 수 없기 때문에 프로세서 실행 권한을 계속 가지고 있으면 전체 시스템 장애로 이어질 수 있음
- **선점형 스케줄링**
	- 각 스레드의 실행 시간을 시스템이 할당
	- 구현이 복잡하고, 동기화 문제가 발생할 수 있음
	- 한 스레드의 장애가 전체 시스템 장애로 이어지지 않음
자바 스레드 스케줄링은 시스템이 자동으로 수행 하지만 특정 스레드의 실행 시간을 조정하도록 OS에 '권고'는 할 수 있다.
스레드의 우선 순위를 설정하는 방식인데, OS마다 우선 순위가 다르고, 고정된 개념이 아니기 때문에 추천하지는 않는다.

### 상태 전이
![[JVM 12장 - 스레드 상태전이.jpg|500]]
자바 언어에서 스레드의 상태는 총 여섯 가지로 구분할 수 있다.
- **신규**
	- 스레드 생성 후 시작되기 전 상태
- **실행 중**
	- OS의 스레드 상태 중에서 실행 중과 준비에 해당
- **무기한 대기**
	- 프로세서 실행 시간이 할당되지 않았고, 다른 스레드가 명시적으로 깨워주기를 기다리는 상태
	- Object::wait(), Thread::join()을 타임아웃 매개 변수 없이 호출한 경우
- **시간 제한 대기**
	- 프로세서 실행 시간이 할당되지 않았지만 일정 시간이 지나면 시스템에 의해 자동으로 깨어남
	- Thread::sleep()과 Object::wait(), Thread::join()을 타임아웃 매개 변수와 함께 호출한 경우 등
- **블록**
	- 스레드가 블록된 상태로 배타적 락 획득을 기다림
- **종료**
	- 스레드가 실행을 마침

### 자바 가상 스레드
