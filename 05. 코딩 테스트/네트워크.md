---
플랫폼: 프로그래머스
문제 이름: 네트워크
알고리즘: DFS, BFS
tags:
  - DFS
  - BFS
date: 2025-09-25
aliases:
  - DFS, BFS
복습 풀이: 250925(O), 251006(O), 251011(O), 251019(O), 251025(O), 251115(O)
---
# 1차 풀이
```java
class Solution {
    public int solution(int n, int[][] computers) {
        boolean[] visited = new boolean[n];
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (visited[i]) {
                continue;
            }

            explore(i, visited, computers);
            count++;
        }

        return count;
    }

    private void explore(int start, boolean[] visited, int[][] computers) {
        visited[start] = true;
        for (int i = 0; i < computers.length; i++) {
            if (visited[i] || computers[start][i] == 0) {
                continue;
            }

            visited[i] = true;
            explore(i, visited, computers);
        }
    }
}
```
풀면서 제대로 풀었는지 헷갈림
문제를 풀기 위한 논리적 과정을 곱씹으며 풀어보기
- 어떤 알고리즘을 써야 하는지
- 시간 복잡도는 어떻게 되는지
- 어떠한 방식으로 구현해야 하는지

# 2차 풀이
```java
// 1. 방문배열을 활용해 재귀 탐색을 하여, 네트워크 개수 파악

class Solution {
    public int solution(int n, int[][] computers) {
        int count = 0;
        boolean[] visited = new boolean[n];
        for (int i = 0; i < computers.length; i++) {
            if (visited[i]) {
                continue;
            }
            
            explore(i, computers, visited);
            count++;
        }
        
        return count;
    }

    private void explore(int from, int[][] computers, boolean[] visited) {
        visited[from] = true;
        for (int i = 0; i < computers[from].length; i++) {
            if (visited[i] || i == from || computers[from][i] == 0) {
                continue;
            }
            
            explore(i, computers, visited);
        }
    }
}
```

# 3차 풀이
```java
// 1. 2차원 방문 배열을 만들기
// 2. 연결된 컴퓨터엔 방문을 표시하고 방문이 가능한 경우엔 count++

class Solution {
    public int solution(int n, int[][] computers) {
        boolean[] visited = new boolean[n];
        int answer = 0;
        for (int i = 0; i < computers.length; i++) {
            if (visited[i]) {
                continue;
            }
            
            visited[i] = true;
            explore(i, computers, visited);
            answer++;
        }
        
        return answer;
    }
    
    private void explore(int from, int[][] computers, boolean[] visited) {
        for (int i = 0; i < computers.length; i++) {
            if (visited[i] || computers[from][i] == 0) {
                continue;
            }
            
            visited[i] = true;
            explore(i, computers, visited);
        }
    }
}
```

# 4차 풀이
```java
class Solution {
    public int solution(int n, int[][] computers) {
        boolean[] visited = new boolean[n];
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            
            result++;
            markNetwork(i, computers, visited);
        }
        
        return result;
    }
    
    private void markNetwork(int start, int[][] computers, boolean[] visited) {
        for (int i = 0; i < computers.length; i++) {
            if (visited[i] || computers[start][i] == 0) continue;
            
            visited[i] = true;
            markNetwork(i, computers, visited);
        }
    }
}
```

# 5차 풀이
```java
class Solution {
    public int solution(int n, int[][] computers) {
        boolean[] visited = new boolean[n];
        int network = 0;
        for (int i = 0; i < computers.length; i++) {
            if (visited[i]) continue;
            
            network++;
            connect(i, computers, visited);
        }
        
        return network;
    }
    
    private void connect(int start, int[][] computers, boolean[] visited) {
        for (int i = 0; i < computers.length; i++) {
            if (visited[i] || computers[start][i] == 0) continue;
            
            visited[i] = true;
            connect(i, computers, visited);
        }
    }
}
```

# 6차 풀이
```java
class Solution {
    public int solution(int n, int[][] computers) {
        boolean[] visited = new boolean[n];
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (visited[i]) continue;
            
            count++;
            connect(i, computers, visited);
        }
        
        return count;
    }
    
    private void connect(int start, int[][] computers, boolean[] visited) {
        for (int i = 0; i < computers.length; i++) {
            if (visited[i] || computers[start][i] == 0) continue;
            
            visited[i] = true;
            connect(i, computers, visited);
        }
    }
}
```