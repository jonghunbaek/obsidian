---
플랫폼: 프로그래머스
문제 이름: 주식가격
알고리즘: 스택
tags:
  - 스택
date: 2025-09-01
aliases:
  - 스택
복습 풀이: 250901(X). 250907(X), 250913(O), 250920(O)
---
# 1차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] prices) {
        Stack<Integer> stack = new Stack<>();
        
        int[] results = new int[prices.length];
        for (int i = 0; i < prices.length; i++) {
            while (!stack.isEmpty() && prices[stack.peek()] > prices[i]) {
                int index = stack.pop();
                results[index] = i - index;
            }
            
            stack.push(i);
        }
        
        while (!stack.isEmpty()) {
            int index = stack.pop();
            results[index] = prices.length - index - 1;
        }
        
        return results;
    }
}
```
h-index 문제처럼 뭔가 어렵진 않지만 이해가 잘 안가는 문제..
일단 포인트는 스택을 쓰는데, 실제 값을 넣어주는 것이 아닌 인덱스를 넣어주는 것임
여러번 풀어보자
# 2차 풀이
```java
class Solution {
    public int[] solution(int[] prices) {
        Stack<Integer> stack = new Stack<>();
        int[] results = new int[prices.length];
        
        for (int i = 0; i < prices.length; i++) {
            while (!stack.isEmpty() && prices[stack.peek()] > prices[i]) {
                int idx = stack.pop();
                results[idx] = i - idx;
            }
            
            stack.push(i);
        }

        while (!stack.isEmpty()) {
            int idx = stack.pop();
            results[idx] = results.length - idx - 1;
        }
        
        return results;
    }
}
```
아직 이해못함 좀 더 풀어보기

# 3차 풀이
```java
import java.util.*;

// 1. prices의 인덱스를 스택에 담는다.
// 2. 더 적은 가격이 나오면 반복문을 돌려 스택의 값을 꺼내 해당 값보다 작은 값이 나올 때까지 확인
// 3. 인덱스의 차이가 곧 정답
class Solution {
    public int[] solution(int[] prices) {
        int[] results = new int[prices.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < prices.length; i++) {
            while(!stack.isEmpty() && prices[stack.peek()] > prices[i]) {
                int idx = stack.pop();
                results[idx] = i - idx;
            }
            
            stack.push(i);
        }
        
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            results[idx] = prices.length - idx - 1;
        }
        
        return results;
    }
}
```
마지막 한 번만 더 풀어보기

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int[] prices) {
        Stack<Integer> stack = new Stack<>();
        int[] results = new int[prices.length];
        for (int i = 0; i < prices.length; i++) {
            while (!stack.isEmpty() && prices[stack.peek()] > prices[i]) {
                int idx = stack.pop();
                results[idx] = i - idx;
            }
            
            stack.push(i);
        }
        
        while (!stack.isEmpty()) {
            int idx = stack.pop();
            results[idx] = results.length - idx - 1;
        }
        
        return results;
    }
}
```