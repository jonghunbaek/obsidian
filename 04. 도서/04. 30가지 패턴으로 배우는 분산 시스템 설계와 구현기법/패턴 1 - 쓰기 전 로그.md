# 1. 문제점
서버가 어떤 작업을 수행하기로 했으면 장애로 인해 메모리의 데이터가 휘발되어도 재작업할 수 있어야 한다. 
이 문제는 사실 분산 시스템만의 문제가 아니다. 
단일 서버에서도 장애 발생하여, 실제로 요청을 받았음에도 작업이 수행되지 않을 수 있다. 
# 2. 해결책
이러한 문제를 해결하기 위해 쓰기 전 로그(Write-Ahead Logging) 방식을 사용한다.
방법은 단순하다.
- **각각의 상태 변화를 명령어 형태로 하드디스크의 파일에 저장**(메모리 데이터 휘발 대응)
- **단일 로그는 각 서버 프로세스에 유지 관리하고, 순차적으로 덧붙여짐**(작업 단순화)
- **각 로그 엔트리엔 고유 식별자 부여**(분할 로그, 로우 워터마크에 활용)
이렇게 작성된 **로그는 서버 재시작 시, 상태 복구에 활용**된다.
### 로그 엔트리의 일반적 구성
```java
class WALEntry ... 
	
	private final Long entryIndex;
	private final byte[] data;
	private final EntryType entryType;
	private final long timeStamp;
```

### 구현 시 고려사항
- **로그 파일에 실제로 엔트리가 기록되었는가?**
	- 일반적으로 OS는 디스크 I/O 비용을 줄이기 위해, 일정량의 데이터를 모아서 한 번에 디스크에 동기화하는 버퍼 방식을 사용
	- 때문에 프로그래머 입장에선 저장되었다고 생각했어도 실제론 디스크에 저장되지 않는 경우가 존재
		- 이를 해결하기 위해 직접 플러시를 할 수는 있지만 명령어 한 번만다 디스크 I/O가 발생하므로 성능 저하로 병목 현상이 발생할 수 있음
		- 하지만 데이터의 지속성을 위해선 어느정도는 필요함
	- 이러한 문제로 인해 대부분의 구현체는 배치 작업 등의 기법을 사용해 플러시 작업의 충격을 완화
- **로그 엔트리가 손상되었는가?**
- 