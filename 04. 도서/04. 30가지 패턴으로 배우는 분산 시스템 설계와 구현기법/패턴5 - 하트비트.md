# 1. 문제점
[[패턴4 - 리더 팔로워]]모델에서 가장 중요한 요소 중 하나는 리더의 실패를 감지하고, 새로운 리더를 선출하는 것이다.
또한 해당 모델이 데이터 일관성 유지의 핵심임을 생각했을 때, 서버의 실패를 적시에 감지하는 것은 매우 중요한 일이다.
그럼 리더(서버)의 실패를 감지는 방법은 무엇일까?

# 2. 해결책
바로 모든 서버에 주기적으로 하트비트라는 요청을 보내 송신 서버의 활동성을 알리는 것이다.
하트비트 요청을 보낼 때 주요 고려사항이 있다.
```text
타임아웃 간격 > 요청 시간 간격 > 서버 간 네트워크 왕복시간
```
이 기준이 중요한 이유는 **거짓 음성을 예방할 수 있기 때문**이다.

### 하트비트 송수신
하트비트를 송신/수신하는 서버 모두 스케줄러를 통해 주기적으로 요청을 보내고 처리한다. 
송신 서버에선 주기적으로 하트비트를 보내야 하고, 수신 서버에선 주기적으로 하트비트가 정상 도착했는지 확인하여 실패 감지를 한다.

### 서버 실패 판단 기준
서버의 실패 여부를 판단하는 것은 일종의 트레이드 오프다. 
하트비트의 간격이 짧다면 적시에 서버 실패를 감지할 수 있지만, 거짓 음성이될 확률이 높아진다. 
반대로 간격이 짧다면 거짓 음성이될 확률은 낮아지지만 서버 실패를 적시에 감지하지 못해 데이터 일관성이 깨질 수 있다. 

따라서 이러한 트레이드 오프는 클러스터의 규모를 기반으로 구분할 수 있다. 
# 3. 클러스터 규모별 하트비트 전략
### 소규모 클러스터 : 합의 기반 시스템
모든 합의 시스템 구현에서 하트비트는 리더 서버에서 전체 팔로워 서버로 전송된다. 
수신된 하트비트의 타임스탬프를 기록하여 수신 주기를 확인하고, 제시간에 받지 못하면 리더가 실패했다고 간주한다. 
이 과정에서 프로세스들이 느리거나 네트워크 지연으로 **가짜 실패를 감지할 가능성**이 존재한다. 

가짜 실패를 감지했다고 해도 실패로 보기에 새로운 리더가 선출이 된다.
이 때, 기존 리더는 아직 자신이 리더라고 생각하고 하트비트를 보내게 된다.
**하트비트엔 일반적으로 세대 시계가 포함되기 때문에 이 요청에 대한 응답을 받은 후에 기존 리더는 팔로워**가 된다. 

>[!HOL블로킹으로 인한 하트비트 지연]
>단일 소켓 채널을 사용해 서버 간에 통신할 땐, HOL블로킹이 하트비트 메세지 처리를 방해하지 않도록 해야 한다. 
>HOL블로킹으로 인해 하트비트가 정상적으로 보내지고 있음에도 송신 서버에 장애가 생긴것으로 오해할 수 있다. 
>이 문제는 **하트비트를 비동기로 전송하는 것으로 해결**할 수 있다.(요청 파이프라인을 사용해 이전 요청에 대해 응답을 기다리지 않고 새 요청을 보냄)
>여기까진 송신 서버 입장에서의 문제이고, 수신 서버 입장에선 단일 갱신 큐를 사용할 때 비슷한 문제가 발생할 수 있다.
>
>수신 서버에서 단일 갱신 큐를 사용하면 디스크 쓰기 작업과 같은 작업 시 하트비트를 늦게 수신해 지연이 발생할 수 있다. 
>이러한 문제를 해결하기 위해 지연을 고려한 하트비트 메커니즘을 사용하기도 한다. 

>[!HOL 블로킹]
>Head Of Line Blocking으로 큐의 앞쪽에 있는 요청이 지연되어 이후 요청들도 함께 지연되는 현상

>[!단일 소켓 채널을 사용하는 이유]
>1. 연결 관리의 복잡성 - 서버가 많아질수록 관리해야할 채널이 늘어나므로 관리가 복잡해짐. 더불어 방화벽 설정 등 여러 설정이 복잡해짐
>2. 리소스 오버헤드 - 소켓마다 별도의 스레드/이벤트 루프가 필요하므로 리소스가 소모됨
>3. 트래픽 양의 차이 - 대규모 클러스터 대비 TPS가 낮기 때문에 단순한 설정을 이점으로 가져감.(그럼에도 충분히 트래픽 부하를 감당할 수 있기 때문)
### 대규모 클러스터 : 가십 기반 프로토콜
대규모 클러스터에선 소규모 클러스터와 달리 아래와 같은 내용을 고려해야 한다.
- 각 서버는 고정된 수 이상의 메세지를 생성하지 않아야 한다.
- 하트비트 메세지가 사용하는 총 대역폭이 너무 많은 네트워크 대역폭을 차지하지 않아야 한다.
수천 대의 서버가 존재할 수도 있기 때문에 이러한 조건은 당연하다.
이러한 조건을 고려했을 때, **대규모 클러스터에서 전체 서버에게 하트비트를 전송하는 것은 지양**해야 한다.
**대신 실패 감지자와 가십 전파 프로토콜을 함께 사용**해 실패 정보를 클러스터 전체에 전파한다. 

실패가 발생하면 노드간 데이터 이동이 발생하므로 상대적으로 긴 지연을 허용해 정확한 실패 감지를 추구한다.
따라서, 느린 처리 속도로 인해 거짓 실패를 감지하지 않도록 하는 것이 중요하다.
각 프로세스에 의심 번호를 할당해 이를 어느정도 방지할 수 있다.
제한된 시간 내에 해당 프로세스를 포함한 가십이 없다면 번호를 증가하고, 과거 통계를 기반으로 설정한 상한선에 도달하면 실패했다고 판단한다. 
-> 분산 시스템에선 서버를 프로세스라고 부르기도 함

>[!가십 프로토콜]
>각 노드가 주기적으로 자신이 알고 있는 정보를 랜덤하게 선택한 몇 개의 다른 노드들에게만 전송