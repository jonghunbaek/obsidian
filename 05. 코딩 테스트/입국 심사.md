---
플랫폼: 프로그래머스
문제 이름: 입국 심사
알고리즘: 이진탐색
tags:
  - 이진탐색
date: 2025-08-15
aliases:
  - 이진탐색
복습 풀이: 250815(X), 250818(X), 250824(O), 250830(O), 250906(O), 250913(O), 250919(O), 251029(O)
---
# 1차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        
        while (end > start) {
            long middle = (start + end) / 2;
            
            if (isShorter(middle, n, times)) {
                end = middle;                            
            } else {
                start = middle + 1;
            }
        }
        
        return start;
    }
    
    private boolean isShorter(long target, int n, int[] times) {
        long temp = 0;
        for (int time : times) {
            temp += target / time;
        }
        
        return temp >= n;
    }
}
```
이진 탐색인 것을 알고 봤지만 여전히 접근법조차 생각이 나지 않았던 문제
이진 탐색을 세우는 방식과 이진 탐색을 구분하는 조건에 대한 생각이 필요함

```java
// 1. 문제의 핵심은 시간을 기준으로 몇명의 심사를 완료했는지다.
// 2. 특정 시간(분)을 심사 시간으로 나누면 해당 심사관이 몇명을 심사할 수 있는지 알 수 있다.
// 3. 심사관의 심사 시간 배열을 순회하며 이 값을 더해 n과 일치하는 경우를 찾는것이 핵심
class Solution {
    public long solution(int n, int[] times) {
        long start = 0;
        long end = 1000000000000000000L;
        
        while (start < end) {
            long mid = (start + end) / 2;
            
            if (isBigger(mid, n, times)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        return start;
    }
    
    private boolean isBigger(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
코드가 간단해 기억나는데로 풀어 맞추긴했으나 제대로 이해하고 푼 것은 아님

# 3차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        
        while (start < end) {
            long mid = (start + end) / 2;
            
            if (isValid(mid, n, times)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        
        return start;
    }
    
    private boolean isValid(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
확실히 저번주보단 이해도가 올라감. 다만 이해보단 공식을 외운 느낌이라 더 풀어보며 이해도를 높이기

# 4차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        
        while (start <= end) {
            long mid = (start + end) / 2;
            
            if (isValid(mid, times, n)) {
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return start;
    }
    
    private boolean isValid(long mid, int[] times, int n) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
이분 탐색 문제 나오면 그냥 반쯤 포기하고 외워서 가는 방향으로 작업하는게 좋을 듯 하다.
일단 아래 템플릿을 고정 값으로 사용하기. 상세 내용은 [[이분 탐색]] 참조 
```java
int start = 0 // 정답이 가능한 최솟값
int end = some.size() - 1 // 정답이 가능한 최댓값
while(start <= end) {
	int mid = (start + mid) / 2;
	
	// 최솟값 찾는 문제
	if (isPossible(mid)) {
		end = mid - 1;
	} else {
		start = mid + 1;
	}
}
```

# 5차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        long answer = 0;
        
        while (start <= end) {
            long mid = (start + end) / 2;
            
            if (isValid(mid, n, times)) {
                answer = mid; // 3. 일단은 정답 후보가 될 수 있으므로 저장
                end = mid - 1; // 2. 때문에 이에 해당되면 범위를 좀 더 줄임                
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n; // 1. count의 최소 값을 찾아야 함(n이상이 되는 첫 번째 값)
    }
}
```

# 6차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1L;
        long end = 1000000000000000000L;
        long answer = 0L;
        
        while (start <= end) {
            long mid = (start + end) / 2;
            System.out.println("mid");
            if (isValid(mid, n, times)) {
                answer = mid;   
                end = mid - 1; // 정답이 될 수 있는 값 중 최솟값을 찾아야 하므로 범위 줄이기
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
문제에 익숙해지니 이분 탐색은 크게 어렵지 않음
하지만 이 문제의 기반이 전체 범위가 되는 시간을 고려해서 이분 탐색 기준을 세우는 것은 쉽지 않을 것으로 보임
한 번 더 풀어보되, 문제를 제대로 읽으며 논리적 단계를 거쳐 풀어 볼 것

# 7차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        long answer = 1;
        
        while (start <= end) {
            long mid = (start + end) / 2;
            
            if (isValid(mid, n, times)) {
                answer = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
# 8차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        long answer = 0;
        while(start <= end) {
            long mid = (start + end) / 2;
        
            if (isValid(n, times, mid)) {  // 정답 범위에 포함된다면 종료값을 감소
                answer = mid;
                end = mid - 1;    
            } else {
                start = mid + 1;
            }
        }
        return answer;
    }
    
    private boolean isValid(int n, int[] times, long mid) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```