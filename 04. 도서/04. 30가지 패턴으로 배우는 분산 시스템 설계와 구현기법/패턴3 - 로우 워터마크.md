# 1. 문제점
이전 [[패턴1 - 쓰기 전 로그]]와 [[패턴2 - 분할 로그]]에서 단일 파일로 관리할 때의 단점과 이에 대한 해결책에 대해 알아보았다. 
그런데 분할 로그라 한들 무한히 데이터를 쌓을 수는 없다.
어느 순간이 되면 필요 없는 로그는 삭제할 필요가 있다.

# 2. 해결책
그렇다면 어느 순간이라는 시점을 어떻게 정의할 수 있을까?
바로 로우 워터 마크가 그 시점을 정해준다.
이 메커니즘은 **로그를 폐기할 수 있는 가장 낮은 오프셋을 제공**한다.
백그라운드 스레드는 지속적으로 로우 워터마크를 확인하고 폐기할 수 있는 부분을 디스크에서 삭제한다.

# 3. 로우 워터 마크의 종류
### 스냅샷 기반 로우 워터마크
스냅샷 메커니즘 구현에서 저장소 엔진은 주기적으로 스냅샷을 생성한다. 
이 때, 스냅샷에는 적용에 성공한 **로그 인덱스도 함께 저장**한다.
스냅샷이 디스크 저장에 성공하면 오래된 로그를 폐기하기 위해 로그 매니저에게 로우 워터마크를 전달한다.
```java
class SnapshotBasedLogCleaner ... {
	@Override
	List<WALSegment> getSegmentsToBeDeleted() {
		return getSegmentsBefore(this.snapshotIndex);
	}
	
	List<WALSegment> getSegmentsBefore(Long snapshotIndex) {
		List<WALSegment> markedForDeletion = new ArrayList<>();
		List<WALSegment> sortedSavedSegments = wal.sortedSavedSegments;
		for (WALSegment sortedSavedSegment : sortedSavedSegments) {
			if (sortedSavedSegment.getLastLogEntryIndex() < snapshotIndex) {
				markedForDeletion.add(sortedSavedSegment);
			}
		}
		
		return markedForDeletion;
	}
}
```
### 시간 기반 로우 워터마크
일부 시스템에서는 시스템 상태를 갱신하는 데 로그를 사용하지 않아 시스템에선 정해진 time window가 지나면 로그를 폐기할 수 있다.
-> 시스템 상태 갱신을 어디까지 했는지 확인할 수 있는 인덱스가 필요 없음
이 방식에선 로그 엔트리에 생성 시간이 포함되어야 한다.



