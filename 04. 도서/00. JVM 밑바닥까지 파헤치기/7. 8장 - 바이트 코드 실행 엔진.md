자바 가상 머신 명세에선 바이트 코드 실행 엔진의 개념 모델을 정의해 다양한 JVM들이 통일성을 갖게 만들었다.
이 모델에서 실행 엔진의 실행 방법은 크게 두 가지로 구분할 수 있다.
- **해석 실행**(인터프리터를 통한 실행)
- **컴파일 실행**(JIT 컴파일러로 네이티브 코드 생성 후 실행)

두 가지 중 어떤 방식을 택하는 입력은 바이너리 바이트 스트림이며, 출력 결과는 같다.

# 1. 런타임 스택 프레임 구조
JVM은 메서드 호출과 실행을 뒷받침하는 내부 데이터 구조로 '스택 프레임'을 사용한다.
스택 프레임엔 아래와 같은 정보가 저장된다.
- **지역 변수 테이블**
- **피연산자 스택**
- **동적 링크**
- **메서드 반환 주소**
- **기타 추가 정보**

## 1.1 지역 변수 테이블
지역 변수 테이블은 말 그대로 메서드의 매개 변수와 메서드 안에서 정의된 지역 변수를 저장하는 공간이다.
이 공간의 **크기는 컴파일 시 계산되며, 오로지 소스 코드와 VM의 스택 메모리 레이아웃에 좌우**된다.

크기의 단위는 변수 슬롯을 사용하며, 일반적으로 변수 슬롯 하나의 크기는 32비트이다. (대개 32비트의 VM인 경우)
이 경우 저장될 수 있는 데이터 타입은 boolean, byte, char, short, int, float, 참조 타입, returnAddress다.

공식 문서에서 참조 타입의 크기를 명시하진 않았지만 참조는 다음 두 가지의 역할을 해야 한다.
- 참조가 가리키는 **객체의 자바 힙 내에서의 시작 주소 또는 인덱스를 알 수 있어야** 한다.
- 참조가 가리키는 **객체의 타입 정보를 직간접적으로 알 수 있어야** 한다.

64비트 데이터 타입(long, double)의 경우 JVM은 연속된 두 개의 슬롯을 고차 정렬 방식으로 연결해 할당한다.
이 때문에 long과 double 타입의 읽기와 쓰기는 32비트씩 나눠 수행되어 원자적이지 않다라는 말이 나온 것이다. 
지역 변수 테이블에선 스레드별로 할당되기에 상관 없다.

### 지역 변수 테이블의 인덱스
JVM은 지역 변수 테이블을 인덱스 방식으로 이용한다. 범위는 0부터 변수 슬롯 최대 개수까지다. 
보통 0번째 인덱스엔 메서드가 속한 인스턴스의 참조인 this가 저장되고 이후 매개 변수, 지역 변수들이 저장된다. 

### 지역 변수의 유효 범위
바이트 코드 상에서 지역 변수의 유효 범위는 메서드 본문 전체가 아닐 수 있다. 
덕분에 변수 슬롯은 재사용될 수 있다. 하지만 GC의 동작에 영향을 주는 등 몇 가지 부작용이 존재한다.

부작용과 관련하여 '사용하지 않는 객체에는 수동으로 null을 할당하라'와 같은 규칙이 존재했다.
이는 코드를 작성하는 관점에서 좋지 않은 습관이자 규칙이다. 대신 **변수 범위를 적절히 지정해 변수가 회수되는 시간을 제어**하자.

## 1.2 피연산자 스택
피연산자 스택도 지역 변수 테이블과 마찬가지로 컴파일 시에 깊이가 정해진다.(Code 속성의 max_stacks)

피연산자 스택에 있는 원소의 데이터 타입은 바이트 코드 명령어의 순서와 정확히 일치해야 한다. 
때문에 컴파일러는 컴파일 시 이를 엄격하게 보장해야 하며, 클래스 검증 단계에서 데이터 흐름도 분석해야 한다.

![[JVM 8장 - 스택 프레임 데이터 공유.png]]
개념 모델에서 서로 다른 메서드의 스택 프레임들은 완전히 독립적이다. 
하지만 실제론 최적화를 위해 하부 스택 프레임의 피연산자 스택 일부를 상부 스택 프레임의 지역 변수 테이블과 겹치는 방식을 사용한다.
이를 통해 공간을 절약하고, 매개 변수로 전달할 데이터를 복사할 필요가 없게 된다.

## 1.3 동적 링크
메서드에서 이용하는 외부 객체를 가리키는 참조는 런타임 상수 풀에 담겨 있으며, 각 메서드의 스택 프레임에서 런타임 상수 풀 내의 원소를 참조하는 식으로 구성된다.
이 참조가 동적 링크를 가능하게 하는 매개체다. 여기서 참조는 아마 심볼 참조를 의미하는 듯?
심벌 참조 -> 직접 참조가 클래스 로딩 단계 또는 처음 사용될 때 변환되는 경우를 정적 해석, 실행 중에 변환되면 동적 링크

## 1.4반환 주소
JVM에서 메서드를 종료하는 방법은 두 가지다.
- **실행 엔진이 반환 바이트 코드 명령어를 만나면 메서드를 종료**(정상적인 메서드 호출 완료, 메서드 반환 명령어에 따라 반환값 O )
- **메서드 실행 도중 예외가 발생하고, 예외 처리가 제대로 이뤄지지 않으면 종료**(갑작스러운 메서드 호출 완료, 반환값 X)
둘 중 어느 방식으로 종료하든 종료 후엔 메서드를 호출한 위치로 돌아가야 한다. 
메서드가 정상 종료된 경우엔 호출자의 프로그램 카운터 값을 반환 주소로 사용할 수 있으며, 이 카운터 값은 스택 프레임에 저장될 가능성이 높다.
비정상 종료된 경우라면 예외 핸들러 테이블에 의해 반환 주소가 결정된다. 이 경우 일반적으로 스택 프레임에 정보가 저장되지 않는다. 

### 메서드 종료 과정
- 호출자의 지역 변수 테이블과 피연산자 스택을 복원
- 반환값이 있는 경우 반환값을 호출자 스택 프레임의 피연산자 스택에 푸시
- 프로그램 카운터 값을 조정하여 메서드 호출 명령어의 바로 다음 명령어를 가리킴

# 2. 메서드 호출
메서드 호출은 메서드 본문 코드를 실행하는 것이 아니다.
메서드 호출 단계에서 수행하는 **유일한 작업은 메서드 버전을 선택하는 것**이다.

## 2.1 해석
클래스 로딩 해석 단계에서 일부 심볼 참조가 직접 참조로 변환되는데, 직접 참조를 찾아낼 수 있는 전제는 다음과 같다.
- 어떤 메서드의 호출 버전을 프로그램이 실행되기 전에 알아낼 수 있으며 런타임에 다른 버전으로 변경될 수 없다. 
즉, **호출 대상 메서드가 컴파일 시 특정되는 것이고 이를 정적 해석**이라고 한다.
대표적인 예시로 private 메서드, static 메서드, 인스턴스 생성자, 부모 클래스의 메서드, final이 붙은 메서드가 존재한다.

### 메서드 호출 유형에 따른 바이트 코드 명령어
- **invokestatic**
	- 정적 메서드 호출
- **invokespecial**
	- \<init>() 메서드, private 메서드, 부모 클래스 메서드 호출
- **invokevirtual**
	- 가상 메서드 호출
- **invokeinterface**
	- 인터페이스 메서드 호출
- **invokedynamic**
	- 호출 사이트 한정자가 참조하는 메서드는 메서드 실행 전에 런타임에 동적으로 해석됨

위 내용을 종합하면 invokestatic, invokespecial은 정적 해석에 이용되는 바이트 코드 명령어다. 

## 2.2 디스패치
메서드 호출의 또 다른 형태로 디스패치라는 개념이 존재하며 아래와 같이 네 가지로 구분할 수 있다.
-> 앞선 5가지 메서드 호출 명령어와 다른 개념으로 주로 다형성과 관련되어 있음(오버 로딩, 오버 라이딩)
- **정적 단일 디스패치**
- **정적 다중 디스패치**
- **동적 단일 디스페치**
- **동적 다중 디스패치**

**해석과 디스패치는 완전 별개의 개념이 아니라 서로 다른 수준에서 대상 메서드를 검사하고 선택하는 과정**이다.
### 정적 디스패치
```java
Human man = new Man();
```
위 코드에서 Human은 겉보기 타입(정적 타입)이라고 하고, Man은 실제 타입(런타임 타입)이라고 한다. 
두 타입 모두 프로그램이 실행되는 동안에는 변경될 수 있다. 하지만 정적 타입은 변수가 사용될 때만 변경되며, 변수 자체의 정적 타입은 변하지 않는다.
```java
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
sr.sayHello((Man) human); 
sr.sayHello((Woman) human); // 실행 중에 정적 타입이 변하게 됨. 하지만 이는 컴파일 타입에 알 수 있는 변경
```

컴파일러는 sayHello가 오버로딩된 메서드이므로 컴파일 시 정적 타입을 참고해 메서드를 선택한다.
이처럼 메서드 버전 선택에 정적 타입을 참고하는 모든 디스패치 작업을 정적 디스패치라고 한다.(많은 블로그에서 정적 바인딩이라고 언급하기도 함)
오버 로딩은 그 대표적인 예시 중 하나다.

어느 한 버전을 적절히 선택할 수 없는 경우도 존재한다. 이런 경우 비교적 더 적합한 버전을 선택하게 되는데 추가로 궁금하면 412p를 참고하자.
'비교적 더 적합한 버전'을 선택하는 기준은 가장 가까운 상속 관계 순이다. 즉, 계층이 낮을수록 우선 순위가 높다.

### 동적 디스패치
동적 디스패치는 오버라이딩과 밀접하게 관련되어 있다.
즉, 실제 타입을 통해 메서드 버전을 선택하게 된다.

그렇다면 JVM이 실제 타입을 기준으로 메서드 버전을 선택해 알려주는 구체적인 방식은 무엇일까?
핵심은 invokevirtual 명령어의 런타임 해석 과정에 있다.
- 피연산자 스택 상단 첫 번째 요소가 가리키는 객체의 실제 타입을 탐색(이 타입을 C라고 가정)
- 타입 C에서 상수의 서술자 및 단순 이름과 일치하는 메서드를 찾으면 접근 권한을 검사. 권한이 없다면 IlleagalAccessError발생
- 없다면 상속 계층을 따라 아래에서 위로 C의 상위 클래스에 대해 위 과정을 반복
- 결국 못찾는다면 AbstractMethodError 발생
