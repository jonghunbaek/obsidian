동시성 문제를 제대로 처리하는 것은 많은 지식과 경험을 필요로 한다. 
다행히 Java와 JVM은 동시성 문제 해결을 위한 진입 장벽을 상당히 낮춰준다. 

# 1. 물리 머신의 메모리 모델
물리 머신에서 발생하는 동시성 문제는 가상 머신의 동시성 문제와 비슷한 점이 많다.
그러므로 해결책 또한 차용할 수 있는 경우가 많다.
![[JVM 12장 - 물리 머신 메모리 모델.png|500]]
물리 머신에서 프로세서의 연산 처리 속도는 메모리에 접근하는 속도보다 훨씬 빠르다.
이를 해결하기 위해 다음과 같은 방식들을 사용한다.
- **레지스터와 같은 캐시 계층**
	- 캐시 일관성과 같은 새로운 문제가 발생하며, 프로토콜을 활용해 이를 해결
- **비순차 실행 최적화**
	- 결과는 같지만 실제 실행 과정은 입력된 코드와 다를 수 있음

# 2. 자바 메모리 모델
## 2.1 메인 메모리와 작업 메모리
자바 메모리 모델의 주된 목적은 메모리에서 변수에 값을 저장하고 가져오는 저수준의 세세한 규칙을 정하는 것에 있다. 
→ 여기서 변수의 범위에 지역 변수, 매개 변수는 제외된다. (스레드별 고유 공간이므로 동기화가 필요 없음)
즉, **자바 메모리 모델은 스레드간 데이터 동기화를 위한 일종의 프로토콜**이라고 볼 수 있다.

![[JVM 12장 - JVM 메모리 모델.png|500]]
자바 메모리 모델은 **모든 변수가 메인 메모리(가상 머신)에 저장된다고 규정**한다. 
각 스레드는 자체 작업 메모리를 가진다. 
**작업 메모리엔 해당 스레드가 사용하는 변수의 복사본(메인 메모링 저장되어 있음)이 존재**한다. 
스레드가 변수를 읽고 쓰는 모든 연산은 작업 메모리에서 수행되며 메인 메모리의 데이터를 직접 읽고 쓸 수 없다. 
또한 스레드끼리는 서로의 작업 메모리에 있는 변수에 직접 접근할 수 없다. 

메인 메모리, 작업 메모리 각각은 물리 머신에서 하드웨어 메모리, 레지스터/캐시에 대응된다. 
실제로 성능 최적화를 위해 작업 메모리를 레지스터나 캐시에 미리 저장하기도 한다. 
## 2.2 메모리 간 상호 작용
자바 메모리 모델에서 메인 메모리와 작업 메모리 간 데이터 동기화에 대한 구체적인 방법을 다음과 같이 정의한다.
 JVM은 각 단계의 연산이 원자적으로 수행되도록 보장해야 한다. 
 - **잠금(lock)**
	 - 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만듦
 - **잠금 해제(unlock)**
	 - 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있음
 - **읽기(read)**
	 - 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 **전송**
 - **적재(load)**
	 - 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 **복사해 넣음**
 - **사용(use)**
	 - 작업 메모리의 변숫값을 실행 엔진으로 전달.
	 - VM이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행
 - **할당(assign)**
	 - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
	 - VM이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행
 - **저장(store)**
	 - 작업 메모리의 변숫값을 메인 메모리로 전송
 - **쓰기(write)**
	 - 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록

이 중 읽기/적재, 저장/쓰기는 각각 순서대로 수행되어야 한다.
하지만 순서대로만 수행된다면 사이에 다른 연산이 수행되어도 문제가 발생하지 않는다.

이러한 연산들을 수행할 때 지켜야 할 규칙들도 존재한다. 
- **읽기/적재, 저장/쓰기는 단독으로 수행될 수 없음**
- **스레드는 최근 할당 연산을 버릴 수 없음**
	- 할당이 됐다는 것은 변수의 값이 변한 것이므로 반드시 메인 메모리에 동기화 되어야 함
- **스레드는 작업 메모리의 데이터를 아무 이유 없이(할당 없이) 메인 메모리로 동기화할 수 없음**
- **변수는 메인 메모리에서만 새로 생겨날 수 있으며, 작업 메모리에 있는 초기화 되지 않은 변수를 곧바로 사용할 수 없음**
	- 변수를 사용/저장하기 전에 할당과 적재과 이뤄져야 함
- **변수는 한 번에 한 스레드만 잠글 수 있음**
- **변수를 잠그면 작업 메모리의 변숫값은 지워진다.** 
- **잠겨 있지 않은 변수나 다른 스레드가 잠근 변수에 대해서는 잠금 해제 연산을 수행할 수 없음**
- **잠금 해제를 하려면 변수를 메인 메모리에 동기화해야 함**

이 복잡하고 추상적인 규칙들을 자바 설계진에서 네 가지 유형(읽기, 쓰기, 잠금, 잠금 해제)로 단순화 했다.
→ 언어 설명 차원의 이야기이지, 실제 메모리 모델이 달라지는 것은 아님

## 2.3 volatile 변수용 특별 규칙
volatile 키워드는 JVM이 제공하는 가장 가벼운 동기화 메커니즘이다.
변수가 volatile로 정의되면 다음 두 가지 특성을 갖게 된다.
- **모든 스레드에서 이 변수를 투명하게 볼 수 있음**
- **명령어 재정렬 최적화를 방지**
### 모든 스레드에서 변수를 투명하게 볼 수 있음
이 말은 다른 말로 '가시성을 보장한다'라고 할 수 있다. 
작업 메모리에서 volatile 변수의 일관성은 문제가 없지만 **자바의 산술 연산자가 원자적이지 않아 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하진 않다.**
```java
public stataic volatile int race = 0;

public static void increase() {
	race++;
}
```
이 자바 코드는 컴파일 후 5줄의 바이트코드로 파싱된다. 이 과정에서 값을 가져오고, 갱신하기 때문에 일관성이 깨질 수 있다. 

**이러한 특징을 가진 volatile 변수는 가시성만 보장한다고 볼 수 있다.** 
때문에 다음 두 규칙을 충족할 때만 volatile은 멀티스레드 환경에서 안전하다고 말할 수 있다. 
- **연산 결과가 변수의 현재 값과는 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장**
- **다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않음**
-> 무슨 말인지 검색 필요