---
플랫폼: 프로그래머스
문제 이름: 메뉴 리뉴얼
알고리즘: 재귀, 정렬
tags:
  - 재귀
  - 정렬
date: 2025-08-12
aliases:
  - 재귀
복습 풀이: 250812(X), 250818(O), 250823(O), 250830(O), 250906(O), 251027(O)
---
# 1차 풀이
```java
import java.util.*;
import java.util.stream.*;

// 1. course를 순회하며 코스 메뉴의 개수를 파악
// 2. 개수에 따라 orders를 순회
// 3. 하나의 order에서 개수에 맞는 조합을 모두 찾아 Map에 저장
// 4. 한 코스에 대한 모든 조합이 Map 저장되고, 가장 많이 주문된 조합을 결과 List에 저장
//  4-1. 이 때,  주문 최대 횟수가 동일하다면 동일한 값 모두 저장
// 5. 결과 List를 사전순으로 정렬하여 반환
class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> countByMenu = new HashMap<>();
            for (int i = 0; i < orders.length; i++) {
                combineMenu(0, size, orders[i], new HashSet<>(), countByMenu);
            }

            int max = countByMenu.values().stream()
                 .mapToInt(i -> i)
                 .max()
                 .orElse(0);

            
            if (max >= 2) {
                 List<String> menus = countByMenu.entrySet().stream()
                     .filter(entry -> entry.getValue() == max)
                     .map(Map.Entry::getKey)
                     .collect(Collectors.toList());

                 results.addAll(menus);
            }
        }

        results.sort(String::compareTo);

        return results.toArray(String[]::new);
    }

    private void combineMenu(int depth, int size, String order, Set<String> target, Map<String, Integer> countByMenu) {
        if (target.size() == size) {
            String value = target.stream()
                    .sorted()
                    .collect(Collectors.joining());

            countByMenu.put(value, countByMenu.getOrDefault(value, 0) + 1);
            return;
        }

        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            combineMenu(i + 1, size, order, target, countByMenu);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }

}
```
이해하고 보니 어렵지 않은 문제.
하지만 카카오답게 놓칠 수 있는 여러 조건이 존재했음.
일단 가장 애먹었던 부분은 메뉴에서 가장 많이 존재하는 메뉴 조합을 찾는 것이었음
단순한 재귀로 풀다가 애를 많이 먹음.
이건 별도로 정리할 필요가 있음

# 2차 풀이
```java
// 1. 문제의 조건을 확인해보면 시간복잡도는 충분함
//  orders최대 20, 각 원소 크기 최대 10 -> 10의 제곱 * 20
// 2. orders를 course의 원소 크기만큼을 종료조건 삼아 재귀 탐색하며 Map에 키(메뉴조합), 값(주문횟수) 형태로 저장
// 3. course 원소 크기별로 최대 주문 횟수를 찾아 해당 값을 결과 List에 저장
// 4. course 원소 크기에 해당하는 주문 개수가 없다면 0을 반환
import java.util.*;
import java.util.stream.*;

class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> countByMenus = new HashMap<>();
            for (String order : orders) {
                String menus = order.chars()
                    .mapToObj(c -> (char) c)
                    .sorted((c1, c2) -> c1.compareTo(c2))
                    .map(c -> String.valueOf(c))
                    .collect(Collectors.joining());
                
                countMenuOrder(0, new ArrayList<>(), menus, size, countByMenus);
            }
            
            int max = countByMenus.entrySet().stream()
                .filter(entry -> entry.getValue() > 1)
                .mapToInt(entry -> entry.getValue())
                .max()
                .orElse(0);
            
            List<String> result = countByMenus.entrySet().stream()
                .filter(entry -> entry.getValue() == max)
                .map(entry -> entry.getKey())
                .collect(Collectors.toList());
            
            results.addAll(result);
        }
        
        return results.stream()
            .sorted((s1, s2) -> s1.compareTo(s2))
            .toArray(String[]::new);
    }
    
    private void countMenuOrder(int depth, List<String> target, String order,int size, Map<String, Integer> countByMenus) {
        if (target.size() == size) {
            String key = String.join("", target);
            countByMenus.put(key, countByMenus.getOrDefault(key, 0) + 1);
            return;
        }
        
        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            countMenuOrder(i + 1, target, order, size, countByMenus);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }
}
```
무난하게 풀었지만 input으로 주어지는 orders의 각 원소들이 처음부터 정렬되어 있지 않다는 사실을 놓쳤음
이전엔 Set을 활용하고, 종료 조건에서 정렬을 별도로 해줘 정답을 도출했다면 이번엔 List를 사용해 미리 input값을 정렬함

# 3차 풀이
```java
class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> menus = new HashMap<>();
            for (String order : orders) {
                countMenu(new HashSet<>(), 0, size, order, menus);
            }
            
            int max = menus.values().stream()
                .mapToInt(Integer::intValue)
                .max()
                .orElse(0);
            
            if (max < 2) {
                continue;
            }
            
            List<String> values = menus.entrySet().stream()
                .filter(entry -> entry.getValue() >= max)
                .map(entry -> entry.getKey())
                .collect(Collectors.toList());
            
            if (values.isEmpty()) {
                continue;
            }
            
            results.addAll(values);
        }
        
        return results.stream()
            .sorted()
            .toArray(String[]::new);
    }
    
    private void countMenu(Set<String> target, int depth, int size, String order, Map<String, Integer> menus) {
        if (target.size() == size) {
            String menu = target.stream()
                .sorted()
                .collect(Collectors.joining());
            menus.put(menu, menus.getOrDefault(menu, 0) + 1);
            return;
        }
        
        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            countMenu(target, i + 1, size, order, menus);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }
}
```
이젠 익숙해져서 쉽게 풀 수 있으나 여전히 고민해볼 포인트들이 꽤 있음
특히 재귀 방식에 대한 숙련도가 높아져야 함
- **하나의 배열에서 모든 조합 구하기**
- **시간 복잡도 계산**

# 4차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> countByMenus = new HashMap<>();
            for (String order : orders) {
                countOrderByMenu(0, new HashSet<>(), order, size, countByMenus);
            }
            
            int max = countByMenus.values().stream()
                .mapToInt(Integer::intValue)
                .max()
                .orElse(0);
            
            if (max < 2) {
                continue;
            }
            
            List<String> menus = countByMenus.entrySet().stream()
                .filter(entry -> entry.getValue() == max)
                .map(entry -> entry.getKey())
                .collect(Collectors.toList());
            
            results.addAll(menus);
        }
        
        return results.stream()
            .sorted()
            .toArray(String[]::new);
    }
    
    private void countOrderByMenu(int depth, Set<String> target, String order, int size, Map<String, Integer> countByMenus) {
        if (target.size() == size) {
            String value = target.stream()
                .sorted()
                .collect(Collectors.joining());
            
            countByMenus.put(value, countByMenus.getOrDefault(value, 0) + 1);
            return;
        }
        
        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            countOrderByMenu(i + 1, target, order, size, countByMenus);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }
}
```

# 5차 풀이
```java
// 1. course 배열을 순회
// 2. course 배열 원소에 따라 orders를 완탐하며 주문 조합 구하기
// 3. 가장 많이 주문된 조합을 결과 List에 넣기
//  3-1. 이 때 주문은 최소 2번 이상 되어야 하며, 해당하는 주문 조합이 없다면 건너뛰기
class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> menus = new HashMap<>();
            for (String order : orders) {
                countByMenu(0, new HashSet<>(), size, order, menus);    
            }
            
            int max = menus.values().stream()
                .mapToInt(Integer::intValue)
                .filter(val -> val > 1)
                .max()
                .orElse(0);
            
            List<String> values = menus.entrySet().stream()
                .filter(entry -> entry.getValue() == max)
                .map(entry -> entry.getKey())
                .collect(Collectors.toList());
            
            results.addAll(values);
        }
        return results.stream()
            .sorted()
            .toArray(String[]::new);
    }
    
    private void countByMenu(int depth, Set<String> target, int size, String order, Map<String, Integer> menus) {
        if (target.size() == size) {
            String key = target.stream()
                .sorted()
                .collect(Collectors.joining());
            
            menus.put(key, menus.getOrDefault(key, 0) + 1);
            return;
        }
        
        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            countByMenu(i + 1, target, size, order, menus);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }
}
```

# 6차 풀이
```java
// 1. 코스 요리 개수마다 맞는 메뉴 조합을 재귀 탐색으로 카운팅
// 2. 카운팅 결과를 Map에 담음(메뉴조합이름, 주문 횟수)
// 3. Map을 주문 횟수 기준 내림차순 정렬
// 4. 가장 많이 주문된 메뉴, 또는 동일한 주문횟수를 가진 메뉴조합을 선별(최소 2번이상)
// 5. 해당 조합을 결과 List에 넣고 배열로 변환해 반환
import java.util.*;
import java.util.stream.*;

class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> countByMenu = countMenu(orders, size);
            
            int max = countByMenu.values().stream()
                .mapToInt(Integer::intValue)
                .max()
                .orElse(0);
        
            if (max < 2) continue;
            List<String> menus = countByMenu.entrySet().stream()
                .filter(entry -> entry.getValue() == max)
                .map(entry -> entry.getKey())
                .collect(Collectors.toList());
            
            results.addAll(menus);
        }
    
        return results.stream()
            .sorted()
            .toArray(String[]::new);
    }
    
    private Map<String, Integer> countMenu(String[] orders, int size) {
        Map<String, Integer> countByMenu = new HashMap<>();        
        
        for (String order : orders) {
            countMenuByOrder(0, new HashSet<>(), size, order, countByMenu);
        }
        
        return countByMenu;
    }
    
    private void countMenuByOrder(int idx, Set<String> target, int size, String order, Map<String, Integer> countByMenu) {
        if (target.size() == size) {
            String menu = target.stream()
                .sorted()
                .collect(Collectors.joining());
            
            countByMenu.put(menu, countByMenu.getOrDefault(menu, 0) + 1);
            return;
        }
        
        for (int i = idx; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            countMenuByOrder(i + 1, target, size, order, countByMenu);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }
}
```