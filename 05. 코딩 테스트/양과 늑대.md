---
플랫폼: 프로그래머스
문제 이름: 양과 늑대
알고리즘: 재귀, DFS, 이진트리
tags:
  - 이진탐색
  - 재귀
  - 구현
date: 2025-12-02
aliases:
복습 풀이: 251202()
---
# 1차 풀이
```java
// 1. 노드의 최대 개수는 17개이며, 정확성 테스트 인것으로 미뤄봤을 때 완탐으로 구현
// 2. 상세 구현
//  2-1. 파라미터로 받은 info, edges를 Node 객체로 변환하며, 자식-부모 관계 설정
//  2-2. 노드는 재방문이 가능하나 이미 방문한 곳에서 양/늑대를 획득할 수 없음
//  2-3. 재귀 탐색하며, 늑대 마리 수가 양의 마리 수 이상이되면 종료
class Solution {
    public int solution(int[] info, int[][] edges) {
        Node[] nodes = new Node[info.length];
        for (int i = 0; i < info.length; i++) {
            nodes[i] = new Node(i, info[i]);
        }
        
        for (int[] edge : edges) {
            int parentIdx = edge[0];
            int childIdx = edge[1];
            Node parent = nodes[parent];
            Node child = nodes[childIdx];
            if (parent.left == null) {
                parent.left = nodes[childIdx];
                continue;
            } 
            
            if (parent.left.no < child.no) {
                parent.right = child;
            } else {
                parent.right = parent.left;
                parent.left = child;
            }
        }
        
        Shepherd boy = new Shepherd();
        
        dfs(0, boy, nodes);
        
        return boy.maxSheepCount;
    }
    
    static class Shepherd {
        private int maxSheepCount;
        private int sheepCount;
        private int wolfCount;
    }
    
    static class Node {
        private int no;
        private boolean isSheep;
        private Node left;
        private Node right;
        
        public Node(int no, int isSheep) {
            this.no = no;
            this.isSheep = isSheep == 0 ? true : false;
        }
    }
}
```