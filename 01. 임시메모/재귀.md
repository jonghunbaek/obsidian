재귀에 대해 충분히 이해했다고 생각했음에도 매번 문제 풀이에 실패해 왜 실패하는지 분석하며 정리해본다.

# 1. 재귀의 종류
재귀의 종류란 일반적으로 존재하지 않는 개념이다.
다만 코딩 테스트 문제를 풀어보며 상황에 따라 재귀를 다음처럼 구분해 볼 수 있었다.
- **순열 (Permutation)**: N개 중 M개를 **순서대로** 나열하기
- **조합 (Combination)** : N개 중 M개를 **순서 없이** 뽑기
- **중복 순열 (Permutation with Repetition)**: N개 중 M개를 **중복을 허용**하여 **순서대로** 나열하기
- **중복 조합 (Combination with Repetition)**: N개 중 M개를 **중복을 허용**하여 **순서 없이** 뽑기

이 종류들 모두 조건이 정적이라면 단순히 반복문을 실행하면 된다.
예를 들어, [[교점에 별만들기(배열, 구현)]] 문제에서 교점을 구하는 과정이 이와 같다. 

하지만 반복문 중첩 횟수가 동적으로 변경된다면 재귀 함수를 활용할 수 밖에 없다. 
재귀 함수의 경우 인자로 넘겨주는 파라미터에 따라 위와 같은 종류로 구분해볼 수 있었다.

# 2. 종류별 재귀 구현 방법
### 순열
- **핵심** : 순서가 중요하므로 `[A, B]`와 `[B, A]`는 다른 경우다. 한 번 사용한 원소는 현재 만들고 있는 순열 내에서 다시 사용하면 안된다.
- **구현 패턴**: `visited` 배열을 사용해 **원소의 중복 사용을 방지**하는 것이 핵심.
```java
// N개의 원소 중 M개를 뽑아 나열하는 순열
void permutation(int depth, int[] result, boolean[] visited, int[] arr) {
    // M개를 모두 뽑았다면 종료
    if (depth == M) {
        // 결과 처리 로직 ...
        return;
    }

    for (int i = 0; i < N; i++) {
        // 아직 사용하지 않은 원소라면
        if (!visited[i]) {
            visited[i] = true;      // 사용했다고 표시 (핵심 1)
            result[depth] = arr[i]; // 결과 배열에 담기
            permutation(depth + 1, result, visited, arr); // 다음 자릿수 뽑으러 이동
            visited[i] = false;     // 백트래킹: 다음 탐색을 위해 사용 표시 해제 (핵심 2)
        }
    }
}
```

### 조합
- **핵심 아이디어**: 순서가 중요하지 않으므로 `{A, B}`와 `{B, A}`는 같은 경우다. 이러한 중복을 피하기 위해 **오름차순으로만 원소를 뽑도록 강제**한다.
- **구현 패턴**: 재귀 호출 시 다음 탐색을 시작할 인덱스(`start`)를 넘겨줘, **현재 뽑은 원소의 뒤에 있는 원소들만 보도록 제한**하는 것이 핵심. 
- **예시 문제**: **[[메뉴 리뉴얼]]**, **[[불량 사용자]]**

```java
// N개의 원소 중 M개를 순서 없이 뽑는 조합
// dfs(뽑은 개수, 탐색 시작 인덱스, ...)
void combination(int depth, int start, int[] result, int[] arr) {
    // M개를 모두 뽑았다면 종료
    if (depth == M) {
        // 결과 처리 로직 ...
        return;
    }

    // 탐색 시작 인덱스(start)부터 순회 (핵심 1)
    for (int i = start; i < N; i++) {
        result[depth] = arr[i];
        // 다음 원소는 현재 뽑은 것(i) 다음부터(i + 1) 뽑도록 함 (핵심 2)
        combination(depth + 1, i + 1, result, arr);
    }
}
```

### 중복 순열
- **핵심 아이디어**: 순열처럼 순서가 중요하지만(`[A, A, B]` ≠ `[A, B, A]`), **한 번 사용했던 원소를 다시 사용할 수 있다.** 네 가지 패턴 중 제약 조건이 가장 적어 가장 단순한 형태.
- **구현 패턴**: 각 자리에 올 수 있는 원소를 결정할 때, 아무런 제약 없이 **매번 모든 원소(0번부터 N-1번까지)**를 후보로 탐색합니다. `visited` 배열이나 `start` 인덱스가 모두 필요 없음.
- **예시 문제**: **[[모음 사전]]** (A, E, I, O, U 5개의 문자를 중복 사용해 만들 수 있는 모든 단어를 나열하는 문제)
```java
// N개의 원소 중 M개를 중복을 허용하여 순서대로 나열하는 중복 순열
void permutationWithRepetition(int depth, char[] result, char[] arr) {
    // M개를 모두 뽑았다면 종료
    if (depth == M) {
        // 결과 처리 로직 ...
        return;
    }

    // 아무 제약 없이 0번부터 N-1번까지 모든 원소를 탐색 (핵심)
    for (int i = 0; i < N; i++) {
        result[depth] = arr[i]; // 현재 자리에 원소를 담고
        permutationWithRepetition(depth + 1, result, arr); // 다음 자리를 뽑으러 이동
    }
}
```

### 중복 조합
- **핵심 아이디어**: 조합과 동일하게 순서가 중요하지 않지만, **한 번 뽑았던 원소를 다시 뽑을 수 있다.**
- **구현 패턴**: 조합 코드와 거의 동일하지만, 다음 재귀 호출 시 시작 인덱스를 `i + 1`이 아닌 **`i`**로 넘겨 **자기 자신을 다시 뽑을 수 있도록 허용**하는 것이 핵심.

```java
// N개의 원소 중 M개를 중복을 허용하여 순서 없이 뽑는 중복 조합
void combinationWithRepetition(int depth, int start, int[] result, int[] arr) {
    if (depth == M) {
        // 결과 처리 로직 ...
        return;
    }

    for (int i = start; i < N; i++) {
        result[depth] = arr[i];
        // 다음 탐색에 자기 자신(i)도 포함 (핵심)
        combinationWithRepetition(depth + 1, i, result, arr);
    }
}
```

### 기타
위 네 가지 분류에 해당하지 않는 재귀의 종류도 존재
[[순위 검색]]에서 지원자의 조건을 조합하는 재귀가 이에 해당한다. 
N개중 M개를 뽑지 않고, 고정된 4자리에서 기존 값과 "-" 값 중 하나를 선택하는 모든 경우의 수를 구하기 때문이다.
즉, 여러 개의 독립적인 사건이 만들어낼 수 있는 모든 경우의 수를 찾는 것이다.