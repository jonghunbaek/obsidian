---
플랫폼: 프로그래머스
알고리즘: 구현
tags:
  - 구현
date: 2025-12-24
복습 풀이: 251224(X), 251229(O)
---
# 1차 풀이
```java
public int solution(int[] bandage, int health, int[][] attacks) {  
    int remainHealth = health;  
    int previousTime = 0;  
    int castingTime = bandage[0];  
    int healPerSec = bandage[1];  
    int additionalHeal = bandage[2];  
    for (int[] attack : attacks) {  
        int time = attack[0];  
        int damage = attack[1];  
  
        int diff = time - previousTime;  
        if (remainHealth < health) {  
            int healValue = calculateHealValue(diff, castingTime, healPerSec, additionalHeal);  
            remainHealth = Math.min(healValue + remainHealth, health);  
        }  
  
        remainHealth -= damage;  
        previousTime = time + 1;  
  
        if (remainHealth <= 0) {  
            return -1;  
        }  
    }  
  
    return remainHealth;  
}  
  
private int calculateHealValue(int diff, int castingTime, int healPerSec, int additionalHeal) {  
    int value = diff / castingTime;  
    int remain = diff % castingTime;  
  
    if (value > 0) return value * (castingTime * healPerSec + additionalHeal) + (remain * healPerSec);  
    return diff * healPerSec;  
}
```

발견하지 못했던 엣지 케이스
- 이전 시간과 공격 시간의 차이가 시전 시간의 배수인 경우
- 남은 세개는 찾지 못함
	- 회복량 계산 부분에서 몫만 계산해주고, 나머지는 계산하지 않은 것이 문제였음
	- `if (value > 0) return value * (castingTime * healPerSec + additionalHeal) + (remain * healPerSec)
# 2차 풀이
```java
class Solution {
    public int solution(int[] bandage, int health, int[][] attacks) {
        int remainHealth = health;
        int castingTime = bandage[0];
        int healingPerSec = bandage[1];
        int additionalHealing = bandage[2];
        int currentSec = 0;
        
        for (int[] attack : attacks) {
            int attackTime = attack[0];
            int dealing = attack[1];
            int healingValue = calculateHealingValue(currentSec, attackTime, bandage);
            
            if (healingValue + remainHealth > health) {
                remainHealth = health;
            } else {
                remainHealth += healingValue;
            }
            
            remainHealth -= dealing;
            currentSec = attackTime;
            
            if (remainHealth <= 0) return -1;
        }
        
        return remainHealth;
    }
    
    private int calculateHealingValue(int currentSec, int attackTime, int[] bandage) {
        int castingTime = bandage[0];
        int healingPerSec = bandage[1];
        int additionalHealing = bandage[2];
        
        int diff = attackTime - 1 - currentSec;
        if (diff / castingTime >= 1) {
            int time = diff / castingTime;
            int mod = diff % castingTime;
            
            return (time * (castingTime * healingPerSec + additionalHealing)) + mod * healingPerSec;
        } else {
            return diff * healingPerSec;
        }
    }
}
```