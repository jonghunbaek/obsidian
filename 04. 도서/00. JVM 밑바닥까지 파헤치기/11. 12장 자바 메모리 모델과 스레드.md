동시성 문제를 제대로 처리하는 것은 많은 지식과 경험을 필요로 한다. 
다행히 Java와 JVM은 동시성 문제 해결을 위한 진입 장벽을 상당히 낮춰준다. 

# 1. 물리 머신의 메모리 모델
물리 머신에서 발생하는 동시성 문제는 가상 머신의 동시성 문제와 비슷한 점이 많다.
그러므로 해결책 또한 차용할 수 있는 경우가 많다.
![[JVM 12장 - 물리 머신 메모리 모델.png|500]]
물리 머신에서 프로세서의 연산 처리 속도는 메모리에 접근하는 속도보다 훨씬 빠르다.
이를 해결하기 위해 다음과 같은 방식들을 사용한다.
- **레지스터와 같은 캐시 계층**
	- 캐시 일관성과 같은 새로운 문제가 발생하며, 프로토콜을 활용해 이를 해결
- **비순차 실행 최적화**
	- 결과는 같지만 실제 실행 과정은 입력된 코드와 다를 수 있음

# 2. 자바 메모리 모델
## 2.1 메인 메모리와 작업 메모리
자바 메모리 모델의 주된 목적은 메모리에서 변수에 값을 저장하고 가져오는 저수준의 세세한 규칙을 정하는 것에 있다. 
→ 여기서 변수의 범위에 지역 변수, 매개 변수는 제외된다. (스레드별 고유 공간이므로 동기화가 필요 없음)
즉, **자바 메모리 모델은 스레드간 데이터 동기화를 위한 일종의 프로토콜**이라고 볼 수 있다.

![[JVM 12장 - JVM 메모리 모델.png|500]]
자바 메모리 모델은 **모든 변수가 메인 메모리(가상 머신)에 저장된다고 규정**한다. 
각 스레드는 자체 작업 메모리를 가진다. 
**작업 메모리엔 해당 스레드가 사용하는 변수의 복사본(메인 메모링 저장되어 있음)이 존재**한다. 
스레드가 변수를 읽고 쓰는 모든 연산은 작업 메모리에서 수행되며 메인 메모리의 데이터를 직접 읽고 쓸 수 없다. 
또한 스레드끼리는 서로의 작업 메모리에 있는 변수에 직접 접근할 수 없다. 

메인 메모리, 작업 메모리 각각은 물리 머신에서 하드웨어 메모리, 레지스터/캐시에 대응된다. 
실제로 성능 최적화를 위해 작업 메모리를 레지스터나 캐시에 미리 저장하기도 한다. 
## 2.2 메모리 간 상호 작용
자바 메모리 모델에서 메인 메모리와 작업 메모리 간 데이터 동기화에 대한 구체적인 방법을 다음과 같이 정의한다.
 JVM은 각 단계의 연산이 원자적으로 수행되도록 보장해야 한다. 
 - **잠금(lock)**
	 - 메인 메모리에 존재하는 변수를 특정 스레드만 사용할 수 있는 상태로 만듦
 - **잠금 해제(unlock)**
	 - 잠금이 해제된 변수는 다른 스레드에 의해 잠길 수 있음
 - **읽기(read)**
	 - 메인 메모리의 변숫값을 특정 스레드의 작업 메모리로 **전송**
 - **적재(load)**
	 - 읽기 연산으로 메인 메모리에서 얻어온 값을 작업 메모리의 변수에 **복사해 넣음**
 - **사용(use)**
	 - 작업 메모리의 변숫값을 실행 엔진으로 전달.
	 - VM이 변숫값을 사용하는 바이트코드 명령어를 만날 때마다 실행
 - **할당(assign)**
	 - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당
	 - VM이 변수에 값을 할당하는 바이트코드 명령어를 만날 때마다 실행
 - **저장(store)**
	 - 작업 메모리의 변숫값을 메인 메모리로 전송
 - **쓰기(write)**
	 - 저장 연산으로 작업 메모리에서 얻어온 값을 메인 메모리의 변수에 기록

이 중 읽기/적재, 저장/쓰기는 각각 순서대로 수행되어야 한다.
하지만 순서대로만 수행된다면 사이에 다른 연산이 수행되어도 문제가 발생하지 않는다.

이러한 연산들을 수행할 때 지켜야 할 규칙들도 존재한다. 
- **읽기/적재, 저장/쓰기는 단독으로 수행될 수 없음**
- **스레드는 최근 할당 연산을 버릴 수 없음**
	- 할당이 됐다는 것은 변수의 값이 변한 것이므로 반드시 메인 메모리에 동기화 되어야 함
- **스레드는 작업 메모리의 데이터를 아무 이유 없이(할당 없이) 메인 메모리로 동기화할 수 없음**
- **변수는 메인 메모리에서만 새로 생겨날 수 있으며, 작업 메모리에 있는 초기화 되지 않은 변수를 곧바로 사용할 수 없음**
	- 변수를 사용/저장하기 전에 할당과 적재과 이뤄져야 함
- **변수는 한 번에 한 스레드만 잠글 수 있음**
- **변수를 잠그면 작업 메모리의 변숫값은 지워진다.** 
- **잠겨 있지 않은 변수나 다른 스레드가 잠근 변수에 대해서는 잠금 해제 연산을 수행할 수 없음**
- **잠금 해제를 하려면 변수를 메인 메모리에 동기화해야 함**

이 복잡하고 추상적인 규칙들을 자바 설계진에서 네 가지 유형(읽기, 쓰기, 잠금, 잠금 해제)로 단순화 했다.
→ 언어 설명 차원의 이야기이지, 실제 메모리 모델이 달라지는 것은 아님

## 2.3 volatile 변수용 특별 규칙
volatile 키워드는 JVM이 제공하는 가장 가벼운 동기화 메커니즘이다.
volatile로 선언된 변수의 읽기 성능은 일반 변수와 비슷하지만 쓰기는 더 느릴 수 있다. 
➡️ 명령어 재정렬을 방지하기 위해 네이티브 코드에 메모리 장벽 명령어를 다수 삽입하기 때문
변수가 volatile로 정의되면 다음 두 가지 특성을 갖게 된다.
- **모든 스레드에서 이 변수를 투명하게 볼 수 있음**
- **명령어 재정렬 최적화를 방지**
### 모든 스레드에서 변수를 투명하게 볼 수 있음
이 말은 다른 말로 '가시성을 보장한다'라고 할 수 있다. 
작업 메모리에서 volatile 변수의 일관성은 문제가 없지만 **자바의 산술 연산자가 원자적이지 않아 volatile 변수라도 멀티스레드 환경에서 완벽하게 안전하진 않다.**
```java
public stataic volatile int race = 0;

public static void increase() {
	race++;
}
```
이 자바 코드는 컴파일 후 5줄의 바이트코드로 파싱된다. 이 과정에서 값을 가져오고, 갱신하기 때문에 일관성이 깨질 수 있다. 

**이러한 특징을 가진 volatile 변수는 가시성만 보장한다고 볼 수 있다.** 
때문에 다음 두 규칙을 충족할 때만 volatile은 멀티스레드 환경에서 안전하다고 말할 수 있다. 
- **연산 결과가 변수의 현재 값과는 무관하거나 변수의 값을 수정하는 스레드가 하나뿐임을 보장**
	- 즉, 연산에 현재의 값이 필요한 경우라고 볼 수 있음
- **다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않음**
	- 다른 상태 변수들과 논리적으로 묶이지 않아야 함

### 명령어 재정렬 최적화 방지
명령어 재정렬은 동시성 프로그래밍에서 가장 혼란스러운 영역이다. 
다음 예제를 통해 volatile 키워드가 명령어 재정렬을 막는 방식을 알아보자.
```java
public class Singlton {
	private volatile static Singleton instance;

	public static Singleton getInstance() {
		if (instance == null) {https://netflixtechblog.com/active-active-for-multi-regional-resiliency-c47719f6685b
			syncronized (Singleton.class) {
				if (instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}

	public static void main(String[] args) {
		Singleton.getInstance();
	}
}
```
이 코드가 컴파일 되면 volatile 때문에 'lock addl $0x0, ( %esp)' 작업이 추가로 수행된다. 
이 작업은 메모리 장벽과도 같은 기능을 하는데, 장벽 뒤의 명령어를 장벽 앞으로 재정렬할 수 없도록 만든다.
addl $0x0, ( %esp) 명령은 ESP 레지스터 값에 0을 추가하라는 뜻이며, 노옵을 뜻한다. 
**lock 접두어는 프로세서의 캐시를 메인 메모리에 쓰는 기능을 하며, 다른 프로세서가 자신의 캐시를 무효화하게 한다.** 
그러므로 이 노옵 명령 덕분에 이전 volatile 변수의 수정 사항을 다른 프로세서에서 즉시 볼 수 있다. 
더불어, 이 명령어가 수행 되어 메모리에 동기화할 때는 **이전의 모든 작업이 수행 되었음을 뜻**하므로 이 명령어 앞으로 재정렬을 할 수 없게 되는 효과도 존재한다.

>[!노옵]
>노옵이란  아무 일도 하지 않는 명령이란 뜻이다. 

>[!volatile의 메모리 장벽]
>해당 답변은 GPT 답변이므로 검증이 필요함.
>책에선 addl $0x0, ( %esp) 명령어 자체에 힘을 실어 설명했지만 GPT에선 lock 접두어에 집중했다.
>현대 CPU의 내부 구조가 x86 아키텍처일 때, lock 명령어를 발견하면 해당 명령어 앞의 모든 적재/저장이 반드시 수행되도록 강제한다. 
>즉, lock 접두어가 붙은 경우 해당 명령어 앞의 모든 명령어 수행을 끝낸다고 볼 수 있다.

## 2.4 long과 double 변수용 특별 규칙
64비트 데이터 타입인 두 키워드는 가상 머신에 따라 원자성이 보장될 수도 안될 수도 있다. 
64비트 상용 가상머신에선 원자적이지 않아도 데이터가 반만 수정되는 이상 현상은 거의 발생하지 않는다.
하지만 32비트 JVM에선 long 타입 데이터를 비원자적으로 처리할 위험이 존재한다. 
## 2.5 자바 메모리 모델의 주요 특징
### 원자성
자바 메모리 모델이 직접 보장하는 원자적 연산은 다음과 같다.
- 읽기
- 적재
- 할당
- 사용
- 저장
- 쓰기
잠금/잠금 해제 연산은 애플리케이션 수준에서 원자성을 더 넓은 범위로 제공하기 위해 사용된다. 
다만 사용자에게 직접 제공하지는 않고, 바이트 코드 명령어 monitorenter와 monitorexit을 이용 하도록 한다. 
➡️ syncronized 키워드로 사용된 블록
### 가시성
volatile은 자바에서 가시성을 보장하는 키워드다. 
volatile로 선언된 변수는 일반 변수와 달리 새로운 값을 즉시 메모리로 동기화하고, 이를 사용할 때마다 즉시 메인 메모리에서 새로 고치도록 한다. 
➡️ 일반 변수도 이러한 과정을 수행하긴 하지만 항상/즉시 수행되진 않음

volatile외에도 syncronized와 final 또한 가시성을 보장한다.
syncronized 블록의 가시성은 '**변수의 잠금을 해제하기 전에 변수의 값을 메인 메모리로 다시 동기화해야 한다**'는 규칙으로 확보된다.
final 키워드의 가시성은 final로 선언된 변수가 생성자에서만 초기화 된다는 규칙으로 확보된다.
➡️ 생성이 완벽하게 끝나지 않은 객체의 참조를 다른 스레드에 전달할 수 없음
### 실행 순서
자바 프로그램의 명령어 실행 순서는 다음처럼 요약할 수 있다.
```text
현재 스레드에서 보면 모든 연산이 순서대로 수행된다. 하지만 다른 스레드에서 보면 순서가 다를 수 있다.
```
여기서 두 번째 문장은 '명령어 재정렬'과 '작업 메모리와 메인 메모리 사이의 동기화 지연 현상'을 의미한다. 

## 2.6 선 발생 원칙
선 발생 원칙은 데이터 경합 발생 여부와 스레드 안정성을 확인하는 데 매우 유용한 수단이다.
즉, 몇 가지 간단한 규칙으로 자바 메모리 모델의 복잡한 정의에 얽매이지 않을 수 잇다. 

선 발생 원칙에서 '선 발생'은 자바 메모리 모델에서 정의된 두 작업의 수행 순서 관계를 말한다. 
a, b 두 작업이 존재하고, a가 b보다 선 발생했다면 작업 b가 수행되기 전에 작업 a의 수행 결과를 작업 b에서 관찰할 수 있다.

다음은 자연스러운 선 발생 관계다. 동기화 장치의 지원 없이 이루어지며, 코드에서 활용할 수 있다.
만약 **두 작업 사이의 관계가 다음 목록에 없고, 이로부터 추론할 수도 없다면** 이는 **JVM에서 명령어 순서를 마음대로 바꿀 수 있다는 뜻**이다.
- **프로그램 순서 규칙**
	- 한 스레드 안에서는 '제어 흐름 순서'에 따라 앞의 연산이 뒤따르는 연산보다 선 발생한다. 
- **모니터 락 규칙**
	- 잠금 해제 연산은 '같은 락'에 대한 잠금 연산보다 선 발생한다. 순서는 시간 순서다.
- **휘발성 변수 규칙**
	- volatile 변수의 쓰기 연산은 같은 변수에 대한 읽기 연산보다 선 발생한다. 순서는 시간 순서다.
- **스레드 시작 규칙**
	- Thread 객체의 start()메서드는 해당 스레드의 어떤 작업보다도 선 발생한다.
- **스레드 종료 규칙**
	- 스레드의 모든 작업은 해당 스레드의 종료 감지보다 선 발생한다.
- **스레드 인터럽트 규칙**
	- Thread의 interrupt() 메서드 호출은 인터럽트되는 스레드가 인터럽트 이벤트 발생 감지보다 선 발생한다.
- **종료자 규칙**
	- 객체 초기화는 finalize()메서드 시작 보다 선 발생한다.
- **전이성**
	- 연산 a가 연산 b보다 선 발생하고, 연산 b가 연산 c보다 선 발생한다면 연산 a가 c보다 선 발생한다고 결론지을 수 있다.