---
플랫폼: 프로그래머스
문제 이름: 정수 삼각형
알고리즘: dp
tags:
  - dp
date: 2025-08-25
aliases:
  - dp
복습 풀이: 250825(O), 250830(O), 250906(O), 250913(O), 250919(O), 251003(O), 251029(O), 251101(O)
---
# 1차 풀이
```java
// 1. 완탐을 할 경우 2의 500승으로 무조건 시간 초과
// 2. DP를 사용해야 함
// 3. 이동 가능한 값은 아래와 오른쪽 아래
// 4. 두 방향에서 진입 가능하면 둘 중 큰 값을 대입
// 7
// 3 8
// 8 1 0
// 2 7 4 4
// 4 5 2 6 5

class Solution {
    public int solution(int[][] triangle) {
        int y = triangle.length;
        int x = triangle[triangle.length - 1].length;
        int[][] dp = new int[y][x];
        for (int i = 0; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {
                dp[i][j] = triangle[i][j];
            }
        }
    
        for (int i = 1; i < dp.length; i++) {
            for (int j = 0; j < dp[i].length; j++) {
                if (j - 1 < 0) {
                    dp[i][j] = dp[i - 1][j] + dp[i][j];
                    continue;
                }
                
                dp[i][j] = Math.max(dp[i - 1][j] + dp[i][j], dp[i - 1][j - 1] + dp[i][j]);
            }
        }
        
        int max = 0;
        for (int i = 0; i < dp[0].length; i++) {
            max = Math.max(max, dp[dp.length - 1][i]);
        }
        
        return max;
    }
}
```
생각보다 어렵지 않게 풀었음. 
다만 아래 풀이처럼 재귀를 이용한 풀이도 있으니 참고해서 분석해볼 것
```java
public class Solution {
    private final int[][] mem = new int[501][501];

    private int max(int x, int y, int[][] triangle) {
        if (y == triangle.length) return 0;
        if (mem[x][y] != -1) return mem[x][y];

        return mem[x][y] = triangle[y][x] + Math.max(
                max(x, y + 1, triangle),
                max(x + 1, y + 1, triangle));
    }

    public int solution(int[][] triangle) {
        for (int[] row : mem) {
            Arrays.fill(row, -1);
        }
        return max(0, 0, triangle);
    }
}
```

# 2차 풀이
```java
class Solution {
    public int solution(int[][] triangle) {
        int[][] dp = new int[triangle.length][triangle[triangle.length - 1].length];
        
        for (int i = 0; i < triangle.length; i++) {
            for (int j = 0; j < triangle[i].length; j++) {
                if (i - 1 < 0 && j - 1 < 0) {
                    dp[i][j] = triangle[i][j];
                    continue;
                }
                
                if (j - 1 < 0) {
                    dp[i][j] = triangle[i][j] + dp[i - 1][j];
                    continue;
                }
                
                dp[i][j] = Math.max(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j];
            }
        }
        
        int max = 0;
        for (int i = 0; i < dp[dp.length - 1].length; i++) {
            max = Math.max(max, dp[dp.length - 1][i]);
        }
        
        return max;
    }
}
```
하향식 풀이법도 공부해보자

# 3차 풀이
```java
class Solution {
    public int solution(int[][] triangle) {
        int[][] mem = new int[501][501];
        for (int i = 0; i < mem.length; i++) {
            Arrays.fill(mem[i], -1);
        }
        
        dfs(0, 0, mem, triangle);
        
        return mem[0][0];
    }
    
    private int dfs(int x, int y, int[][] mem, int[][] triangle) {
        if (y == triangle.length - 1) {
            mem[y][x] = triangle[y][x];
            return triangle[y][x];
        }
        
        if (mem[y][x] != -1) {
            return mem[y][x];
        }
        
        mem[y][x] = Math.max(dfs(x + 1, y + 1, mem, triangle), dfs(x, y + 1, mem, triangle)) + triangle[y][x];
        
        return mem[y][x];
    }
}
```
하향식으로 풀어봄 
낯설어서 여러번 풀어봐야 할듯

# 4차 풀이
```java
class Solution {
    public int solution(int[][] triangle) {
        int y = triangle.length;
        int x = triangle[triangle.length - 1].length;
        int[][] dp = new int[y][x];
        
        return dfs(0, 0, dp, triangle);
    }
    
    private int dfs(int x, int y, int[][] dp, int[][] triangle) {
        if (triangle.length - 1 == y) {
            dp[y][x] = triangle[y][x];
            return dp[y][x];
        }
        
        if (dp[y][x] != 0) {
            return dp[y][x];
        }
        
        dp[y][x] = Math.max(dfs(x + 1, y + 1, dp, triangle), dfs(x, y + 1, dp, triangle)) + triangle[y][x];
        
        return dp[y][x];
    }
}
```
좀 익숙하게 풀었지만 논리적으로 구현 순서를 정리하고 풀어보기

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int[][] triangle) {
        int y = triangle.length;
        int x = triangle[triangle.length - 1].length;
        int[][] mem = new int[y][x];
        for (int i = 0; i < mem.length; i++) {
            Arrays.fill(mem[i], -1);
        }
        
        return dfs(0, 0, mem, triangle);
    }
    
    private int dfs(int x, int y, int[][] mem, int[][] triangle) {
        if (y == mem.length - 1) {
            mem[y][x] = triangle[y][x];
            return mem[y][x];
        }
        
        if (mem[y][x] != -1) {
            return mem[y][x];
        }
        
        mem[y][x] = Math.max(dfs(x + 1, y + 1, mem, triangle), dfs(x, y + 1, mem, triangle)) + triangle[y][x];
        
        return mem[y][x];
    }
}
```
dfs를 return 값이 있는 것으로 푸는 것은 어렵지 않은데, return 값이 void인 형태로 풀려니 막혔음

아래는 풀다 막힌 것인데 마지막에 두번의 dfs 호출을 mem 변수 추가 라인 위로 올려주면 통과한다.
```java
class Solution { 
	public int solution(int[][] triangle) { 
		int y = triangle.length; 
		int x = triangle[triangle.length - 1].length; 
		int[][] mem = new int[y][x]; 
		for (int i = 0; i < mem.length; i++) { 
			Arrays.fill(mem[i], -1); 
		}

		dfs(0, 0, mem, triangle);

		return mem[0][0]; 
	}

private void dfs(int x, int y, int[][] mem, int[][] triangle) { 
	if (y == mem.length - 1) { 
		mem[y][x] = triangle[y][x]; 
		return; 
	}

	if (mem[y][x] != -1) { 
		return; 
	}

	mem[y][x] = Math.max(mem[y + 1][x + 1], mem[y + 1][x]) + triangle[y][x]; 
	dfs(x + 1, y + 1, mem, triangle); 
	dfs(x, y + 1, mem, triangle); } 
}
```

# 6차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int[][] triangle) {
        int y = triangle.length;
        int x = triangle[y - 1].length;
        int[][] map = new int[y][x];
        for (int i = 0; i < map.length; i++) {
            Arrays.fill(map[i], -1);
        }
        return count(0, 0, map, triangle);
    }
    
    private int count(int y, int x, int[][] map, int[][] triangle) {
        if (y == map.length - 1) {
            map[y][x] = triangle[y][x];
            return map[y][x];
        }
        
        if (map[y][x] != -1) {
            return map[y][x];
        }
        
        map[y][x] = Math.max(count(y + 1, x, map, triangle), count(y + 1, x + 1, map, triangle)) + triangle[y][x];
        
        return map[y][x];
    }
}
```

# 7차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int[][] triangle) {
        int[][] dp = new int[triangle.length][triangle[triangle.length - 1].length];
        for (int i = 0; i < dp.length; i++) {
            Arrays.fill(dp[i], -1);
        }
        
        sumValue(0, 0, dp, triangle);
        return dp[0][0];
    }
    
    private void sumValue(int x, int y, int[][] dp, int[][] triangle) {
        if (y >= dp.length || x >= dp[0].length) return;
        if (y == dp.length - 1) {
            dp[y][x] = triangle[y][x];
            return;
        }
        
        if (dp[y][x] != -1) return;
        
        sumValue(x, y + 1, dp, triangle);
        sumValue(x + 1, y + 1, dp, triangle);

        dp[y][x] = Math.max(dp[y + 1][x], dp[y + 1][x + 1]) + triangle[y][x];
    }
}
```

`if (y >= dp.length || x >= dp[0].length) return;` 범위 검사는 필요 없음

# 8차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int[][] triangle) {
        int[][] mem = new int[triangle.length][triangle[triangle.length - 1].length];
        for (int i = 0; i < mem.length; i++) {
            Arrays.fill(mem[i], -1);
        }
        return sum(0, 0, mem, triangle);
    }
    
    private int sum(int x, int y, int[][] mem, int[][] triangle) {
        if (y >= mem.length || x >= mem[0].length) return 0;
        if (y == mem.length - 1) {
            mem[y][x] = triangle[y][x];
            return mem[y][x];
        }
        
        if (mem[y][x] != -1) return mem[y][x];
        
        mem[y][x] = Math.max(sum(x + 1, y + 1, mem, triangle), sum(x, y + 1, mem, triangle)) + triangle[y][x];
        return mem[y][x];
    }
}
```