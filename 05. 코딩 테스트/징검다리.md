---
플랫폼: 프로그래머스
문제 이름: 징검다리
알고리즘: 이진탐색
tags:
  - 이진탐색
date: 2025-08-19
aliases:
  - 이진탐색
복습 풀이: 250819(X), 250824(X), 250901(X), 250906(X), 250913(O)
---
# 1차 풀이
```java
import java.util.Arrays;

public class Solution {
    private boolean isValid(int d, int[] rocks, int n) {
        int removed = 0;  // 제거한 바위의 개수
        int last = 0;  // 마지막 바위의 위치
        for (int rock : rocks) {
            if (rock - last < d) {
                removed++;
                continue;
            }

            last = rock;
        }
        return removed <= n;
    }

    public int solution(int distance, int[] rocks, int n) {
        rocks = Arrays.copyOf(rocks, rocks.length + 1);
        rocks[rocks.length - 1] = distance;
        Arrays.sort(rocks);

        int start = 1;
        int end = distance + 1;

        while (end - start > 1) {
            int d = (start + end) / 2;

            if (isValid(d, rocks, n)) {
                start = d;
            } else {
                end = d;
            }
        }

        return start;
    }
}
```
해당 코드는 정답을 그대로 옮긴 풀이. 
설명을 봐도 정확히 이해가 안됨

# 2차 풀이
```java
class Solution {
    public int solution(int distance, int[] rocks, int n) {
        rocks = Arrays.copyOf(rocks, rocks.length + 1);
        rocks[rocks.length - 1] = distance;
        Arrays.sort(rocks);
        
        int start = 1;
        int end = distance + 1;
        
        while (end - start > 1) {
            int mid = (start + end) / 2;
            
            if (isSmallest(mid, rocks, n)) {
                end = mid;
            } else {
                start = mid;
            }
        }
        
        return start;
    }
    
    private boolean isSmallest(int mid, int[] rocks, int n) {
        int count = 0;
        int last = 0;
        for (int rock : rocks) {
            if (rock - last < mid) {
                count++;
                continue;
            }
            
            last = rock;
        }
        
        return count > n;
    }
}
```
일단 해당 문제가 정답을 만족하는 값 중, 최댓값을 찾는 문제라는 것은 이해했다.
하지만 여전히 이해가 가지 않는 부분은 while문..
[[이분 탐색]] 을 여러번 읽어보기

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(int distance, int[] rocks, int n) {
        rocks = Arrays.copyOf(rocks, rocks.length + 1);
        rocks[rocks.length - 1] = distance;
        Arrays.sort(rocks);
        int start = 1;
        int end = distance;
        int answer = 0;
        
        while (start <= end) {
            int mid = (start + end) / 2;
            
            if (isValid(mid, rocks, n)) {
                start = mid + 1;
            } else {
                end = mid - 1;
            }
        }
        
        return start;
    }
    
    private boolean isValid(int mid, int[] rocks, int n) {
        int count = 0;
        int last = 0;
        for (int rock : rocks) {
            if (rock - last < mid) {
                count++;
            } else {
                last = rock;    
            }
        }
        
        return count <= n;
    }
}
```
전반적인 문제 이해도는 올라감
다만 여전히 이진 탐색 구현 방식이 어려움
추가적으로 다음과 같은 정보를 얻을 수 있었음
일단 기본 템플릿은 유지하되, 아래와 같은 경우에 따라 answer을 사용하던지 사용하지 않던지 두 가지로 나뉨
### `answer` 변수가 필요 없는 경우: 경계 찾기 (Lower/Upper Bound)
`answer` 변수 없이 `start`를 반환했던 **순위 검색**이 이 경우에 해당합니다.
- **`mid`의 역할**: 정렬된 `scores` 리스트의 **`인덱스`** 또는 **`위치`**를 가리킵니다. `mid` 자체는 아무 의미가 없고, `scores.get(mid)` 즉, 그 위치에 있는 **값**이 중요합니다.
- **탐색의 목표**: `targetScore`보다 크거나 같은 값이 **처음 나타나는 `위치(인덱스)`**를 찾는 것입니다.
- **왜 `answer`가 필요 없나?**: 이진 탐색의 `while` 루프는 **정답이 있을 만한 `인덱스` 범위를 좁혀나가는 과정**입니다. 루프가 종료되면 `start` 포인터는 자연스럽게 우리가 찾던 바로 그 경계 `위치`에 멈추게 됩니다. 즉, **포인터의 최종 위치가 우리가 원하는 답**이므로, 굳이 중간 결과를 `answer` 변수에 저장할 필요가 없습니다.
> **비유**: 백과사전에서 '강아지'라는 단어를 찾는 것과 같습니다. 'ㄱ' 섹션을 찾고, '가'를 찾고, '강'을 찾는 식으로 범위를 좁혀나갑니다. 최종적으로 '강아지'라는 단어를 찾았을 때, 중요한 것은 그 단어가 있는 **페이지 번호(인덱스)** 자체입니다. 중간에 확인했던 다른 페이지 번호를 기억할 필요가 없죠.

---

### `answer` 변수가 필수인 경우: 최적해 찾기 (Parametric Search)
`answer` 변수가 반드시 필요했던 **징검다리** 문제가 이 경우에 해당합니다.
- **`mid`의 역할**: **'돌 사이의 최소 거리'라는 `정답 후보` 그 자체**입니다. 이것은 배열의 인덱스가 아니라, 문제의 답이 될 수 있는 추상적인 값(e.g., 거리 25)입니다.
- **탐색의 목표**: "돌 사이의 최소 거리를 `mid`로 설정하는 것이 가능한가?"라는 질문을 만족시키는 **`mid` 값 중 최댓값**을 찾는 것입니다.
- **왜 `answer`가 필요한가?**: `isPossible(mid)`가 `true`라는 것은 `mid`가 일단 답이 될 수 있다는 의미입니다. 하지만 우리는 **더 좋은 답(더 큰 `mid` 값)**을 찾아야 하므로 탐색을 계속합니다. 이때, **현재 성공한 이 `mid` 값을 `answer` 변수에 저장해두지 않으면 잊어버리게 됩니다.** 포인터(`start`, `end`)는 더 좋은 답을 찾기 위해 계속 움직이다가 결국 정답이 아닌 위치에서 멈추기 때문입니다. `answer`는 **지금까지 찾은 답 중 최고 기록**을 저장하는 역할을 합니다.

> **비유**: "깨지지 않고 달걀을 떨어뜨릴 수 있는 가장 높은 층 찾기"와 같습니다. 50층(`mid`)에서 떨어뜨렸는데 안 깨졌다면, 일단 **"50층은 안전하다"고 `answer`에 기록**해 둡니다. 그리고 더 높은 층을 시도하죠. 75층에서 시도했는데 깨졌다면, 이제 50층과 74층 사이를 탐색합니다. 최종적으로 탐색이 끝났을 때, 우리에게 필요한 정보는 마지막으로 탐색을 시도한 층이 아니라, **기록해 둔 가장 높은 안전한 층(`answer`)**입니다.

---

### 최종 결정 기준 (이것만 기억하세요!)
코드를 짜기 전 스스로에게 이 질문을 던져보세요.
**"`mid`는 배열의 `인덱스`인가, 아니면 `정답 후보(값)`인가?"**
- **`인덱스`다!** → `answer` 변수 **필요 없음**. 루프 종료 후 `start`나 `end`를 반환. (e.g., `순위 검색`)
- **`정답 후보(값)`다!** → `answer` 변수 **필수**. `if`문 안에서 `answer = mid`로 기록하고, 최종적으로 `answer`를 반환. (e.g., `징검다리`, `공유기 설치`)

# 4차 풀이
```java
class Solution {
    public int solution(int distance, int[] rocks, int n) {
        int[] values = new int[rocks.length + 1];
        for (int i = 0; i < rocks.length; i++) {
            values[i] = rocks[i];
        }
        values[rocks.length] = distance;
        Arrays.sort(values);

        int start = 0;
        int end = distance;
        int answer = 0;
        
        while (start <= end) {
            int mid = (start + end) / 2;
            
            if (isValid(mid, values, n)) {
                answer = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(int mid, int[] rocks, int n) {
        int remove = 0;
        int last = 0;
        for (int rock : rocks) {
            if (rock - last < mid) {
                remove++;
            } else {
                last = rock;
            }
        }
        
        return remove >= n;
    }
}
```
answer을 사용하는 이유는 3차 풀이에서 분석한 내용을 참고

isValid 메서드가 잘못됨.
이 문제가 최솟값 중에서 최댓값을 찾는 문제이기 때문임
remove <= n이 되어야 정답이 되는 값 중 더 큰 값을 탐색 시도할 수 있음

# 5차 풀이
```java
class Solution {
    public int solution(int distance, int[] rocks, int n) {
        int[] bridge = new int[rocks.length + 1];
        for (int i = 0; i < rocks.length; i++) {
            bridge[i] = rocks[i];
        }
        bridge[bridge.length - 1] = distance;
        Arrays.sort(bridge);
        int start = 0;
        int end = distance;
        int answer = 0;
        while (start <= end) {
            int mid = (start + end) / 2;
            
            if (isValid(mid, n, bridge)) {
                answer = mid;
                start = mid + 1; // 정답이 될 수 있는 값 중 최댓값을 찾아야 하므로 범위를 늘림
            } else {
                end = mid - 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(int mid, int n, int[] rocks) {
        int removed = 0;
        int last = 0;
        for (int rock : rocks) {
            if (rock - last < mid) {
                removed++;
            } else {
                last = rock;
            }
        }
        
        return removed <= n;
    }
}
```
이제 확실히 이분 탐색의 기준을 잡을 수 있음
다만, [[입국 심사]]와 마찬가지로 이분탐색할 범위를 정하는 것은 쉽지 않은 듯.
한 번더 풀어보면서 문제를 곱씹어 보고, 문제의 기준을 정하는 과정을 논리적 단계를 거쳐 추론해보자.