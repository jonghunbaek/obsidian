---
플랫폼: 프로그래머스
알고리즘:
tags:
date: 2025-12-31
복습 풀이: 251231(O), 260105(O), 260110(X), 260117(O)
---
# 1차 풀이
```java
// 문자열

class Solution {
    public String solution(String s, String skip, int index) {
        boolean[] isSkip = new boolean[26];
        for (char c : skip.toCharArray()) {
            isSkip[c - 'a'] = true;
        }
        
        char[] charArr = s.toCharArray();
        for (int i = 0; i < charArr.length; i++) {
            int from = charArr[i] - 'a';
            int offset = 1;
            int tempIdx = index;
            while (offset <= tempIdx) {
                int idx = (from + offset) % 26;
                if (isSkip[idx]) {
                    offset++;
                    tempIdx++;
                    continue;
                }
                
                offset++;
            }
            
            charArr[i] = (char) (((from + offset - 1) % 26) + 'a');
        }
        
        return new String(charArr);
    }
}
```
테스트 케이스가 없었다면 분명히 틀렸을 문제.
문자열은 아직도 풀이가 어색함

아래는 더 명확한 풀이
```java
class Solution {
    public String solution(String s, String skip, int index) {
        StringBuilder answer = new StringBuilder();
        
        for (char c : s.toCharArray()) {
            char current = c;
            int count = 0;
            
            // index만큼 이동
            while (count < index) {
                current++;
                
                // z를 넘어가면 a로 순환
                if (current > 'z') {
                    current = 'a';
                }
                
                // skip에 포함되지 않은 문자만 카운트
                if (skip.indexOf(current) == -1) {
                    count++;
                }
            }
            
            answer.append(current);
        }
        
        return answer.toString();
    }
}
```

# 2차 풀이
```java
import java.util.*;

class Solution {
    public String solution(String s, String skip, int index) {
        Map<Character, Boolean> isSkip = new HashMap<>();
        for (char c : skip.toCharArray()) {
            isSkip.put(c, true);
        }
        
        char[] target = s.toCharArray();
        for (int i = 0; i < target.length; i++) {
            int count = 0;
            while (count < index) {
                target[i]++;
                if (target[i] > 'z') {
                    target[i] = 'a';
                }
                
                if (isSkip.getOrDefault(target[i], false)) {
                    continue;
                }
                
                count++;
            }
        }
        
        return String.valueOf(target);
    }
}
```

# 3차 풀이
```java
class Solution {
    public String solution(String s, String skip, int index) {
        boolean[] isSkip = new boolean[26];
        for (char target : skip.toCharArray()) {
            int idx = target - 'a';
            isSkip[idx] = true;
        }
        
        StringBuilder sb = new StringBuilder();
        for (char c : s.toCharArray()) {
            int idx = 0;
            int bufferIdx = 0;
            while (idx < index) {
                char target = (char)((((char)(c + bufferIdx)) - 'a') % 26 + 'a');
                int targetIdx = target - 'a';
                if (isSkip[targetIdx]) {
                    bufferIdx++;   
                } else {
                    idx++;    
                    bufferIdx++;
                }
            }
            
            sb.append((char)((((char)(c + bufferIdx)) - 'a') % 26 + 'a'));
        }
        
        return sb.toString();
    }
}
```

# 4차 풀이
```java
class Solution {
    public String solution(String s, String skip, int index) {
        char[] target = s.toCharArray();
        for (int i = 0; i < target.length; i++) {
            int start = 0;
            while (start < index)  {
                target[i]++;
                if (target[i] > 'z') target[i] = 'a';
                if (skip.contains(String.valueOf(target[i]))) continue;
                start++;
            }
        }
        
        return String.valueOf(target);
    }
}
```
지금까지의 풀이드를 토대로 고민해보니, 문자열이 나오면 무조건 아스키 코드를 활용해야 한다는 편견이 존재하는 것 같음
해당 문제도 첫 풀이에선 그 방향으로만 고집하다보니 오히려 풀이가 어렵고 복잡해짐
