---
플랫폼: 프로그래머스
알고리즘: 구현, 정렬
tags:
  - 구현
  - 정렬
  - 우선순위큐
date: 2026-01-22
복습 풀이: 260122(X), 260205(O), 260207(O), 260214(O)
---
# 1차 풀이
```java
// 구현, 정렬
import java.util.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        PriorityQueue<Result> results = new PriorityQueue<>();
        int[] failCount = new int[N + 2];
        int challengerCount = stages.length;
        for (int stage : stages) {
            failCount[stage]++;
        }

        for (int i = 1; i < failCount.length - 1; i++) {
            double failRate = (double) failCount[i] / challengerCount;
            challengerCount -= failCount[i];
            results.offer(new Result(i, failRate));
        }

        int[] r = new int[N];
        int idx = 0;
        while (!results.isEmpty()){
            Result result = results.poll();
            r[idx] = result.stage;
            idx++;
        }

        return r;
    }

    static class Result implements Comparable<Result> {
        private int stage;
        private double failRate;

        public Result(int stage, double failRate) {
            this.stage = stage;
            this.failRate = failRate;
        }

        @Override
        public int compareTo(Result o) {
            if (this.failRate == o.failRate) {
                return this.stage - o.stage;
            }

           return Double.compare(o.failRate, this.failRate);
            // return o.failRate - this.failRate > 0 ? 1 : -1;
        }
    }
}
```

# 2차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        Map<Integer, Integer> counts = new HashMap<>();
        for (int stage : stages) {
            counts.put(stage, counts.getOrDefault(stage, 0) + 1);
        }
        
        int challenger = stages.length;
        List<Stage> results = new ArrayList<>();
        for (int i = 1; i <= N; i++) {
            double count = (double) counts.getOrDefault(i, 0);
            double failRate = challenger == 0 ? 0.0 : count / challenger;
            results.add(new Stage(i, failRate));
            challenger -= count;
        }
        
        return results.stream()
            .sorted((s1, s2) -> {
                if (s1.failRate == s2.failRate) return s1.no - s2.no;
                return Double.compare(s2.failRate, s1.failRate);
            })
            .mapToInt(stage -> stage.no)
            .toArray();
    }
    
    static class Stage {
        private int no;
        private double failRate;
        
        public Stage(int no, double failRate) {
            this.no = no;
            this.failRate = failRate;
        }
    }
}
```
지난 풀이 때 일부 엣지 케이스를 찾지 못했음
문제 속에 답이 있다 생각하고, 꼼꼼히 읽다보니 `challenger`의 값이 0인 경우에 대해 고려하지 않음
실패한 테케에서 런타임 오류가 아닌 단순 실패로만 표시되어 찾기가 더욱 힘들었음

`0 / 0` 은 `java.lang.ArithmeticException: / by zero` 예외가 터지지만
`0.0 / 0`은 `NaN(Not a Number`로 처리되며, 이는 Java에서 가장 큰 수로 판별되어 `Double.compare`에서 올바른 정렬을 수행하지 못하게 됨

따라서, 내코드처럼 NaN을 못 뱉도록 하던지 아래 코드처럼 처리해야함.
-> NaN은 다른 어떤 수와 비교해도 항상 false를 반환하게 됨
```java
class Stage implements Comparable<Stage> {
        public int id;
        public double failure;

        public Stage(int id_, double failure_) {
            id = id_;
            failure = failure_;
        }

        @Override
        public int compareTo(Stage o) {
            if (failure < o.failure ) {
                return -1;
            }
            if (failure > o.failure ) {
                return 1;
            }
            return 0;
        }
    }
```

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int N, int[] stages) {        
        Map<Integer, Integer> counts = new HashMap<>();
        for (int stage : stages) {
            counts.put(stage, counts.getOrDefault(stage, 0) + 1);
        }
        
        int challengers = stages.length;
        List<StageInfo> results = new ArrayList<>();
        for (int i = 1; i <= N; i++) {
            double failRate = challengers == 0 ? 0.0 : (double) counts.getOrDefault(i, 0) / challengers;
            results.add(new StageInfo(i, failRate));
            challengers -= counts.getOrDefault(i, 0);
        }
        
        return results.stream()
            .sorted((r1, r2) -> {
                if (r1.failRate == r2.failRate) return r1.no - r2.no;
                return Double.compare(r2.failRate, r1.failRate);
            })
            .mapToInt(result -> result.no)
            .toArray();
    }
    
    static class StageInfo {
        private int no;
        private double failRate;
        
        public StageInfo(int no, double failRate) {
            this.no = no;
            this.failRate = failRate;
        }
    }
}
```

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        Map<Integer, Integer> counts = new HashMap<>();
        for (int stage : stages) {
            counts.put(stage, counts.getOrDefault(stage, 0) + 1);
        }
        
        int challengers = stages.length;
        List<StageResult> results = new ArrayList<>();
        for (int i = 1; i <= N; i++) {
            int count = counts.getOrDefault(i, 0);
            double failRate = count == 0 ? 0.0 : (double) count / challengers;
            results.add(new StageResult(i, failRate));
            challengers -= count;
        }
        
        return results.stream()
            .sorted((r1, r2) -> {
                if (r1.failRate == r2.failRate) return r1.no - r2.no;
                return Double.compare(r2.failRate, r1.failRate);
            })
            .mapToInt(result -> result.no)
            .toArray();
    }
    
    static class StageResult {
        private int no;
        private double failRate;
        
        public StageResult(int no, double failRate) {
            this.no = no;
            this.failRate = failRate;
        }
    }
}
```