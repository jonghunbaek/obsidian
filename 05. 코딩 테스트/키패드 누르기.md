---
플랫폼: 프로그래머스
문제 이름: 키패드 누르기
알고리즘: 구현
tags:
  - 구현
date: 2025-09-23
aliases:
  - 구현
복습 풀이: 250923(O), 251006(O), 251011(O), 251019(O)
---
# 1차 풀이
```java
class Solution {
    public String solution(int[] numbers, String hand) {
        String[] results = new String[numbers.length];
        String[][] keypad = initKeypad();

        String left = "*";
        String right = "#";
        for (int i = 0; i < numbers.length; i++) {
            if (numbers[i] == 1 || numbers[i] == 4 || numbers[i] == 7) {
                results[i] = "L";
                left = String.valueOf(numbers[i]);
                continue;
            }

            if (numbers[i] == 3 || numbers[i] == 6 || numbers[i] == 9) {
                results[i] = "R";
                right = String.valueOf(numbers[i]);
                continue;
            }

            String direction = findCloserThumb(numbers[i], left, right, keypad, hand);
            if (direction.equals("right")) {
                results[i] = "R";
                right = String.valueOf(numbers[i]);
            } else {
                results[i] = "L";
                left = String.valueOf(numbers[i]);
            }
        }

        return String.join("", results);
    }

    private String[][] initKeypad() {
        String[][] keypad = new String[4][3];
        int value = 1;
        for (int i = 0; i < keypad.length - 1; i++) {
            for (int j = 0; j < keypad[i].length; j++) {
                keypad[i][j] = String.valueOf(value++);
            }
        }

        keypad[3][0] = "*";
        keypad[3][1] = String.valueOf(0);
        keypad[3][2] = "#";

        return keypad;
    }

    private String findCloserThumb(int number, String left, String right, String[][] keypad, String major) {
        int[] leftPoint = new int[2];
        int[] rightPoint = new int[2];
        int[] targetPoint = new int[2];

        for (int i = 0; i < keypad.length; i++) {
            for (int j = 0; j < keypad[i].length; j++) {
                if (keypad[i][j].equals(String.valueOf(number))) {
                    targetPoint[0] = i;
                    targetPoint[1] = j;
                }

                if (keypad[i][j].equals(left)) {
                    leftPoint[0] = i;
                    leftPoint[1] = j;
                }

                if (keypad[i][j].equals(right)) {
                    rightPoint[0] = i;
                    rightPoint[1] = j;
                }
            }
        }

        int leftLength = Math.abs(leftPoint[0] - targetPoint[0]) + Math.abs(leftPoint[1] - targetPoint[1]);
        int rightLength = Math.abs(rightPoint[0] - targetPoint[0]) + Math.abs(rightPoint[1] - targetPoint[1]);

        if (leftLength < rightLength) {
            return "left";
        } else if (leftLength > rightLength) {
            return "right";
        } else {
            return major;
        }
    }
}
```
구현에만 집중해 깔끔하지 않음

# 2차 풀이
```java
// 1. 키패드를 구현한 2차원 배열을 생성
// 2. Hand라는 객체로 왼손/오른손 구현(direction, x, y)
// 3.
import java.util.*;
import java.util.stream.*;

class Solution {
    public String solution(int[] numbers, String hand) {
        int[][] keypad = createKeypad();
        Hand myHand = new Hand(hand);
        
        return Arrays.stream(numbers)
            .mapToObj(number -> myHand.moveTo(number, keypad[number]))
            .collect(Collectors.joining());
    }
    
    private int[][] createKeypad() {
        int[][] keypad = new int[10][2];
        int row = 0;
        int col = 0;
        for (int i = 1; i < 10; i++) {
            if (col == 3) {
                row++;
                col = 0;
            }
            
            keypad[i] = new int[] {row, col++};
        }
        
        keypad[0] = new int[] {3, 1};
        
        return keypad;
    }
    
    static class Hand {
        String priority;
        Point leftPoint;
        Point rightPoint;
        
        public Hand(String priority) {
            this.priority = priority;
            this.leftPoint = new Point(0, 3);
            this.rightPoint = new Point(2, 3);
        }
        
        public String moveTo(int number, int[] point) {
            if (isLeft(number)) {
                moveLeft(point);
                return "L";
            } else if (isRight(number)) {
                moveRight(point);
                return "R";
            } 
            
            if (findCloserDirection(point).equals("L")) {
                moveLeft(point);
                return "L";    
            } else {
                moveRight(point);
                return "R";
            }
        }
        
        private boolean isLeft(int number) {
            return number == 1 || number == 4 || number == 7;
        }
        
        private boolean isRight(int number) {
            return number == 3 || number == 6 || number == 9;
        }
        
        private void moveLeft(int[] point) {
            leftPoint.y = point[0];
            leftPoint.x = point[1];
        }
        
        private void moveRight(int[] point) {
            rightPoint.y = point[0];
            rightPoint.x = point[1];
        }
        
        private String findCloserDirection(int[] point) {
            int leftDistance = Math.abs(leftPoint.y - point[0]) + Math.abs(leftPoint.x - point[1]);
            int rightDistance = Math.abs(rightPoint.y - point[0]) + Math.abs(rightPoint.x - point[1]);
   
            if (leftDistance > rightDistance) {
                return "R";
            } else if (leftDistance < rightDistance) {
                return "L";
            } else {
                return priority.equals("left") ? "L" : "R";
            }
        }
    }
    
    static class Point {
        int x;
        int y;
        
        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}
```

# 3차 풀이
```java
// 1. 키패드용 2차원 배열 만들기
// 2. 왼손/오른손은 */# 위치 좌표로 초기화
// 3. 누를 번호에 해당 하는 손을 옮기며 좌표 값 갱신
// 4. 가운데 번호는 가장 가까운 거리(절대값 계산)

class Solution {
    public String solution(int[] numbers, String hand) {
        int[][] keypad = createKeypad();
        Hand myHand = new Hand(hand);
        
        String[] results = new String[numbers.length];
        
        for (int i = 0; i < numbers.length; i++) {
            results[i] = myHand.move(numbers[i], keypad);
        }
        
        return String.join("", results);
    }

    private int[][] createKeypad() {
        int[][] keypad = new int[10][2];
        
        keypad[0] = new int[] {3, 1};
        int col = 0;
        int row = 0;
        for (int i = 1; i < keypad.length; i++) {
            if (row == 3) {
                col++;
                row = 0;
            }
            
            keypad[i] = new int[] {col, row};
            row++;
        }

        return keypad;
    }
    
    static class Hand {
        String major;
        int[] left = new int[] {3, 0};
        int[] right = new int[] {3, 2};
        
        public Hand(String major) {
            this.major = major;
        }
        
        public String move(int number, int[][] keypad) {
            if (number == 1 || number == 4 || number == 7) {
                left = keypad[number];
                return "L";
            } else if (number == 3 || number == 6 || number == 9) {
                right = keypad[number];
                return "R";
            } 
            
            int leftDistance = leftDistance(keypad[number]);
            int rightDistance = rightDistance(keypad[number]);

            if (leftDistance > rightDistance) {
                right = keypad[number];
                return "R";
            } else if (leftDistance < rightDistance) {
                left = keypad[number];
                return "L";
            }

            if (major.equals("left")) {
                left = keypad[number];
                return "L";
            } else {
                right = keypad[number];
                return "R";
            }
        }
        
        private int leftDistance(int[] point) {
            return Math.abs(point[0] - left[0]) + Math.abs(point[1] - left[1]);
        }
        
        private int rightDistance(int[] point) {
            return Math.abs(point[0] - right[0]) + Math.abs(point[1] - right[1]);
        }
    }
}
```
풀이 자체는 어렵지 않으나 어떻게 하면 더 단순하고 가독성 좋고 디버깅하기 쉽게 작성할 수 있을지 고민하며 풀어보기.

# 4차 풀이
```java
class Solution {
    public String solution(int[] numbers, String hand) {
        int[][] keypad = createKeypad();
        
        int[] left = new int[] {3, 0};
        int[] right = new int[] {3, 2};
        StringBuilder sb = new StringBuilder();
        for (int number : numbers) {
            if (number == 1 || number == 4 || number == 7) {
                left = keypad[number];
                sb.append("L");
                continue;
            } 
            
            if (number == 3 || number == 6 || number == 9) {
                right = keypad[number];
                sb.append("R");
                continue;
            }
            
            int leftDistance = Math.abs(keypad[number][0] - left[0]) + Math.abs(keypad[number][1] - left[1]);
            int rightDistance = Math.abs(keypad[number][0] - right[0]) + Math.abs(keypad[number][1] - right[1]);
        
            if (leftDistance > rightDistance) {
                right = keypad[number];
                sb.append("R");
            } else if (leftDistance < rightDistance) {
                left = keypad[number];
                sb.append("L");
            } else {
                if (hand.equals("left")) {
                    left = keypad[number];
                    sb.append("L");
                } else {
                    right = keypad[number];
                    sb.append("R");
                }
            }
        }
        
        return sb.toString();
    }
    
    private int[][] createKeypad() {
        int[][] keypad = new int[10][2];
        int row = 0;
        int col = 0;
        for (int i = 1; i < 10; i++) {
            if (col == 3) {
                row++;
                col = 0;
            }
            
            keypad[i] = new int[] {row, col++};
        }
        
        keypad[0] = new int[] {3, 1};
        return keypad;
    }
}
```