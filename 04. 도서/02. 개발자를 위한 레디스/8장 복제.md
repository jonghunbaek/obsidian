레디스에서 고가용성을 보장하려면 **복제와 자동 페일오버가 존재**해야 한다. 
기본 레디스에선 자동 페일오버가 되지 않으며, 필요하다면 자체 솔루션인 센티넬을 사용해야 한다.

# 1. 레디스의 복제 구조
레디스는 기본적으로 멀티 마스터 구조가 아니라 단일 마스터 구조이며, 복제본은 읽기만 가능(2.6v ~)하다.
아래 명령어를 통해 복제본을 마스터에 연결할 수 있다.
```cli
REPLICAOF <master-ip> <master-port>
```
![[Redis - 복제본 연결.png]]
>[!마스터가 다운되면 새로운 마스터의 존재를 클라이언트에선 어떻게 알 수 있을까?]
>기본 레디스에선 이를 자동으로 알려줄 수 있는 방법이 없는 듯.
>대신 센티넬을 사용하면 센티넬에서 새 마스터 정보를 클라이언트에게 알려준다고 함.

## 1.1 복제 메커니즘
레디스 옵션 중 repl-diskless-sync의 값에 따라 복제 메커니즘이 달라진다.
7버전 이전에는 기본 값이 **no이므로 디스크 기반 복제 작업**이 수행되고, 7버전 이후에는 기본 값이 **yes이므로 소켓 통신 기반 복제 작업**이 수행된다.

### 디스크 기반 복제 작업
![[Redis - 디스크 기반 복제.png|500]]
1. 복제 연결 시도
2. 자식 프로세스를 생성해 RDB 스냅숏 생성
3. RDB 파일 생성 중, 데이터 변경 작업은 RESP 형태로 복제 버퍼에 저장됨
4. RDB 파일을 복제본 노드로 복사
5. 복제본에 저장된 모든 내용을 삭제하고, RDB 파일을 이용해 데이터 로딩
6. 복제 과정 동안 마스터 노드 복제 버퍼에 쌓인 데이터를 복제본으로 전달해 실행

**이 과정**에서 마스터가 RDB 파일을 저장하는 시간, 복제본에서 RDB 파일을 읽어 오는 시간 모두 **디스크 I/O 처리량에 영향**을 받는다. 
때문에 버전 7 이후에는 기본 값으로 소켓 통신 기반의 복제 작업을 수행하게 된다.

### 소켓 통신 기반 복제 작업
![[Redis - 소켓 통신 기반 복제 작업.png|500]]
1. 복제 연결 시도
2. 소켓 통신으로 복제본 노드에 연결한 후, RDB 파일 생성과 동시에 점진적으로 복제본의 소켓에 전송
3. 2의 과정 동안, 데이터 변경 작업은 RESP 형태로 마스터의 복제 버퍼에 저장
4. 소켓에서 읽어온 RDB 파일을 복제본의 디스크에 저장
5. 복제본에 저장된 데이터 삭제 후 RDB 파일 로딩
6. 복제 과정 동안 마스터 노드 복제 버퍼에 쌓인 데이터를 복제본으로 전달해 실행

이 과정 중 4의 과정은 레디스 옵션 중 repl-diskless-load의 값에 따라 수행 방식이 달라진다.
기본 값은 disabled로 **RDB 파일을 일단 디스크에 저장 후 메모리로 로드**한다.
이는 **소켓 통신으로 받아온 RDB 파일의 안정성을 확신할 수 없기 때문**이다.
>[!소켓 통신 기반 RDB 파일 전송 과정]
>전체 파일이 생성된 후에 파일 전송이 시작되는 것이 아닌 **일부 데이터가 생성되며 점진적으로 전송**
>Redis에선 이를 riofd로 수행
>riofd는 rio라는 추상 인터페이스의 구현체 중 하나이며, 복제본과 연결된 소켓 파일 디스크립터에 데이터를 전송하는 역할을 한다. 
>rio는 RDB 데이터를 저장할 때 사용되는 인터페이스

>[!파일 디스크립터 - File Descriptor]
>파일 디스크립터는 리눅스에서 파일, 소켓, 파이프 등을 식별하는 정수형 ID다. 
>프로세스가 파일을 결거나 소켓을 만들면 각 대상에 고유한 파일 디스크립터가 부여되며, IP 주소처럼 대상을 식별하는 역할을 한다. 
### 비동기 방식으로 동작하는 복제 연결
마스터에서 복제본으로의 데이터 전달은 비동기 방식으로 수행된다. 
때문에 마스터 노드의 비정상 종료로 인해 데이터가 유실될 가능성도 존재한다. 
