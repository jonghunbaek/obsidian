# 3.1 들어가며
GC의 역사는 1960년 MIT에서 개발된 리스프라는 언어이며, 자바의 역사보다 훨씬 오래됐다.
리스프의 창시자인 존 맥카시가 말한 'GC가 처리해야 할 문제' 세 가지
- 어떤 메모리를 회수해야 하나?
- 언제 회수해야 하나?
- 어떻게 회수해야 하나?
다시 말해, GC의 주된 역할은 적절한 시기에 적절한 방법으로 적절한 메모리 영역의 데이터를 회수해야 하는 것이다.
또한 객체의 생명 주기는 런타임에만 알 수 있기에 메모리 회수와 할당은 동적으로 수행해야 한다. 

# 3.2 대상이 죽었는가?
자바에서 거의 모든 객체 인스턴스는 힙에 저장된다. 
GC가 힙을 청소하려면 객체의 생사 여부를 판단해야 한다.
이번 절에선 객체의 생사 판단 기준에 대해 알아보자.

### 3.2.1 참조 카운팅 알고리즘
객체의 생서 여부를 판단하는 가장 기초적이고 단순한 알고리즘이다.
- 객체를 가리키는 참조 카운터를 추가
- 참조하는 곳이 하나 늘어날 때마다 카운터 값++
- 참조하는 곳이 하나 줄어들 때마다 카운터 값--
- 카운터 값이 0인 인스턴스는 더 사용될 수 없음

하지만 여러 예외 케이스를 고려할 때, 실제 JVM에서 해당 알고리즘을 사용하는 것은 불가능하다.
대표적으로 순환 참조 문제가 존재한다. 
```java
/**  
 * VM Option : -Xlog:gc* 
*/
public class ReferenceCouningGC {  
    public Object instance = null;  
    private static final int _1MB = 1024 * 1024;  
    private byte[] bigSize = new byte[2 * _1MB];  
  
    public static void testGC() {  
        ReferenceCouningGC objA = new ReferenceCouningGC();  
        ReferenceCouningGC objB = new ReferenceCouningGC();  
  
        objA.instance = objB;  
        objB.instance = objA;  
  
        objA = null;  
        objB = null;  
  
        System.gc();  
    }  
  
    public static void main(String[] args) {  
        testGC();  
    }  
}
```
![[JVM 3장 - 순환 참조 객체 회수 로그.png]]
-> 위 코드 실행을 통해 JVM은 참조 카운팅 알고리즘을 사용하지 않음을 알 수 있음

### 3.2.2 도달 가능성 분석 알고리즘
참조 카운팅 알고리즘의 한계는 명확하기에 현재 주류 프로그래밍 언어는 모두 객체 생사 판단에 도달 가능성 분석 알고리즘을 활용한다. 

이 알고리즘의 핵심은 GC루트라고 하는 루트 객체를 시작 노드 집합으로 삼아 참조 객체들을 탐색해 나가는 것이다. 이 과정에서 만들어진 경로를 참조 체인이라고 한다. 
이 때, **특정 객체에 대한 참조 체인이 존재하지 않는다면 해당 객체는 회수 대상**이 된다. 
![[JVM 3장 - 도달 가능성 분석 알고리즘의 객체 생사 판별.png]]

#### GC루트로 사용될 수 있는 객체 목록
- VM 스택에서 참조하는 객체(매개 변수, 지역 변수 등 지역 변수 테이블)
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
- 메서드 영역에서 상수로 참조되는 객체(문자열 테이블 안의 참조 -> String 상수 풀)
- 네이티브 메서드 스택에서 JNI가 참조하는 객체
- JVM 내부에서 쓰이는 참조(기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체)
- 동기화 락으로 잠겨있는 모든 객체
- JVM 내부 상황을 반영하는 JMXBean
- 그 외 GC 종류나 현재 회수 중인 메모리 영역에 따라 다른 객체들도 임시 추가 될 수 있음
GC루트로부터 참조를 탐색하는 과정에서 주의할 점은 한 객체가 다른 영역에 존재하는 객체를 참조할 수도 있다는 점이다. 그러므로 연관된 영역의 객체들도 GC루트 집합에 포함해야 알고리즘을 정확하게 구현할 수 있다. 

### 3.2.3 참조의 개념
전통적인 참조의 개념은 다음과 같다.
- 참조 타입 데이터에 저장된 값이 다른 메모리 조각의 시작 주소를 뜻한다면, 이 참조 데이터를 해당 메모리 조각이나 객체를 참조한다고 말한다.

현 시점에서 해당 개념은 범위가 좁다. 
그래서 현재는 참조 개념을 확장해 아래와 같이 네 가지로 구분한다.
- **강한 참조**
	- 가장 전통적인 참조
	- 프로그램 코드에서 참조를 할당하는 것이며 **GC 회수 대상이 아님**
- **부드러운 참조**
	- 유용하지만 필수는 아닌 객체를 표현
	- 메모리 오버플로 발생 직전에 두 번째 회수를 위한 회수 목록에 추가됨
	- **두 번째 회수 이후에도 메모리가 부족한 경우 회수 대상이 됨**
- **약한 참조**
	- 부드러운 참조와 비슷하지만 연결 강도가 더 약함
	- **다음 가비지 컬렉션까지만 생존**
- **유령 참조**
	- 객체 수명에 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것은 불가능

>[!NOTE]
> **finalize()** 
> 도달 불가능한 객체라고 해서 반드시 회수 되어야 하는 것은 아니다. 
> 확실한 회수 대상이 되려면 두 번의 표시 과정을 거쳐야 하는데 이 때 활용되는 것이 finalize()다.
> 실행 비용도 높고 불확실성도 크기에 절대 사용 하지마라

### 3.2.4 메서드 영역 회수
메서드 영역은 GC의 회수 대상이 아니다는 거짓이다.
다만, 메서드 영역의 회수는 조건이 까다롭고 비용 효율이 좋지 않다. .

메서드 영역에서 GC의 회수 대상은 크게 상수, 클래스 두 가지다.
상수의 경우 'java'라는 리터럴을 참조하는 문자열 객체가 전혀 없다면 해당 상수는 회수 대상이 된다. 
클래스의 경우 다음 세 가지 조건을 만족해야 한다.
- 힙 영역에 해당 클래스와 하위 클래스의 인스턴스가 존재하지 않음
- 해당 클래스를 읽어들인 클래스 로더가 회수 되어야 함
- 해당 클래스의 java.lang.Class 객체를 참조하는 객체가 없고, 리플렉션으로도 해당 기능을 이용하지 않아야 함
**-> 회수를 허용한다지 반드시 회수하는 것은 아님**

## 3.3 가비지 컬렉션 알고리즘
이번 절에서 소개하는 알고리즘은 모두 추적 GC(도달 가능성 분석)에 속한다.
### 3.3.1 세대 단위 컬렉션 이론
세대 단위 컬렉션 이론은 다음과 같은 가설에서 시작하며, 현재 사용 VM 대부분이 해당 이론에 기초해 설계 됐다.
- **약한 세대 가설** - 대다수 객체는 일찍 죽는다.
- **강한 세대 가설** - GC 회수 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
이 가설에 따라 **자바 힙을 몇 개의 영역으로 구분하고, 객체들의 나이에 따라 각기 다른 영역에 할당하는 것**이 세대 단위 컬렉션 이론의 핵심이다.

힙 영역을 몇 가지로 구분하면 GC는 한 번에 하나 또는 몇 개 영역만 선택해 회수할 수 있는데 이를 기준으로 마이너 GC(신세대), 메이저 GC(구세대), 전체 GC로 구분할 수 있다. 
각 영역의 객체 생존 특성에 따라 마크-스윕, 마크-카피, 마크-컴패트 알고리즘을 구분해 회수하게 된다.

이 이론에 기초하여 VM 설계자들은 보통 자바 힙을 두 개 영역으로 구분한다. 
- **신세대**
- **구세대**
GC 회수 과정에서 살아 남은 신세대 영역의 객체들은 구세대 영역으로 승격된다. 

#### 그렇다면 이 두 가지 이론으로 완벽한 설계가 가능할까?
객체들은 단독으로 존재하지 않고 다른 세대에 존재하는 객체들을 참조하는 상황이 존재하기 때문에 두 가설만 가지고 완벽한 설계를 하는 것은 불가능 하다. 
예를 들어, 신세대에서만 가비지 컬렉션을 수행하고 싶어도 구세대에서 신세대의 객체를 참조 중인 경우가 존재한다. 반대의 경우도 마찬가지인데, 이 경우 구세대 전체를 탐색하는 것은 성능 면에서 부담이 크다. 
그러므로 **도달 가능성을 분석할 때, 고정된 GC 루트뿐만 아니라 구세대 객체까지 모두 탐색해야 결과를 신뢰**할 수 있다.

#### 약점을 어떻게 보완할까?
앞선 두 가설의 예외 케이스를 보완하기 위해 아래 가설이 추가적으로 필요하다.
- **세대 간 참조 가설** - 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.
**즉, 상호 참조 관계의 두 객체는 생명 주기가 비슷한 경향이 있다.**
이 가설에 따르면 세대 간 참조의 수는 적기에 구세대 전체를 탐색하는 것은 낭비다. 

이를 해결하기 위해 신세대에 **기억 집합**이라는 전역 데이터 구조를 둔다.
이 구조는 **구세대를 작은 조각 몇 개로 나누고, 그중 어느 조각에 세대 간 참조가 있는지 기록해 관리하기 위함**이다.
마이너 GC가 수행되면 세대 간 참조를 포함하는 작은 메모리 블록 안의 객체들만 GC 루트에 추가된다. 

### 3.3.2 마크-스윕 알고리즘
해당 알고리즘은 가장 기본적인 가비지 컬렉션 알고리즘이다.
![[JVM 3장 - 마크-스윕 알고리즘.png]]
방식은 아래와 같다. 
- 회수할 객체를 표시
- 표시된 객체를 회수
단순한만큼 큰 단점이 두 가지 존재한다.
- **실행 효율이 일정하지 않음**
	- 객체가 많아질수록 효율이 떨어짐
- **메모리 파편화가 심함**
	- GC가 회수하고 간 자리에 불연속적인 메모리 파편이 만들어짐
	- 파편화가 심해지면 큰 객체를 만들 수 없고, 이에 추가적인 가비지 컬렉션이 발생

### 3.3.3 마크-카피 알고리즘
앞선 마크-스윕 알고리즘의 단점을 해결하기 위해 나온 알고리즘이다 .
해당 알고리즘은 **가용 메모리 영역을 이등분하여 한 번에 한 블록만 사용**한다.
![[JVM 3장 - 마크-카피 알고리즘.png]]
위 그림에서 볼 수 있듯이 메모리 파편화 문제를 해결할 수 있다. 하지만 여전히 아래와 같은 문제가 존재한다.
- 회수 대상이 적은 경우 여전히 비용 효율이 나쁨(대다수가 회수된다면 ㄱㅊ)
- 이등분하여 한 영역만 사용하기 때문에 메모리 공간을 낭비
#### 그럼에도 불구하고 오늘날 대부분의 상용 VM은 해당 방식을 채택
IBM의 연구 결과 신세대 객체 중 98%가 첫 번째 가비지 컬렉션에서 회수된다는 것을 알게 됐다. 
그러므로 가용 메모리 영역을 반드시 이등분할 필요가 없게 된다. 
이 이론을 구체화하면 아래와 같다.
- 신세대를 하나의 큰 에덴 공간과 두 개의 작은 생존자 공간으로 나눔
- 이 공간의 비율은 8(에덴) : 1(생존자)이다.
- 메모리 할당시 생존자 공간 하나와 에덴만 사용
- 가비지 컬렉션이 시작되면 에덴과 생존자 공간에서 살아남은 객체들을 나머지 생존자 공간으로 복사 후 에덴과 이전 생존자 공간을 지운다.
이를 통해 메모리 낭비 공간을 10%로 줄일 수 있다.

#### 만약 10%(생존자 공간 크기)가 넘는 크기의 객체들이 살아 남는다면?
98%의 객체가 회수된다는 연구 결과는 일반적인 상황을 가정한 결과다.
이를 해결하기 위해 **메모리 할당 보증**이란 메커니즘이 추가된다.
마이너 GC에서 생존한 객체를 생존자 공간에 모두 할당하지 못한다면, 다른 메모리 영역(대부분 구세대)을 활용해 메모리 할당을 보증하는 것이 핵심이다.

### 3.3.4 마크-컴팩트 알고리즘
마크-카피 알고리즘에서 해결하지 못한 문제 하나가 여전히 남아 있다.
- **객체 생존율이 높을수록 효율이 떨어진다.**
때문에 마크-카피 알고리즘은 구세대에는 적합하지 않다. 

![[JVM 3장 - 마크-컴팩트 알고리즘.png]]
표시 단계는 마크-스윕과 같지만 핵심적인 차이는 메모리 이동에 있다. 컴팩트 단계에서 회수 대상을 바로 회수하지 않고, 생존할 객체들을 메모리 영역의 한쪽 끝으로 모은 다음 나머지 공간을 한꺼번에 비운다. 객체를 이동하여 재할당하기 때문에 이동된 객체들을 가리키던 기존 참조들을 모두 갱신해야 한다. 이를 통해 메모리 파편화의 문제를 해결할 수 있다. 

#### 그렇다면 마크-컴팩트 알고리즘으로 충분한가?
구세대처럼 생존 객체가 많다면 이동된 객체들의 기존 참조를 모두 갱신하는 것은 효율이 떨어지는 일이다.
이보다 더 큰 문제는 **객체 이동을 할 땐, 사용자 애플리케이션을 모두 멈춘 상태에서 진행**해야 한다. 이를 'stop the world'라 부른다. 

결국 객체 이동 여부에 따라 아래와 같은 트레이드 오프를 고려해야 한다.
- **객체 이동 o**
	- 스톱더 월드를 최소화거나 없애기 위한 **복잡한 회수 작업**
	- 시스템 전체 처리량 기준에서 유리한 방식
	- 여기서 처리량은 사용자 프로그램과 GC의 효율을 포괄하는 개념
- **객체 이동 x**
	- 메모리 파편화로 해결을 위한 **복잡한 할당 작업**
	- 일시 정지 시간 기준에서 유리한 방식
그러므로 마크-스윕과 마크-컴팩트를 혼용하여 단점을 최대한 상쇄시키는 GC도 존재한다.
-> CMS

## 3.4 핫스팟 알고리즘 상세 구현
### 3.4.1 루트 노드 열거(Root Node Enumeration)
루트 노드 열거란 **도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업**을 말한다.

루트 노드 열거는 반드시 일관성이 보장된 스냅숏 상태에서 수행되어야 하므로 스톱 더 월드 문제를 피할 수 없다. 즉, **해당 작업 중에 참조 관계가 변하면 신뢰성이 깨지게 된다.** 
이는 모든 GC들이 가지고 있는 문제다. 

현재 주류 VM들은 정확한 메모리 관리 기술에 기반한 '정확한 가비지 컬렉션'을 사용한다. 
따라서 사용자 스레드가 정지한 후 실행 컨텍스트와 전역 참조의 위치를 빠짐없이 확인할 필요가 없다. 대신 **가상 머신이 객체 참조가 저장된 위치를 직접 알아낼 방법**이 있어야 한다.

핫스팟은 OopMap이라는 데이터 구조를 사용해 이 문제를 해결한다. 
- 클래스 로딩이 완료되면 객체에 포함된 각 데이터의 타입을 확인
- JIT 컴파일 과정에서 스택의 어느 위치와 어느 레지스터의 데이터가 참조인지 기록
- 이를 통해 컬렉터는 **GC 루트로부터 시작해 추적 없이 스캔 과정에서 정보를 획득**

정리하자면, 아래와 같다.
- 루트 노드 열거에서 모든 참조를 하나씩 탐색하는 것은 효율이 떨어진다.
	- 작업 중 일관성 보장을 위해 스톱 더 월드 문제가 발생하는데 그 양이 많다면 그만큼 지연 시간이 늘어나기 때문이다.
- 이를 해결하기 위해 현대의 JVM은 '정확한 가비지 컬렉션'을 사용
	- 해당 방식은 '정확한 메모리 관리'에 기반한다. 
	- 이를 구현하기 위해 내부적으로 OopMap이란 자료 구조를 사용(핫스팟의 경우)
	- 해당 자료 구조는 JIT 컴파일 단계에서 스캐닝 하는 과정에 초기화 됨
- '정확한 가비지 컬렉션'을 사용하면 실행 컨텍스트와 전역 참조의 위치를 일일이 확인할 필요가 없음
>[!NOTE]
>**정확한 메모리 관리**
>정확한 메모리 관리란 VM이 메모리의 특정 위치에 있는 데이터의 구체적인 자료형을 알 수 있다는 뜻이다.

### 3.4.2 안전 지점
