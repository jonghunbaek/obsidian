---
플랫폼: 프로그래머스
문제 이름: 수식 최대화
알고리즘: 완전탐색
tags:
  - 완전탐색
  - 구현
date: 2025-07-30
aliases:
  - 완전탐색
복습 풀이: 250730(X), 250809(O), 250816(O)
---
# 1차 풀이
```java
private static final String[] OPERATION_ORDER = {"+-*", "+*-", "*-+", "*+-", "-+*", "-*+"};  
  
public long solution(String expression) {  
    List<Integer> values = new ArrayList<>();  
    List<Character> operations = new ArrayList<>();  
    splitExpression(values, operations, expression);  
  
    int max = 0;  
    for (String operation : OPERATION_ORDER) {  
        List<Integer> copyValues = new ArrayList<>(values);  
        List<Character> copyOpr = new ArrayList<>(operations);  
        String result = "";  
        for (char c : operation.toCharArray()) {  
            for (int i = 0; i < operations.size(); i++) {  
                if (c == operations.get(i)) {  
                    int pre = copyValues.get(i * 2);  
                    int post = copyValues.get(i * 2 + 1);  
                    long val = calculate(pre, post, c);  
  
  
                }  
            }  
        }  
  
        max = Math.max(max, Integer.parseInt(result));  
    }  
  
    return max;  
}  
  
private long calculate(int pre, int post, char operation) {  
    if (operation == '+') {  
        return pre + post;  
    } else if (operation == '-') {  
        return pre - post;  
    } else {  
        return pre * post;  
    }  
}  
  
private void splitExpression(List<Integer> values, List<Character> operations, String expression) {  
    StringBuilder sb = new StringBuilder();  
    for (int i = 0; i < expression.length(); i++) {  
        if (!Character.isAlphabetic(expression.charAt(i))) {  
            operations.add(expression.charAt(i));  
            values.add(Integer.parseInt(sb.toString()));  
            sb = new StringBuilder();  
            continue;  
        }  
  
        sb.append(expression.charAt(i));  
    }  
}

/**
* 집와서 2차 풀이
*/
class Solution {
    private static final String[] OPERATION_ORDER = {"+-*", "+*-", "*-+", "*+-", "-+*", "-*+"};  
  
    public long solution(String expression) {  
        List<Long> values = new ArrayList<>();  
        List<Character> operations = new ArrayList<>();  
        splitExpression(values, operations, expression);  
    
        long max = 0;  
        for (String operation : OPERATION_ORDER) {  
            List<Long> copyValues = new ArrayList<>(values);  
            List<Character> copyOpr = new ArrayList<>(operations);  

            for (char c : operation.toCharArray()) {  
                for (int i = 0; i < copyOpr.size(); i++) {  
                    if (c == copyOpr.get(i)) {  
                        long pre = copyValues.get(i);  
                        long post = copyValues.get(i + 1);  
                        long val = calculate(pre, post, c);  
                        
                        copyOpr.remove(i);
                        copyValues.remove(i);
                        copyValues.remove(i);
                        copyValues.add(i, val);
                        
                        i--;
                    }  
                }  
            }  

            max = Math.max(max, Math.abs(copyValues.get(0)));  
        }  

        return max;  
    }  

    private long calculate(long pre, long post, char operation) {  
        if (operation == '+') {  
            return pre + post;  
        } else if (operation == '-') {  
            return pre - post;  
        } else {  
            return pre * post;  
        }  
    }  

    private void splitExpression(List<Long> values, List<Character> operations, String expression) {  
        StringBuilder sb = new StringBuilder();  
        for (int i = 0; i < expression.length(); i++) {  
            if (!Character.isDigit(expression.charAt(i))) {  
                operations.add(expression.charAt(i));  
                values.add(Long.parseLong(sb.toString()));  
                sb = new StringBuilder();  
                continue;  
            }  

            sb.append(expression.charAt(i));  
        }  
        
        if (sb.length() > 0) {
            values.add(Long.parseLong(sb.toString()));
        }
    }
}
```


풀다 말았음. 일단 내용 자체는 어렵지 않았으나 문자열을 분리해서 연산하는 과정을 구현하는 것을 못했음
자세히는 List를 반복문을 돌며 요소를 삭제 하는 부분에 대해서 막힘
이 부분을 고려해 다시 시도해보자.

# 2차 풀이
```java
import java.util.*;
// 연산 경우의 수 = 9, 최대 피연산자 수 = 51 => 시간복잡도를 구하기
// 1. 주어진 문자열을 연산기호에 따라 나눠 각각 다른 배열에 저장
// 2. 연산 우선순위대로 계산하며 배열 인덱스 조정
// 3. 결과 값 절대 값으로 변환 후 반환
class Solution {
    
    private static final String[] OPERATION_ORDERS = new String[] {
      "*+-", "*-+", "+*-", "+-*", "-+*", "-*+"
    };
    
    public long solution(String expression) {
        List<Long> operands = new ArrayList<>();
        List<Character> operations = new ArrayList<>();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < expression.length(); i++) {
            if (!Character.isDigit(expression.charAt(i))) {
                operations.add(expression.charAt(i));
                operands.add(Long.parseLong(sb.toString()));
                sb = new StringBuilder();
                continue;
            }
            
            sb.append(expression.charAt(i));
        }
        
        if (sb.length() != 0) {
            operands.add(Long.parseLong(sb.toString()));
        }
        
        long max = 0;
        int idx = 0;
        for (String order : OPERATION_ORDERS) {
            List<Long> copyOperands = new ArrayList<>(operands);
            List<Character> copyOperations = new ArrayList<>(operations);
            for (int i = 0; i < order.length(); i++) {
                calculate(order.charAt(i), copyOperands, copyOperations);
            }
            
            max = Math.max(max, Math.abs(copyOperands.get(0)));
            idx++;
        }
        
        return max;
    }
    
    private void calculate(char operation, List<Long> operands, List<Character> operations) {
        for (int i = 0; i < operations.size(); i++) {
            if (operations.get(i) == operation) {
                long pre = operands.get(i);
                long post = operands.get(i + 1);
                long result = calculate(pre, post, operation);

                operands.remove(i);
                operands.remove(i);
                operands.add(i, result);
                operations.remove(i);
                i--;
            }
        }
    }
    
    private long calculate(long pre, long post, char operation) {
        if (operation == '+') {
            return pre + post;
        } else if (operation == '-') {
            return pre - post;
        } else {
            return pre * post;
        }
    }
}
```
찝찝하게 풀었지만 여차저차 풀긴함
가장 애매한 부분은 연산자와 피연산자를 분리하는 부분인 것 같음

# 3차 풀이
```java
// 1. 입력으로 받은 문자열을 계산하여 최대 값을 구해야 함
// 2. 모든 조건은 동일하지만, 연산자의 우선 순위를 변경하며 계산해야 함. 
// 3. +- 구분하지 않고 절대 값으로 가장 큰 값을 반환해야 함
import java.util.*;

class Solution {
    
    private static final String[] PRIORITIES = {
        "+-*", "+*-", "-+*", "-*+", "*+-", "*-+"
    };
    
    public long solution(String expression) {
        List<String> operands = new ArrayList<>();
        List<Character> operations = new ArrayList<>();
        splitByOperation(operands, operations, expression);
        
        long max = 0;
        for (String priority : PRIORITIES) {
            max = Math.max(max, Math.abs(calculateByOperationPriorirty(priority, operands, operations)));
        }
        
        return max;
    }
    
    private void splitByOperation(List<String> operands, List<Character> operations, String expression) {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < expression.length(); i++) {
            char target = expression.charAt(i);
            if (!Character.isDigit(target)) {
                operations.add(target);
                operands.add(sb.toString());
                sb = new StringBuilder();
                continue;
            }
            
            sb.append(target);
        }
        
        if (sb.length() > 0) {
            operands.add(sb.toString());
        }
    }
    
    private long calculateByOperationPriorirty(String priority, List<String> operands, List<Character> operations) {
        List<String> copyOperands = new ArrayList<>(operands);
        List<Character> copyOperations = new ArrayList<>(operations);
        for (char op : priority.toCharArray()) {
            calculate(op, copyOperands, copyOperations);
        }
        
        return Long.parseLong(copyOperands.get(0));
    }
    
    private void calculate(char op, List<String> operands, List<Character> operations) {
        for (int i = 0; i < operations.size(); i++) {
            if (op == operations.get(i)) {
                long pre = Long.parseLong(operands.get(i));
                long post = Long.parseLong(operands.get(i + 1));
                long result = operate(pre, post, op);
                
                operands.remove(i);
                operands.remove(i);
                operands.add(i, String.valueOf(result));
                operations.remove(i);
                i--;
            }
        }
    }
    
    private long operate(long pre, long post, char operation) {
        if (operation == '+') {
            return pre + post;
        } else if (operation == '-') {
            return pre - post;
        } else {
            return pre * post;
        }
    }
}
```
무난하게 풀었지만 시간이 제법 걸림
시간을 단축하며 풀어보고, 연산자/피연산자를 두 개의 List로 관리하지 않고 StringTokenizer를 활용하는 방법으로 풀어보기