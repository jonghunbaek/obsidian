---
플랫폼: 프로그래머스
알고리즘: 구현, 해시, 배열
tags:
  - 구현
  - 해시
  - 배열
date: 2025-12-23
복습 풀이: 251223(O)
---
# 1차 풀이
```java
// 선물 개수 -> 선물 지수 -> X
// 친구 목록을 2차원 배열로 저장
// 친구 이름을 key로, 인덱스를 배열로 저장
// gifts를 순회하며 2차원 배열 갱신
// 결과 계산

import java.util.*;

class Solution {
    public int solution(String[] friends, String[] gifts) {
        int[][] counts = new int[friends.length][friends.length];
        Map<String, Integer> indexByFriend = new HashMap<>();
        for (int i = 0; i < friends.length; i++) {
            indexByFriend.put(friends[i], i);
        }
        
        for (String gift : gifts) {
            String giver = gift.split(" ")[0];
            String receiver = gift.split(" ")[1];
            
            int giverIdx = indexByFriend.get(giver);
            int receiverIdx = indexByFriend.get(receiver);
            counts[giverIdx][receiverIdx]++;
        }
        
        int[] countReceived = new int[friends.length];
        for (int i = 0; i < counts.length; i++) {
            for (int j = 0; j < counts[i].length; j++) {
                if (i == j || counts[i][j] < counts[j][i]) continue;
                
                if (counts[i][j] > counts[j][i]) {
                    countReceived[i]++;
                    continue;
                } 
                
                if (calculateGiftIdx(i, counts) > calculateGiftIdx(j, counts)) {
                    countReceived[i]++;
                }
            }
        }
        
        int max = 0;
        for (int i = 0; i < countReceived.length; i++) {
            max = Math.max(max, countReceived[i]);
        }
        
        return max;
    }
    
    private int calculateGiftIdx(int target, int[][] counts) {
        int givingTotal = 0;
        int receivingTotal = 0;
        for (int i = 0; i < counts.length; i++) {
            givingTotal += counts[target][i];
            receivingTotal += counts[i][target];
        }
        
        return givingTotal - receivingTotal;
    }
    
}
```
작년 초에 한번 풀었던 문제라 그런가 이해도도 빨랐고, 결과적으로 풀이 과정도 유사했음
