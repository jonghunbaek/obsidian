---
플랫폼: 프로그래머스
문제 이름: 메뉴 리뉴얼
알고리즘: 재귀, 정렬
tags:
  - 재귀
  - 정렬
date: 2025-08-12
aliases:
  - 재귀
복습 풀이: 2025-08-12(X)
---
# 1차 풀이
```java
import java.util.*;
import java.util.stream.*;

// 1. course를 순회하며 코스 메뉴의 개수를 파악
// 2. 개수에 따라 orders를 순회
// 3. 하나의 order에서 개수에 맞는 조합을 모두 찾아 Map에 저장
// 4. 한 코스에 대한 모든 조합이 Map 저장되고, 가장 많이 주문된 조합을 결과 List에 저장
//  4-1. 이 때,  주문 최대 횟수가 동일하다면 동일한 값 모두 저장
// 5. 결과 List를 사전순으로 정렬하여 반환
class Solution {
    public String[] solution(String[] orders, int[] course) {
        List<String> results = new ArrayList<>();
        for (int size : course) {
            Map<String, Integer> countByMenu = new HashMap<>();
            for (int i = 0; i < orders.length; i++) {
                combineMenu(0, size, orders[i], new HashSet<>(), countByMenu);
            }

            int max = countByMenu.values().stream()
                 .mapToInt(i -> i)
                 .max()
                 .orElse(0);

            
            if (max >= 2) {
                 List<String> menus = countByMenu.entrySet().stream()
                     .filter(entry -> entry.getValue() == max)
                     .map(Map.Entry::getKey)
                     .collect(Collectors.toList());

                 results.addAll(menus);
            }
        }

        results.sort(String::compareTo);

        return results.toArray(String[]::new);
    }

    private void combineMenu(int depth, int size, String order, Set<String> target, Map<String, Integer> countByMenu) {
        if (target.size() == size) {
            String value = target.stream()
                    .sorted()
                    .collect(Collectors.joining());

            countByMenu.put(value, countByMenu.getOrDefault(value, 0) + 1);
            return;
        }

        for (int i = depth; i < order.length(); i++) {
            target.add(String.valueOf(order.charAt(i)));
            combineMenu(i + 1, size, order, target, countByMenu);
            target.remove(String.valueOf(order.charAt(i)));
        }
    }

}
```
이해하고 보니 어렵지 않은 문제.
하지만 카카오답게 놓칠 수 있는 여러 조건이 존재했음.
일단 가장 애먹었던 부분은 메뉴에서 가장 많이 존재하는 메뉴 조합을 찾는 것이었음
단순한 재귀로 풀다가 애를 많이 먹음.
이건 별도로 정리할 필요가 있음