---
플랫폼: 프로그래머스
문제 이름: 소수 찾기
알고리즘: 완전탐색
tags:
  - 완전탐색
date: 2025-07-31
aliases:
  - 완전탐색
복습 풀이: 250731(X), 250809(O), 250816(O), 251031(O), 251103(O)
---
# 1차 풀이
```java
import java.util.*;
// 1. 문자열을 문자로 분리해서 배열로 만들기
// 2. 문자를 조합해서 생성 가능한 모든 숫자를 만들기
// 3. 최댓값 9999999이하의 모든 소수를 찾아 배열로 만들기
// 4. 배열을 순회하며 문자 조합 소수가 존재하는지 판별
class Solution {
    public int solution(String numbers) {
        char[] chars = numbers.toCharArray();
        Set<Integer> numberSet = new HashSet<>(); // 중복 숫자 넣지 않기
        boolean[] visited = new boolean[chars.length]; // 같은 숫자 탐색하지 않기
        createNumbers(chars, visited, numberSet, "");
        List<Integer> primeNumbers = findPrimeNumbers();

        int count = 0;
        for (int primeNumber : primeNumbers) {
            if (numberSet.contains(primeNumber)) {
                count++;
            }
        }

        return count;
    }

    private void createNumbers(char[] chars, boolean[] visited, Set<Integer> numberSet, String target) {
        if (!target.isBlank()) {
            numberSet.add(Integer.parseInt(target));
        }

        if (target.length() == chars.length) {
            return;
        }

        for (int i = 0; i < chars.length; i++) {
            if (visited[i]) {
                continue;
            }

            visited[i] = true;
            createNumbers(chars, visited, numberSet, target + chars[i]);
            visited[i] = false;
        }
    }

    private List<Integer> findPrimeNumbers() {
        boolean[] isPrime = new boolean[10000000];
        Arrays.fill(isPrime, true);
        isPrime[0] = false;
        isPrime[1] = false;
        for (int i = 2; i < Math.sqrt(isPrime.length); i++) {
            if (isPrime[i]) {
                for (int j = i * i; j < isPrime.length; j += i) {
                    isPrime[j] = false;
                }
            }
        }

        List<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i < isPrime.length; i++) {
            if (isPrime[i]) {
                primeNumbers.add(i);
            }
        }

        return primeNumbers;
    }
}
```
가능한 모든 경우의 숫자를 만드는 것까진 성공적. 
소수를 찾는 메서드를 해결하지 못해 실패.
소수를 구하는 방법을 최대한 암기하기

**더 최적화된 방법 또한 알아보기**

# 2차 풀이
```java
import java.util.*;
// 1. 문자열로 만들 수 있는 모든 수 Set에 저장
// 2. 해당 수가 소수인지 판별
// 3. 결과 카운트하여 반환
class Solution {
    public int solution(String numbers) {
        Set<Integer> targets = new HashSet<>();
        createNumbers(new boolean[numbers.length()], numbers, "", targets);
        
        int count = 0;
        for (int target : targets) {
            if (isPrime(target) && target != 1 && target != 0) {
                count++;
            }
        }
        return count;
    }
    
    private void createNumbers(boolean[] visited, String numbers, String target, Set<Integer> targets) {
        if (!target.isEmpty()) {
            targets.add(Integer.parseInt(target));
        }
        
        if (target.length() == numbers.length()) {
            return;
        }
        
        for (int i = 0; i < numbers.length(); i++) {
            if (visited[i]) {
                continue;
            }
            
            visited[i] = true;
            createNumbers(visited, numbers, target + numbers.charAt(i), targets);
            visited[i] = false;
        }
    }
    
    private boolean isPrime(int target) {
        for (int i = 2; i < target; i++) {
            if (target % i == 0) {
                return false;
            }
        }
        
        return true;
    }
}
```
1차 풀이와 달리 전체 숫자 조합을 구하는 것에 애를 먹음
방문 배열을 쓸 때, 안 쓸 때를 구분하는 것이 어려움

# 3차 풀이
```java
// 1. 입력으로 받은 문자열을 문자로 분리하여 모든 숫자 조합 구하기
// 2. 해당 숫자가 소수인지 판별
import java.util.*;

class Solution {
    public int solution(String numbers) {
        Set<Integer> targets = new HashSet<>();
        createAllCases("", targets, numbers, new boolean[numbers.length()]);
        targets.forEach(target -> System.out.println(target));
        return (int)targets.stream()
            .filter(target -> isPrime(target))
            .count();
    }
    
    private void createAllCases(String target, Set<Integer> targets, String numbers, boolean[] visited) {
        if (!target.isEmpty()) {
            targets.add(Integer.valueOf(target));
        }
        
        if (target.length() == numbers.length()) {
            return;
        }
        
        for (int i = 0; i < numbers.length(); i++) {
            if (visited[i]) {
                continue;
            }
            
            visited[i] = true;
            createAllCases(target + numbers.charAt(i), targets, numbers, visited);
            visited[i] = false;
        }
    }
    
    private boolean isPrime(int target) {
        if (target <= 1) {
            return false;
        }
        
        for (int i = 2; i < target; i++) {
            if (target % i == 0) {
                return false;
            }
        }
        
        return true;
    }
}
```
숫자 조합을 구할 때, 순서가 중요하므로 방문 배열을 사용.
단, 중복 조합은 제외해야 하므로 Set을 활용

# 4차 풀이
```JAVA
import java.util.*;

class Solution {
    public int solution(String numbers) {
        Set<Integer> targets = combineNumbers(numbers);
     
        int count = 0;
        for (int target : targets) {
            if (isPrimary(target)) count++;
        }
        
        return count;
    }
    
    private Set<Integer> combineNumbers(String numbers) {
        Set<Integer> results = new HashSet<>();
        boolean[] visited = new boolean[numbers.length()];
        dfs("", numbers, visited, results);
        
        return results;
    }
    
    private void dfs(String target, String numbers, boolean[] visited, Set<Integer> results) {
        if (!target.isEmpty()) results.add(Integer.parseInt(target));
        if (target.length() == numbers.length()) return;
        
        for (int i = 0; i < numbers.length(); i++) {
            if (visited[i]) continue;
            
            visited[i] = true;
            dfs(target + numbers.substring(i, i + 1), numbers, visited, results);
            visited[i] = false;
        }
    }
    
    private boolean isPrimary(int target) {
        if (target == 0 || target == 1) return false;
        
        for (int i = 2; i <= Math.sqrt(target); i++) {
            if (target % i == 0) return false;
        }
        
        return true;
    }
}
```

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String numbers) {
        Set<Integer> set = createNumberSet(numbers);
        
        return (int) set.stream()
            .filter(number -> isPrime(number))
            .count();
    }
    
    private Set<Integer> createNumberSet(String numbers) {
        Set<Integer> results = new HashSet<>();
        boolean[] visited = new boolean[numbers.length()];
        
        dfs("", numbers, visited, results);
        
        return results;
    }
    
    private void dfs(String target, String numbers, boolean[] visited, Set<Integer> results) {
        if (!target.isEmpty()) results.add(Integer.parseInt(target));
        if (target.length() == numbers.length()) return;
        
        for (int i = 0; i < numbers.length(); i++) {
            if (visited[i]) continue;
            
            visited[i] = true;
            dfs(target + String.valueOf(numbers.charAt(i)), numbers, visited, results);
            visited[i] = false;
        }
    }
    
    private boolean isPrime(int number) {
        if (number == 0 || number == 1) return false;
        
        for (int i = 2; i <= Math.sqrt(number); i++) {
            if (number % i == 0) return false;
        }
        
        return true;
    }
}
```