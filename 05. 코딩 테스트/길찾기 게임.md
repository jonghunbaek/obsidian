---
플랫폼: 프로그래머스
문제 이름: 길찾기 게임
알고리즘: 그래프, 이진트리
tags:
  - 그래프
  - 이진트리
date: 2025-09-09
aliases:
  - 그래프
복습 풀이: 250909(X), 250913(X), 250920(O), 251004(O), 251010(O), 251017(O)
---
# 1차 풀이
```java
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        List<Node> nodes = new ArrayList<>();
        for (int i = 1;  i <= nodeinfo.length; i++) {
            nodes.add(new Node(i, new Point(nodeinfo[i - 1][0], nodeinfo[i - 1][1])));
        }

        nodes.sort((n1, n2) -> {
            if (n2.point.y == n1.point.y) {
                return n1.point.x - n2.point.x;
            }

            return n2.point.y - n1.point.y;
        });

        Node root = buildBinaryTree(nodes);
        List<Integer> preOrder = new ArrayList<>();
        List<Integer> postOrder = new ArrayList<>();
        orderPre(root, preOrder);
        orderPost(root, postOrder);

        return new int[][] {
                preOrder.stream().mapToInt(Integer::valueOf).toArray(),
                postOrder.stream().mapToInt(Integer::valueOf).toArray()
        };
    }

    private Node buildBinaryTree(List<Node> nodes) {
        Node root = nodes.get(0);
        for (int i = 1; i < nodes.size(); i++) {
            insertNode(root, nodes.get(i));
        }

        return root;
    }

    private void insertNode(Node parent, Node child) {
        if (child.point.x < parent.point.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            }  else {
                insertNode(parent.right, child);
            }
        }
    }

    private void orderPre(Node node, List<Integer> results) {
        if (node == null) {
            return;
        }

        results.add(node.no);
        orderPre(node.left, results);
        orderPre(node.right, results);
    }

    private void orderPost(Node node, List<Integer> results) {
        if (node == null) {
            return;
        }

        orderPost(node.left, results);
        orderPost(node.right, results);
        results.add(node.no);
    }

    static class Node {
        private int no;
        private Point point;
        private Node left;
        private Node right;

        public Node(int no, Point point) {
            this.no = no;
            this.point = point;
        }
    }

    static class Point {
        private int x;
        private int y;

        public Point(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}	
```
그래프는 쉽지 않다..
이진트리를 구현하기 위해 객체를 만들고, 정렬을 하여 재귀적으로 탐색
배열로도 이진트리를 구현할 수 있음. 다만 완전 이진 트리인 경우에 유효한 선택임
### 인덱스 규칙

```
부모 노드: i
왼쪽 자식: 2*i + 1
오른쪽 자식: 2*i + 2
부모: (i-1)/2
```
### 핵심 문제점
1. **노드 위치 예측 불가**: y좌표와 x좌표가 불규칙해서 배열 인덱스를 미리 계산할 수 없음
2. **메모리 낭비**: 빈 공간이 너무 많음
3. **동적 삽입의 어려움**: BST 삽입 과정을 배열로 구현하기 복잡

# 2차 풀이
```java
// 1. 이진 트리 만들기
// 2. 이진 트리를 전위 순회, 후위 순회한 결과 반환
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        List<Node> nodes = new ArrayList<>();
        for (int i = 1; i <= nodeinfo.length; i++) {
            nodes.add(new Node(i, nodeinfo[i - 1][0], nodeinfo[i - 1][1]));
        }
        
        nodes.sort((n1, n2) -> {
            if (n2.y == n1.y) {
                return n1.x - n2.x;
            }

            return n2.y - n1.y;
        });
        
        buildTree(nodes);
        Node root = nodes.get(0);
        
        List<Integer> pre = new ArrayList<>();
        preOrder(root, pre);
        
        List<Integer> post = new ArrayList<>();
        postOrder(root, post);
        
        return new int[][] {
            pre.stream().mapToInt(Integer::intValue).toArray(),
            post.stream().mapToInt(Integer::intValue).toArray()
        };
    }
    
    private void buildTree(List<Node> nodes) {
        Node root = nodes.get(0);
        for (int i = 1; i < nodes.size(); i++) {
            insertNode(root, nodes.get(i));
        }
    }
    
    private void insertNode(Node parent, Node child) {
        if (child.x < parent.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    private void preOrder(Node root, List<Integer> pre) {
        if (root == null) {
            return;
        }
        
        pre.add(root.no);
        preOrder(root.left, pre);
        preOrder(root.right, pre);
    }
    
    private void postOrder(Node root, List<Integer> post) {
        if (root == null) {
            return;
        }
        
        postOrder(root.left, post);
        postOrder(root.right, post);
        post.add(root.no);
    }
    
    static class Node {
        int no;
        int x;
        int y;
        Node left;
        Node right;
        
        public Node(int no, int x, int y) {
            this.no = no;
            this.x = x;
            this.y = y;
        }
    }
}
```
전위/후위 순회는 어렵지 않음.
이진 트리를 만든느 재귀를 짜는 것이 힘듦.
- 루트 노드를 기준으로 나머지 자식 노드들을 순차적으로 인자로 전달
- 부모 노드의 left, right값이 초기화 안된 지점까지 재귀 탐색하며 탐색 후 값 초기화
- 이 정렬의 핵심은 노드를 먼저 y와 x값을 기준으로 정렬하는 것

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        List<Node> nodes = new ArrayList<>();
        for (int i = 1; i <= nodeinfo.length; i++) {
            nodes.add(new Node(i, nodeinfo[i - 1][0], nodeinfo[i - 1][1]));
        }
        
        nodes.sort((n1, n2) -> n2.y - n1.y);
        Node root = buildTree(nodes);
        
        List<Integer> preOrder = new ArrayList<>();
        orderPre(root, preOrder);
        List<Integer> postOrder = new ArrayList<>();
        orderPost(root, postOrder);
        
        return new int[][] {
            preOrder.stream().mapToInt(Integer::intValue).toArray(),
            postOrder.stream().mapToInt(Integer::intValue).toArray(),
        };
    }
    
    private Node buildTree(List<Node> nodes) {
        Node root = nodes.get(0);
        for (int i = 1; i < nodes.size(); i++) {
            insertNode(root, nodes.get(i));
        }
        return root;
    }
    
    private void insertNode(Node parent, Node child) {
        if (child.x < parent.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    private void orderPre(Node node, List<Integer> preOrder) {
        if (node == null) {
            return;
        }
        
        preOrder.add(node.no);
        orderPre(node.left, preOrder);
        orderPre(node.right, preOrder);
    }
    
    private void orderPost(Node node, List<Integer> postOrder) {
        if (node == null) {
            return;
        }
        
        
        orderPost(node.left, postOrder);
        orderPost(node.right, postOrder);
        postOrder.add(node.no);
    }
    
    static class Node {
        int no;
        int x;
        int y;
        Node left;
        Node right;
        
        public Node(int no, int x, int y) {
            this.no = no;
            this.x = x;
            this.y = y;
        }
    }
}
```
이분탐색과 마찬가지로 통째로 외우며 이해하는 것이 나을 듯.. 여러번 풀어보기

# 4차 풀이
```java
// 1. y값을 기준으로 노드 정보를 정렬한 뒤에 Node 객체로 변환
// 2. 배열의 첫번째 값이 루트 노드이므로 루트 노드 기준으로 이진 트리 생성
// 3. 생성된 이진트리를 기준으로 전위/후위 재귀 탐색하여 결과를 기록
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        Node[] nodes = new Node[nodeinfo.length];
        for (int i = 1; i <= nodeinfo.length; i++) {
            nodes[i - 1] = new Node(i, nodeinfo[i - 1][0], nodeinfo[i - 1][1]);
        }
        
        Arrays.sort(nodes, (n1, n2) -> n2.y - n1.y);
        buildTree(nodes);
        List<Integer> pre = new ArrayList<>();
        List<Integer> post = new ArrayList<>();
        
        orderPre(nodes[0], pre);
        orderPost(nodes[0], post);
        
        return new int[][] {
            pre.stream().mapToInt(Integer::intValue).toArray(),
            post.stream().mapToInt(Integer::intValue).toArray(),
        };
    }
    
    private void buildTree(Node[] nodes) {
        Node root = nodes[0];
        for (int i = 1; i < nodes.length; i++) {
            insertNode(root, nodes[i]);
        }
    }
    
    private void insertNode(Node parent, Node child) {
        if (parent.x > child.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    private void orderPre(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        result.add(node.no);
        orderPre(node.left, result);
        orderPre(node.right, result);
    }
    
    private void orderPost(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        orderPost(node.left, result);
        orderPost(node.right, result);
        result.add(node.no);
    }
    
    static class Node {
        int no;
        int x;
        int y;
        Node left;
        Node right;
        
        public Node(int no, int x, int y) {
            this.no = no;
            this.x = x;
            this.y = y;
        }
    }
}
```
문제 이해도가 많이 높아졌고, 한번만 더 풀어보기.

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        Node[] nodes = new Node[nodeinfo.length];
        for (int i = 1; i <= nodeinfo.length; i++) {
            nodes[i - 1] = new Node(i, nodeinfo[i - 1][0], nodeinfo[i - 1][1]);
        }
        
        Arrays.sort(nodes, (n1, n2) -> n2.y - n1.y);
        buildTree(nodes);
        
        List<Integer> pre = new ArrayList<>();
        preOrder(nodes[0], pre);
        
        List<Integer> post = new ArrayList<>();
        postOrder(nodes[0], post);
        
        
        return new int[][] {
            pre.stream().mapToInt(Integer::intValue).toArray(),
            post.stream().mapToInt(Integer::intValue).toArray(),
        };
    }
    
    private void buildTree(Node[] nodes) {
        Node root = nodes[0];
        for (int i = 1; i < nodes.length; i++) {
            insertNode(root, nodes[i]);
        }
    }
    
    private void insertNode(Node parent, Node child) {
        if (parent.x > child.x) {
            if (parent.left == null) {
                parent.left = child;    
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    private void preOrder(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        result.add(node.no);
        preOrder(node.left, result);
        preOrder(node.right, result);
    }
    
    private void postOrder(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        postOrder(node.left, result);
        postOrder(node.right, result);
        result.add(node.no);
    }
    
    static class Node {
        int no;
        int x;
        int y;
        Node left;
        Node right;
        
        public Node(int no, int x, int y) {
            this.no = no;
            this.x = x;
            this.y = y;
        }
    }
}
```
답안을 외운 느낌이라 천천히 곱씹어보며 한 번 더 풀어보기

# 6차 풀이
```java
import java.util.*;

class Solution {
    public int[][] solution(int[][] nodeinfo) {
        Node[] nodes = new Node[nodeinfo.length];
        for (int i = 1; i <= nodeinfo.length; i++) {
            nodes[i - 1] = new Node(i, nodeinfo[i - 1][0], nodeinfo[i - 1][1]);
        }
        
        Arrays.sort(nodes, (n1, n2) -> n2.y - n1.y);
        buildTree(nodes);
        
        List<Integer> pre = new ArrayList<>();
        orderPre(nodes[0], pre);
        List<Integer> post = new ArrayList<>();
        orderPost(nodes[0], post);
        
        return new int[][] {
            pre.stream().mapToInt(Integer::intValue).toArray(),
            post.stream().mapToInt(Integer::intValue).toArray(),
        };
    }
    
    private void buildTree(Node[] nodes) {
        Node root = nodes[0];
        for (int i = 1; i < nodes.length; i++) {
            insertNode(root, nodes[i]);
        }
    }
    
    private void insertNode(Node parent, Node child) {
        if (parent.x > child.x) {
            if (parent.left == null) {
                parent.left = child;
            } else {
                insertNode(parent.left, child);
            }
        } else {
            if (parent.right == null) {
                parent.right = child;
            } else {
                insertNode(parent.right, child);
            }
        }
    }
    
    private void orderPre(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        result.add(node.no);
        orderPre(node.left, result);
        orderPre(node.right, result);
    }
    
    private void orderPost(Node node, List<Integer> result) {
        if (node == null) {
            return;
        }
        
        orderPost(node.left, result);
        orderPost(node.right, result);
        result.add(node.no);
    }
    
    static class Node {
        private int no, x, y;
        private Node left, right;
        
        public Node(int no, int x, int y) {
            this.no = no;
            this.x = x;
            this.y = y;
        }
    }
}
```
이진 트리는 어렵지 않지만 자식 노드가 2개를 초과한다면...?