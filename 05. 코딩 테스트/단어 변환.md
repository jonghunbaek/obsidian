---
플랫폼: 프로그래머스
문제 이름: 단어 변환
알고리즘: DFS, BFS
tags:
  - BFS
  - DFS
date: 2025-10-06
aliases:
  - DFS, BFS
복습 풀이: 251006(O), 251011(O), 251019(O), 251025(O), 251101(O)
---
# 1차 풀이
```java
class Solution {
    
    static int result = Integer.MAX_VALUE;
    
    public int solution(String begin, String target, String[] words) {
        boolean[] visited = new boolean[words.length];
        count(0, begin, target, words, visited);
        
        return result == Integer.MAX_VALUE ? 0 : result;
    }
    
    private void count(int depth, String begin, String target, String[] words, boolean[] visited) {
        if (begin.equals(target)) {
            result = Math.min(result, depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            if (visited[i]) {
                continue;
            }
            
            String value = convert(begin, words[i]);
            if (value == "") {
                continue;
            }
            
            visited[i] = true;
            count(depth + 1, value, target, words, visited);
            visited[i] = false;
        }
    }
    
    private String convert(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return "";
        }
  
        int count = 0;
        for (int i = 0; i < s1.length(); i++) {
            if (s1.charAt(i) != s2.charAt(i)) {
                count++;
            }
            
            if (count > 1) {
                return "";
            }
        }
 
        return s2;
    }
}
```
디버깅을 굉장히 오래하여 풀었음
다음 풀이에선 다음 부분을 고려해서 풀어보기.
- BFS로 풀기
- 정적 변수를 사용하지 않고 풀기

# 2차 풀이
```java
// 1. words 길이의 방문 배열을 만들어 한번 변환한 단어는 다시 사용하지 못하도록 만들기
// 2. words를 모두 순회했음에도 찾지 못했다면 0
// 3. 찾았다면 값을 저장
// 4. 저장된 값을 정렬해 최솟값을 반환
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        boolean[] visited = new boolean[words.length];
        List<Integer> results = new ArrayList<>();
        find(0, begin, target, words, visited, results);
        
        return results.stream()
            .mapToInt(Integer::intValue)
            .min()
            .orElse(0);
    }
    
    private void find(int depth, String from, String target, String[] words, boolean[] visited, List<Integer> results) {
        if (target.equals(from)) {
            results.add(depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            String value = convert(from, words[i]);
            if (visited[i] || value.isEmpty()) {
                continue;
            }
            
            visited[i] = true;
            find(depth + 1, value, target, words, visited, results);
            visited[i] = false;
        }
    }
    
    private String convert(String origin, String target) {
        if (origin.length() != target.length()) {
            return "";
        }
        
        int count = 0;
        for (int i = 0; i < origin.length(); i++) {
            if (origin.charAt(i) != target.charAt(i)) {
                count++;
            }
        }
        
        return count > 1 ? "" : target;
    }
}
```
살짝 더듬으며 푼듯 
bfs 풀이를 보니 visited를 다시 false로 바꿔주지 않는데 어떤 차이인지 확인필요함
다음 풀이에 BFS를 활용해보기.

# 3차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        PriorityQueue<Integer> result = new PriorityQueue<>();
        convertToTarget(result, 0, begin, target, words, new boolean[words.length]);
        
        return result.isEmpty() ? 0 : result.poll();
    }
    
    private void convertToTarget(PriorityQueue<Integer> result, int depth, String from, String target, String[] words, boolean[] visited) {
        if (from.equals(target)) {
            result.offer(depth);
            return;
        }
        
        for (int i = 0; i < words.length; i++) {
            String value = convert(from, words[i]);
            if (visited[i] || value.isEmpty()) continue;
            
            visited[i] = true;
            convertToTarget(result, depth + 1, value, target, words, visited);
            visited[i] = false;
        }
    }
    
    private String convert(String from, String target) {
        if (from.length() != target.length()) return "";
        
        int count = 0;
        for (int i = 0; i < from.length(); i++) {
            if (target.charAt(i) != from.charAt(i)) count++;
        }
        
        return count == 1 ? target : "";
    }
}
```
- bfs로 풀어보기
- 우선 순위 큐 사용하지 않기

# 4차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        return bfs(begin, target, words);
    }
    
    private int bfs(String begin, String target, String[] words) {
        Queue<Conversion> q = new LinkedList<>();
        q.add(new Conversion(begin, 0));
        boolean[] visited = new boolean[words.length];
        
        while (!q.isEmpty()) {
            Conversion current = q.poll();
            
            if (current.word.equals(target)) return current.count;
            
            for (int i = 0; i < words.length; i++) {
                String value = current.convert(words[i]);
                if (visited[i] || value.isEmpty()) continue;
                
                visited[i] = true;
                q.add(new Conversion(value, current.count + 1));
            }
        }
        
        return 0;
    }
    
    static class Conversion {
        private String word;
        private int count;
        
        public Conversion(String word, int count) {
            this.word = word;
            this.count = count;
        }
        
        public String convert(String target) {
            if (this.word.length() != target.length()) return "";
            
            int count = 0;
            for (int i = 0; i < target.length(); i++) {
                if (target.charAt(i) != this.word.charAt(i)) count++;
            }

            return count == 1 ? target : "";
        }
    }
}
```
bfs로 풀었음
근데 왠지 bfs로 풀면 엣지 케이스가 존재할 것 같은데, 확인이 필요할듯

--- 
`나중에 "hot"이 큐에서 꺼내져서 words를 순회할 때, "hat"은 이미 visited[1] = true이므로 건너뜀. 이 부분에서 hot을 다시 hat으로 바꾸고 정답을 찾아가는 엣지 케이스가 존재하냐는 말이었어. hat을 거쳐야만 정답이 될 수 있는데, hat의 visited가 이미 true라면 해당 케이스는 무시되는 거잖아.`

아! 이제 완벽하게 이해했습니다!
**"hot → hat → ... → target" 경로가 최단 경로인데, hot을 먼저 방문해서 hat을 visited 처리해버리면 이 경로를 놓치는 것 아니냐?"**
## 결론: **이런 엣지 케이스는 존재하지 않습니다!**

### 이유: BFS의 레벨 순회 특성
```
begin = "hit"
target = "cot"
words = ["hot", "hat", "cat", "cot"]

레벨 0: hit
레벨 1: hot, hat (hit에서 한 글자만 다름)
레벨 2: cat (hot→cat, hat→cat 둘 다 가능)
레벨 3: cot
```

**핵심:** 만약 `hot → hat → cot`이 최단 경로라면, `hit → hat → cot`도 같은 길이의 경로입니다!
- `hit → hot → hat → cot` (3단계)
- `hit → hat → cot` (2단계) ← 더 짧음!
**BFS는 레벨별로 탐색하므로:**
- hat을 hot을 거쳐서 가는 것(레벨 2) 보다
- hit에서 직접 hat으로 가는 것(레벨 1)이 항상 더 빠릅니다
## 반례가 불가능한 이유:
만약 `A → B → C → target`이 최단 경로라면:
- `A`에서 `C`로 직접 갈 수 있다면 → `A → C → target`이 더 짧음
- `A`에서 `C`로 직접 못 간다면 → `B`와 `C`는 2글자 이상 차이 → `B → C` 변환 불가능

**한 글자씩만 변환 가능하다는 제약** 때문에, 더 긴 우회 경로를 거쳐야만 도달할 수 있는 단어는 존재하지 않습니다!
## 결론:

당신이 고민한 엣지 케이스는 **"한 글자씩만 바꿀 수 있다"**는 문제의 제약 조건 때문에 **수학적으로 불가능**합니다. BFS + visited 처리가 완벽하게 작동하는 이유입니다! ✅

---

# 5차 풀이
```java
import java.util.*;

class Solution {
    public int solution(String begin, String target, String[] words) {
        Queue<Conversion> q = new LinkedList<>();
        q.add(new Conversion(begin, 0));
        boolean[] visited = new boolean[words.length];
        
        while (!q.isEmpty()) {
            Conversion current = q.poll();
            
            if (current.word.equals(target)) return current.count;
            
            for (int i = 0; i < words.length; i++) {
                String value = current.convert(words[i]);
                if (visited[i] || value.isEmpty()) continue;
                
                visited[i] = true;
                q.add(new Conversion(value, current.count + 1));
            }
        }
        
        return 0;
    }
    
    static class Conversion {
        private String word;
        private int count;
        
        public Conversion(String word, int count) {
            this.word = word;
            this.count = count;
        }
        
        public String convert(String target) {
            if (word.length() != target.length()) return "";
            int count = 0;
            for (int i = 0; i < word.length(); i++) {
                if (word.charAt(i) != target.charAt(i)) count++;
            }
            
            return count == 1 ? target : "";
        }
    }
}
```