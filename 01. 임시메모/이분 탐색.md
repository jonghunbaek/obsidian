```java
// 1단계: 탐색 범위 설정
int start = 가능한 답의 최솟값;
int end = 가능한 답의 최댓값;
int answer = 0; // 답을 저장할 변수

// 2단계: 반복문 조건 설정
while (start <= end) {
    int mid = (start + end) / 2; // 중앙값 (Integer overflow 방지)

    // 3단계: 결정 함수 호출
    if (isPossible(mid)) {
        // 4단계: 범위 좁히기
        // (문제 유형에 따라 이 부분의 로직이 달라짐)
    } else {
        // (문제 유형에 따라 이 부분의 로직이 달라짐)
    }
}
return answer;
```
### 1단계: 탐색 범위 설정 (`start`, `end`)

문제에서 요구하는 답이 될 수 있는 **가장 작은 값**과 **가장 큰 값**을 `start`와 `end`로 설정

- **징검다리 문제 예시**:
    - 돌 사이의 최소 거리는 `1`. -> `start = 1;`
    - 최대 거리는 출발점에서 도착점까지의 거리(`distance`)입니다. -> `end = distance;`
### 2단계: 반복문 조건 설정 (`while (start <= end)`)
이 조건은 **`start`부터 `end`까지 모든 값을 후보로 탐색하겠다**는 의미입니다. `start`와 `end`가 같아지는 마지막 순간까지 검사해야 하므로 `<=`를 사용하는 것이 가장 안전하고 직관적입니다. 루프는 `start`가 `end`를 넘어서는 순간, 즉 탐색할 범위가 없어지면 종료됩니다.

### 3단계: 결정 함수 작성 (`isPossible(mid)`)
가장 중요한 단계입니다. `mid`값이 주어진 문제의 조건을 만족하는지 **"Yes" or "No"**로 판별하는 함수를 만듭니다.

- **징검다리 문제 예시**: `isPossible(mid)`
    - **질문**: "돌 사이의 최소 거리를 `mid`로 만들 수 있는가? (n개 이하의 돌만 제거해서)"
    - **답변**: 가능하다면 `true`, 불가능하다면 `false`를 반환합니다.

### **4-1단계: 범위 좁히기 (최댓값 찾기)**
**문제에서 "조건을 만족하는 값의 최댓값"을 요구할 때의 로직입니다. (e.g., 징검다리)
`isPossible(mid)`가 `true`라면, `mid`는 일단 답이 될 수 있습니다. 하지만 우리는 **더 큰 값**도 가능한지 확인해야 합니다.

```java
// 징검다리 문제 적용 예시 (최댓값 찾기)
if (isPossible(mid)) { // "mid라는 거리가 가능하다!"
    // 1. 현재 mid는 정답 후보이므로 저장한다.
    answer = mid;
    // 2. 더 큰 값도 가능한지 알아보기 위해 탐색 범위를 위로 올린다.
    start = mid + 1;
} else { // "mid라는 거리는 너무 커서 불가능하다!"
    // 1. 더 작은 값에서 정답을 찾아야 한다.
    end = mid - 1;
}
```

### **4-2단계: 범위 좁히기 (최솟값 찾기)**
문제에서 **"조건을 만족하는 값의 최솟값"**을 요구할 때의 로직입니다. (e.g., 블루레이 만들기, 공유기 설치)
`isPossible(mid)`가 `true`라면, `mid`는 답이 될 수 있습니다. 하지만 우리는 **더 작은 값**도 가능한지 확인해야 합니다.

```java
// 가상 문제 적용 예시 (최솟값 찾기)
if (isPossible(mid)) { // "mid라는 값으로 가능하다!"
    // 1. 현재 mid는 정답 후보이므로 저장한다.
    answer = mid;
    // 2. 더 작은 값도 가능한지 알아보기 위해 탐색 범위를 아래로 내린다.
    end = mid - 1;
} else { // "mid라는 값은 너무 작아서 불가능하다!"
    // 1. 더 큰 값으로 시도해야 한다.
    start = mid + 1;
}
```