---
플랫폼: 프로그래머스
알고리즘: 수학, 구현
tags:
  - 구현
date: 2026-02-12
복습 풀이: 260212(O), 260215(O), 260225(X)
---
# 1차 풀이
```java
class Solution {
    public int[] solution(int n, int m) {
        int a = 0;
        int b = Integer.MAX_VALUE;
        for (int i = 1; i <= n * m; i++) {
            if (n % i == 0 && m % i == 0) {
                a = Math.max(a, i);
            }
            
            if (i % n == 0 && i % m == 0) {
                b = Math.min(b, i);
            }
        }
        
        return new int[] {a, b};
    }
}
```
맞추긴했지만, 최대공약수/최소공배수를 구현하는 방법이 효율적이지 않다고 느껴짐

유클리드 호제법에 대해 확실히 인지하고 넘어갈것
```java
class Solution {
    public int[] solution(int n, int m) {
        // 1. 최대공약수 구하기
        int gcdValue = gcd(n, m);
        
        // 2. 최소공배수 구하기 (두 수의 곱 / 최대공약수)
        int lcmValue = (n * m) / gcdValue;
        
        // 3. 결과 반환 [최대공약수, 최소공배수]
        return new int[] {gcdValue, lcmValue};
    }
    
    // 유클리드 호제법을 이용한 최대공약수 함수 (재귀 방식)
    public int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        return gcd(b, a % b);
    }
}
```

**큰 수에서 작은 수를 덜어내도 약수는 변하지 않는다."**
1. $A$와 $B$를 공통으로 나누는 자(약수)가 있습니다.
2. $A$는 $B$와 $B$의 배수들, 그리고 나머지 $r$로 이루어져 있습니다 ($A = Bq + r$).
3. $A$도 그 자로 재어지고, $B$도 그 자로 재어진다면, 남은 조각인 **$r$도 당연히 그 자로 딱 맞게 재어져야 합니다.**
4. 그러니 $A, B$를 비교하는 문제를 $B, r$을 비교하는 더 작은 문제로 축소해도 결과(최대공약수)는 같습니다.

# 3차 풀이
```java
class Solution {
    public int[] solution(int n, int m) {
        int gcd = gcd(n, m);
        int lcm = (n * m) / gcd;
        
        return new int[] {gcd, lcm};
    }
    
    private int gcd(int a, int b) {
        if (b == 0) {
            return a;
        }
        
        return gcd(b, a % b);
    }
}
```
유클리드 호제법에 익숙해지기