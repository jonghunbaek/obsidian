---
플랫폼: 프로그래머스
문제 이름: 큰 수 만들기
알고리즘: 그리디
tags:
  - 그리디
date: 2025-10-09
aliases:
  - 그리디
복습 풀이: 251009(X)
---
# 1차 풀이
```java
// 1. 숫자의 정렬상태는 유지
// 2. 앞에서부터 반복하며, 0 ~ 9의 인덱스를 가진 배열의 값을 ++
// 3. replace()를 사용해 가장 낮은 숫자의 값부터 주어진 개수만큼 삭제

class Solution {
    public String solution(String number, int k) {
        int[] numbers = new int[10];
        for (char c : number.toCharArray()) {
            numbers[c - '0']++;
        }

        int idx = 0;
        while (k > 0) {
            int value = numbers[idx];
            if (value > 0 && value <= k) {
                number = number.replace(String.valueOf(idx), "");
                k -= value;
            } else if (value > 0 && value > k) {
                for (int i = 0; i < number.length(); i++) 
            }
            
            idx++;
            continue;
        }
        
        return "";
    }
}
```
최초 접근 방식이나 시간 복잡도가 제대로 고려되지 않고, 가장 큰 문제로 문제 해결의 접근 방식 자체가 잘못됐음

결과적으로 보니 스택으로 쉽게 풀 수 있었음. 
```java
import java.util.*;

class Solution {
    public String solution(String number, int k) {
        Stack<Character> stack = new Stack<>();
        for (char c : number.toCharArray()) {
            while (k > 0 && !stack.isEmpty() && c > stack.peek()) {
                stack.pop();
                k--;
            }
            
            stack.push(c);
        }
        
        while (k-- > 0) {
            stack.pop();
        }
        
        StringBuilder sb = new StringBuilder();
        while (!stack.isEmpty()) {
            sb.append(stack.pop());
        }
        
        return sb.reverse().toString();
    }
}
```
하지만 문제를 볼 때, 스택 자료구조가 전혀 생각나지 않았음
