# 1. 톰캣 - 정통 클래스 로더 아키텍처
주류 자바 웹 서버는 모두 자체 정의한 클래스 로더를 사용한다. 
그 이유는 다음과 같다.
- **같은 서버에 배포되는 애플리케이션 간에 자바 클래스 라이브러리를 격리할 필요가 있음**
- **같은 서버에 배포되는 애플리케이션 간에 자바 클래스 라이브러리를 공유할 필요가 있음**
- **웹 서버와 웹 애플리케이션 각각이 사용하는 자바 라이브러리는 서로 영향을 받지 않아야 함**
- **JSP 애플리케이션을 지원하는 웹 서버의 경우 핫스왑이 필요**
이러한 조건들 때문에 클래스 패스가 하나뿐인 구조는 다수의 웹 애플리케이션을 배포하기에 적합하지 않다. 
-> 즉, 자체 정의한 클래스 로더가 필요함

## 1.1 톰캣 클래스 로더 아키텍처
### ~ 톰캣 5
![[JVM 9장 - 톰캣5까지의 클래스 로더 아키텍처.png|300]]

공통 클래스 로더와 그 이하의 클래스 로더들이 톰캣에서 자체 정의한 클래스 로더다.
톰캣의 디렉터리에 저장된 클래스 라이브러리들은 저장된 경로에 따라 접근 범위가 다르다.
또한 전용 클래스 로더를 디렉터리마다 따로 제공하는데 자세한 내용은 다음과 같다.
- **/common - 공통 클래스 로더**
	- 톰캣 자신과 모든 웹 애플리케이션
- **/server - 카탈리나 클래스 로더**
	- 톰캣 자신
- **/shared - 공유 클래스 로더**
	- 톰캣을 제외한 모든 웹 애플리케이션
- **/webapp/WEB-INF - 웹 앱 클래스 로더**(웹 앱 하나당 전용 로더가 만들어짐)
	- 해당 웹 애플리케이션
JSP 클래스 로더의 로드 범위는 JSP 파일을 컴파일해 만들어진 클래스 파일들로 한정되며, JSP 파일이 수정되면 새로운 JSP 클래스 로더 인스턴스를 생성해 기존 인스턴스를 교체한다.

### 톰캣 6 ~
톰캣 6부턴 기본 디렉터리 구조가 더 단순해졌다.
공통 클래스 로더가 카탈리나 클래스 로더, 공유 클래스 로더의 역할까지 수행하게 됐다.
그러므로 common, server, shared 디렉터리를 lib 디렉터리 하나로 병합하는 게 좋다.
하지만 더 복잡한 구성이 필요하다면 다시 5까지의 아키텍처로 되돌릴 수 있다.

### 문제
Spring 애플리케이션이 10개 존재한다면, Spring을 모든 웹 애플리케이션이 공유하도록 common 이나 shared 디렉터리에 넣으면 된다.
프레임워크 특성상 Spring 역시 사용자 프로그램의 클래스들을 사용할 수 있어야 한다. 
그런데 사용자 프로그램은 /webapp/WEB-INF 디렉터리에 존재한다. 

이 상황에서 공통 또는 공유 클래스 로더가 로드한, Spring 범위에 없는 사용자 프로그램에 어떻게 접근할 수 있을까?

### 답변
부모 클래스 로더에서 로드한 클래스에선 자식 클래스 로더가 로드한 클래스에 접근하지 못한다.
그러므로 공통 또는 공유 클래스 로더에서 로드한 Spring 프레임워크 관려 클래스들이 웹 앱 클래스 로더에서 정의된 클래스들에 직접 접근할 수 없다.
그래서 Spring에선 이미 로딩된 Class 객체를 전달 받거나 아래와 같은 방식을 통해 우회적으로 접근한다.
```java
ClassLoader appClassLoader = Thread.currentThread().getContextClassLoader();
Class<?> userConfig = appClassLoader.loadClass("com.example.MyConfig");
```
이느 GPT 답변을 정리한 것으로 확실하진 않다. 
내 생각엔 현대의 클래스 로더 아키텍처에서 플랫폼 클래스 로더 - 애플리케이션 클래스 로더가 서로 위임하는 방식을 사용했을 거라 추측한다.
# 2. OSGI - 유연한 클래스 로더 아키텍처
OSGI의 가장 잘 알려진 응용 예시는 이클립스 IDE다.
OSGI의 번들은 보통의 자바 클래스 라이브러리와 크게 다르지 않다.
하지만 번들에서 의존하는 패키지 선언, 외부에 공개할 패키지 선언을 통해 번들간 클래스 라이브러리 가시성이 정밀하게 제어된다.

## 2.1 OSGI 클래스 로더 아키텍처
![[JVM 9장 - OSGI 클래스 로더 아키텍처.png|400]]

OSGI가 핫스왑 같은 매력적인 기능을 제공할 수 있는 근간에는 유연한 클래스 로더 아키텍처가 존재한다.
번들 클래스 로더 사이엔 고정된 위임 관계가 없고 다음과 같은 몇 가지 규칙만 존재한다.
- **번들들이 어떤 패키지를 공개하고 의존하냐에 따라 번들 사이에 위임과 의존 관계가 형성됨
- **번들 클래스 로더는 공개 목록을 통해 접근 범위를 엄격하게 제어**

OSGI는 부모 위임 모델을 따르지 않으며, 더 복잡하지만 런타임에 결정 가능한 메시 형태로 발전했다.
덕분에 유연한 아키텍처를 가지게 됐지만 여러 위험이 있으므로 모든 애플리케이션에 적합한 해결책은 아니다.

# 3. 바이트 코드 생성 기술과 동적 프록시 구현
javac외에도 바이트 코드를 생성하는 사례
- **웹 서버의 JSP 컴파일러**
- **AOP 프레임워크**
- **동적 프록시**
- **리플렉션**
실제 개발에서 바이트 코드를 바이트 단위로 직접 구성하는 경우는 거의 없다. 
특히 생성할 바이트 코드 양이 많은 경우라면 JDK의 바이트 코드 클래스 라이브러리를 활용하자.

# 4. 백포트 도구 - 자바의 타임머신
최신 버전의 JDK를 사용하지 못하고 이전 버전에 계속 머물러야 하는 특수한 상황이 존재할 수 있다.
이런 경우에 백포트 도구를 활용해 최신 버전 JDK의 일부 기능을 가져와 사용할 수 있다.

## 백포트의 수행 방식
백포트의 수행 방식을 알아 보기전에 먼저 JDK의 신기능들을 먼저 분류해보자.
- **자바 클래스 라이브러리 API 개선**
- **프론트엔드 컴파일러 수준의 개선**
- **바이트 코드 차원에서 지원이 필요한 변경**
- **JDK 구조 전반으 개선**
- **가상 머신 내부 개선**

이 중  첫 두 유형의 개선은 백포트 도구가 완벽히 시뮬레이션할 수 있다.
하지만 세 번째 유형부턴 완벽하게 백포트할 수 없거나 가능하더라도 효율이 매우 떨어진다.