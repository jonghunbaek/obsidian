자바 개발자는 JVM에서 제공하는 자동 메모리 관리 메커니즘 덕에 메모리 할당과 해제라는 작업에서 자유로울 수 있다. 하지만 문제가 발생하게 되면 JVM의 메모리 관리 방식을 이해하지 못하는 한 문제 해결이 상당히 어려워진다. 
그렇기 때문에 JVM이 관리하는 다양한 메모리 영역과 각 영역의 역할 등에 대해 알아둬야 한다.
## 2.1 런타임 데이터 영역
![[JVM 구조.png]]
#### 2.2.1 프로그램 카운터
프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행 중인 스레드의 '바이트 코드 줄 번호 표시기'라고 볼 수 있다. 다시 말해 프로그램의 제어 흐름, 분기, 순환, 점프 등을 표현한 것이다. 
JVM의 멀티 스레딩은 CPU 코어를 여러 스레드가 교대로 사용하며, 특정 시각에 각 코어는 한 스레드의 명령어만 실행하게 된다. 그러므로 스레드 전환 후 이전에 실행하다 멈춘 지점을 정확하게 복원하려면 스레드 각각에는 고유한 프로그램 카운터가 필요하다. 이러한 이유 때문에 **프로그램 카운터(PC)레지스터는 각 스레드의 고유한 공간에 저장된다.**
>[!NOTE] 참고
> 스레드가 자바 메서드를 실행할 땐, 바이트 코드 명령어의 주소가 저장되지만 네이티브 메서드를 실행할 땐 Undefined가 프로그램 카운터에 저장된다.
#### 2.2.2 자바 가상 머신 스택
가상 머신 스택도 스레드 프라이빗하며, 연결된 스레드와 생명주기가 같다. 자바에서 각 **메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장**한다. 이후 스택 프레임을 가상 머신 스택에 push, pop을 반복한다.

지역 변수 테이블에는 자바 가상 머신이 컴파일 타임에 알 수 있는 다양한 기본 데이터 타입, 객체 참조, 반환 주소 타입을 저장한다. 그리고 지역 변수 테이블에서 이러한 데이터 타입들을 저장하는 공간을 지역 변수 슬롯이라고 한다.

지역 변수 테이블을 구성하는 데 필요한 데이터 공간은 컴파일 과정에서 할당된다. 다시 말해 런타임에 해당 공간의 크기(슬롯 개수)는 변하지 않는다.
>[!NOTE] 반환 주소 타입이란?
>  return 문이 실행될 때, 어느 위치로 돌아가야 하는지를 가리킴
>  일반적인 자바 코드에선 다룰 일이 없고, 보통 바이트 코드 수준에서 존재함

#### 2.2.3 네이티브 메서드 스택
가상 머신 스택과 비슷한 역할을 하지만 대상이 네이티브 메서드라는 점에서 다르다. 자바 가상 머신 며엣에 네이티브 메서드 스택에 대해 명시된 것이 없어 네이티브 메서드 스택과 가상 머신 스택을 하나로 합쳐 놓은 가상 머신도 존재한다. 대표적으로 핫스팟 가상 머신이 그러하다.
#### 2.2.4 자바 힙
힙은 모든 스레드가 공유하는 메모리 영역이며 자바 애플리케이션이 사용할 수 있는 가장 큰 공간이다. 해당 영역의 유일한 목적은 **객체 인스턴스를 저장**하는 것이다.
메모리 할당 관점에서 자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러 개로 나뉜다. 이와 같이 작게 구분하는 이유는 오직 메모리 회수와 할당을 더 빠르게 하기 위함이다.
힙은 물리적으로 떨어진 메모리에 위치해도 상관 없으나 논리적으로는 연속되어야 한다. 
> 구현 관점에서 자바 언어가 계속 발전하면서 앞으로는 값 타입도 지원할 것으로 보인다.
> 따라서 모든 자바 객체 인스턴스가 힙에 할당된다는 설명이 절대적 진리라고 보기에는 조금씩 애매해지고 있다.
> -> 메서드 내부에서만 사용되는 객체라면 굳이 힙에 할당할 필요 없이 스택에 할당하여 최적화 할 수 있다는 의미?

>[!NOTE] 신세대? 구세대? 에덴 공간?
> 자바 힙을 설명할 때 신세대, 구세대, 영구 세대, 에덴 공간, 생존자 공간에서부터 등의 용어는 GC의 일반적 특성 또는 설계 방식일 뿐이다.

#### 2.2.5 메서드 영역
메서드 영역도 모든 스레드가 공유하는 영역이다. 해당 영역의 목적은 가상 머신이 읽어 들인 타입 정보, 상수, 정적 변수 그리고 JIT 컴파일러가 컴파일한 코드 캐시 등을 저장하는데 이용된다. 
과거 핫스팟 가상 머신 개발 팀에서 GC의 수집 범위를 메서드 영역까지 확장하기로 결정했다. 그래서 메서드 영역을 영구 세대에 구현했다. 이 때문에 많은 사람들이 메서드 영역 == 영구 세대라고 개념을 혼동했다. 자바 가상 머신 명세에선 원칙적으로 메서드 영역을 어떻게 구현할지는 강제하지 않았기에 발생한 현상이었다. 메서드 영역을 영구 세대에 구현한 결정은 오히려 좋은 생각이 아니었다. 메모리 오버 플로를 겪을 가능성이 높아지기 때문이다. JDK 8이 되면서 영구 세대라는 개념을 완전히 지우고 네이티브 메모리에 메타스페이스를 구현했다. 
메서드 영역에서 회수할 대상은 거의 대부분 상수 풀과 타입이라서 회수 효과가 상대적으로 매우 작다. 
>[!NOTE]
>자바 가상 머신 명세에서는 메서드 영역도 논리적으로는 힙의 한 부분으로 기술하지만, 자바 힙과 구분하기 위해 논힙이라고 부르기도 한다.
#### 2.2.6 런타임 상수 풀
런타임 상수 풀은 메서드 영역의 일부다. 상수 풀 테이블에는 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 메타 데이터에 더해 컴파일 타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다.
클래스 파일의 상수 풀과 비교해 런타임 상수 풀의 주요한 특징은 바로 동적이라는 점이다. 
자바 언어에서는 상수가 꼭 컴파일 타임에 생성되어야 한다는 규칙이 없다. **즉, 상수 풀의 내용 전부가 클래스 파일에 미리 완벽하게 기술되어 있는 것이 아니다.**
#### 2.2.7 다이렉트 메모리
다이렉트 메모리는 가상 머신 런타임에 속하지 않으며 자바 가상 머신 명세에 정의된 영역도 아니다. 해당 영역은 물리 메모리를 직접 할당하기에 자바 힙 크기의 제약과는 무관하지만 이 또한 메모리라는 점을 간과해선 안된다. 
## 2.3 핫스팟 가상 머신에서의 객체 들여다 보기
#### 2.3.1 객체 생성
JVM이 new 명령에 해당하는 바이트 코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 심벌 참조인지 확인한다. 그 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화 되었는지 확인한다. 만약 로드되지 않았다면 .class 파일을 읽어와 메서드 영역에 클래스 정보를 로딩한다.  
로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라고 볼 수 있다. 자바 힙이 완벽하게 규칙적이라면 메모리 할당 이후 포인터를 여유 공간쪽으로 '포인터 밀치기'를 객체 크기만큼 하면 된다. 
하지만 자바 힙은 규칙적이지 않기 때문에 포인터 밀치기가 쉽지 않다. 그렇기에 **가용 메모리 블록들을 목록으로 따로 관리**하며, 객체 인스턴스를 담기에 충분한 공간을 찾아 할당 후 목록을 갱신한다. 이를 여유 목록(free list)라고 한다. 자바 힙의 규칙적이냐 아니냐는 GC가 컴팩트를 할 수 있느냐에 달렸다. 
>[!NOTE] 포인터 밀치기란?
>![[포인터 밀치기.png]]
>객체 크기만큼의 메모리 할당 이후 여유 공간으로 포인터를 이동하는 작업

멀티 스레딩 환경에서 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 세이프하지 않기 때문에 여러 스레드가 동시에 객체를 생성한다면 문제가 발생할 수 있다. 
이에 대한 해결책은 두 가지다.
- 메모리 할당을 동기화
	- 비교 및 교환 실패 시 갱신을 원자적으로 수행
- 스레드마다 다른 메모리 공간을 할당하는 방법
	- 스레드 각각이 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당 받음(Thread Local Allocation Buffer - TLAB)
	- ![[TLAB.png]]

메모리 할당이 끝났으면 가상 머신은 할당 받은 공간을 0으로 초기화한다(헤더 제외). TLAB을 사용한다면 초기화는 TLAB 할당 시 미리 수행한다. 이로 인해 자바에선 객체 인스턴스 필드를 초기화 하지 않고도 사용할 수 있다.
이후 JVM은 각 객체의 메타 데이터(클래스 타입, 클래스 메타 정보 찾는 방법, GC 나이 등)를 객체 헤더에 저장한다. 
여기까지가 가상 머신 관점에서 새 객체가 생성되는 과정이다. 이후 자바 프로그램 관점에서 init() 메서드가 실행되어 객체를 개발자 의도대로 초기화되는 과정이 진행된다. 
>[!NOTE] 참고
>자바 컴파일러는 자바의 new 키워드를 발견하면 바이트 코드 명령어인 new와 invokespecial로 변환한다. 바이트 코드의 new는 vm관점에서, invokespecial은 자바 프로그램 관점에서 init()을 호출한다. 만약 new 키워드를 사용하지 않고 객체를 생성했다면 invokespecial은 나오지 않을 수도 있다. 

#### 2.3.2 객체의 메모리 레이아웃
