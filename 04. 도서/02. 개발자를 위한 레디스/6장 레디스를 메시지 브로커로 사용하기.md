# 1. 메시지 브로커
메시지 브로커의 형태는 다음과 같이 나눌 수 있다.
- **메시징 큐**(1:1)
- **이벤트 스트림**(n:n)

메시징 큐와 이벤트 스트림은 비슷하지만 몇 가지 차이점이 존재한다.
- **데이터 생성자/수신자**
	- 메시징 큐에서 데이터를 생성하는 쪽을 'Producer', 데이터를 수신하는 쪽을 'Consumer'라고 한다. 
	- 이벤트 스트림에선 데이터를 생성하는 쪽을 'Publisher', 데이터를 수신하는 쪽을 'Subscriber'라고 한다.
- **방향성**
	- 메시징 큐에선 소비자의 큐로 데이터를 직접 푸시(소비자의 큐가 여러개라면 여러번 푸시)
	- 이벤트 스트림에선 스트림 저장소에 메시지를 푸시, 소비자는 해당 저장소에서 메시지를 풀
- **영속성**
	- 메시징 큐에선 소비자가 데이터를 읽어갈 때 큐에서 데이터를 삭제
	- 이벤트 스트림에선 소비자가 읽어도 저장소 설정에 따라 삭제 여부/기간이 달라짐

# 2. 레디스의 메시지 브로커
레디스가 제공하는 pub/sub을 사용해 메시지 브로커를 구현할 수 있다.
### 레디스 pub/sub
![[Redis - pub,sub.png|500]] 출처 - https://oliveyoung.tech/2023-08-07/async-process-of-coupon-issuance-using-redis/
레디스의 pub/sub은 일회성이다. 
즉, 메시지가 잘 전달됐는지 등의 정보는 보장하지 않는다. 
그러므로 **데이터 정합성이 중요한 프로젝트에선 적합하지 않다**.

레디스 노드에 접근할 수 있는 모든 클라이언트는 publisher/subscriber가 될 수 있다.
또한 매우 가볍기 때문에 **최소한의 메시지 전달 기능만 제공**한다.
그러므로 **어떤 구독자가 메시지를 읽어가는지, 정상적으로 수신 되었는 지 확인할 수 없다.**
또한 메시지 발행 정보와 같은 **메타 데이터도 확인할 수 없다**.

한 번 전파된 데이터는 레디스에 저장되지 않으며, 단순히 메시지의 통로 역할만 한다. 

### 클러스터 구조에서의 pub/sub
메시지를 발행하면 해당 메시지는 클러스터 내의 모든 노드에게 자동으로 전달된다.
단순하지만 이 방법은 클러스터의 존재 목적에 어긋나는 사용 방식이다.(불필요한 리소스 사용 및 네트워크 부하)
→ 클러스터는 대규모 서비스에서 데이터를 분산 저장, 처리하여 고가용성을 보장하기 위함

### shareded pub/sub
기존의 pub/sub 방식의 단점을 해결하기 위해 7.0버전에 나온 기능
**sharded pub/sub 환경에서 각 채널은 슬롯에 매핑**된다.
그러므로 **같은 슬롯을 가지고 있는 노드 간에만 pub/sub 메시지를 전파**한다.

### Redis Cluster vs Sentinel
- **Cluster**
    - 고가용성과 샤딩(스케일 아웃)이 주요 목적
    - 슬롯을 기준으로 데이터가 자동 분산
    - 마스터 장애 시 자동 페일오버
        - Sentinel의 슬레이브 → 마스터 승격과 유사하나 차이가 존재(10장에서 딥다이브)
    - 슬롯을 기준으로 **여러 개의 마스터 노드가 동시 운용**됨
    - 운영 복잡도 및 클라이언트 설정 복잡도가 높음
- **Sentinel**
    - 고가용성이 주요 목적
    - 단일 인스턴스에 전체 데이터 저장
    - 마스터 장애 시 슬레이브를 마스터로 승격
    - **하나의 마스터만 존재**
    - 슬레이브는 마스터의 데이터를 복제만 함. 저장 자체는 마스터에서 수행
    - 상대적으로 낮은 설정, 운영 복잡도

# 3. 레디스의 메시징 큐

레디스의 자료 구조 중 List는 큐로 사용하기에 적절하다.
### List의 블로킹 기능
이벤트 기반 구조에서 시스템은 이벤트 루프를 돌며 신규로 처리할 이벤트가 존재하는 지 확인한다.
이벤트 루프는 이벤트 큐에 새 이벤트가 있는지 확인하여, 없을 경우 **일정 시간 대기**(폴링 인터벌)**한 뒤 큐를 재확인하는 과정을 반복**한다.
폴링 프로세스 동안 **애플리케이션과 큐의 리소스가 낭비**될 수 있고, 폴링 인터벌이 존재하여 **즉시 이벤트를 처리하지 못하는 단점**이 존재한다.

List의 블로킹 기능(BLPOP, BRPOP)을 활용해 문제를 해결할 수 있다.
BLPOP을 사용하면 데이터가 **존재하는 경우엔 즉시 반환, 없는 경우 설정한 시간만큼 대기**한다.
대기하는 동안 **데이터가 들어온다면 즉시 반환**하고, 이후에도 **들어오지 않으면 nil값을 반환**한다.
또한 하나의 리스트가 아닌 여러 개의 리스트에서 동시에 대기할 수 있다.
```
BRPOP queue1 queue2 queue3 0 
1) 값이 꺼내진 큐(리스트)의 이름
2) 실제 값 데이터
```

### List를 활용한 원형 큐
특정 아이템을 반복해서 접근해야 경우, 여러 개의 클라이언트가 병렬적으로 같은 아이템에 접근해야 하는 경우에 원형 큐를 사용할 수 있다.
RPOPLPUSH 기능을 사용한다.
→ BRPOPLPUSH로 블로킹 기능을 사용할 수도 있음

# 4. Stream
레디스의 Stream은 5.0버전에 새로 추가된 자료 구조로, append-only 성격의 자료 구조다.
→ 데이터를 계속해서 추가하며, 대용량/대규모 메시징 데이터를 빠르게 처리할 수 있음

크게 두 가지 방식으로 활용 가능하다.
- **대량의 데이터를 효율적으로 처리할 때
- 다수의 프로듀서가 생성한 데이터를 다수의 컨슈머가 처리할 수 있도록 지원하는 **데이터 저장소 및 중간 큐잉 시스템으로 활용**할 때
### 스트림의 정의
스트림이란 일반적으로 **끝이 정해지지 않고 연속적으로 흐르는 데이터**라고 볼 수 있다.
추상적인 개념이기에 다양한 상황에서 스트림이 활용될 수 있다.
- **Java 클래스 파일을 읽어 들이는 경우**(바이너리 바이트 스트림)
- **채팅 앱에서 실시간으로 처리되는 채팅 데이터**(JSON 스트림)
- **파일 입출력**(I/O Stream)
- **애플리케이션 내부에서 서버 간 데이터의 이동**

### 스트림 생성과 데이터 저장
레디스에서 **하나의 stream 자료 구조는 하나의 stream을 의**미한다. 
다른 자료 구조와 마찬가지로 **하나의 키에 연결**된다. 

stream에 저장되는 데이터(메시지)는 시간과 관련된 중복 없는 ID를 가진다. ID의 구조는 다음과 같다.
```text
<millisecondsTime>-<sequenceNumber>
```
동시에 데이터가 저장되는 경우 sequenceNumber가 증가 하는데, 값의 범위는 64bit다.

stream 생성에 별도의 과정은 필요 없다.
**키가 존재하면 새로운 데이터를 추가하고 그렇지 않으면 새로운 stream에 데이터를 저장**한다.
```
> XADD Email * subject "first" body "hello?"
"1659114481311-0"
```

### 스트림의 데이터 조회
레디스에선 stream의 데이터를 두 가지 방식으로 조회할 수 있다.
#### 실시간 데이터 리스닝
```
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```
#### ID를 활용해 필요한 데이터 조회
```
XRANGE key start end [COUNT count]
XREVRANGE key end start [COUNT count]
```

### 소비자와 소비자 그룹
레디스 스트림에서 데이터를 가져올 때, 소비자 또는 소비자 그룹은 메시지가 전달되는 순서를 신경 쓰지 않아도 된다.
→ 애초에 시간순으로 정렬되어 있기 때문
또한 **소비자 그룹 내의 한 소비자는 다른 소비자가 아직 읽지 않은 데이터만 읽어**간다.

아래와 같이 소비자 그룹을 통해 데이터를 읽어올 수 있다.
```
XGROUP CREATE Email EmailServiceGroup $ // 스트림에 소비자 그룹 생성
XREADGROUP GROUP EmailServiceGroup emailService1 COUNT 1 STREAMS Email > // 소비자 그룹을 통해 스트림에서 데이터 조회
```
XREADGROUP을 통해 여러 스트림 데이터를 동시에 읽어 오려면 각 스트림에 소비자 그룹을 먼저 생성해야 한다.

**레디스 스트림에서 소비자 그룹은 스트림의 상태를 나타내는 개념**으로 볼 수 있다.
→ 소비자 그룹 관점에서 바라봤을 때이므로 하나의 스트림이 여러 개의 소비자 그룹을 통해 데이터를 관리할 수 있음
→ XREADGROUP은 조회 명령어지만 사실상 쓰기 커맨드와 같이 동작하므로 마스터에서만 호출 가능

### ACK와 보류 리스트
메시지 브로커를 이용해 데이터를 처리할 때, **장애가 발생해 시스템이 종료되면 마지막 처리 지점으로부터 재처리**를 해야 한다.
레디스에선 이를 위해 다음과 같은 방법을 사용한다.
- **last_delivered_id 값을 갱신**
	- 마지막으로 읽어간 데이터의 ID의 값으로 갱신해 중복 전달 방지
- **보류 리스트(pending list)**
	- 스트림에서 소비자별로 보류 리스트를 만들어 어떤 소비자가 어떤 데이터를 소비했는지 기록
	- 소비자가 데이터 처리를 완료하며 **ACK 응답을 스트림에게 보내면 스트림은 보류 리스트에서 해당 메시지를 삭제**
>[!NOTE]
>**레디스의 최대 한번 vs 최소 한번 vs 정확히 한번**
>**1. 최대 한번(at most once)**
>	- 메시지를 최대 한번 보냄
>	- 소비자에선 메시지를 받자마자 ACK를 보냄(처리가 아닌 수신임에 주의)
>	- 메시지가 일부 유실되더라도 빠른 응답이 필요한 경우에 적합
>**2. 최소 한번(at least once)**
>	- 메시지를 최소 한번 보냄
>	- 소비자는 메시지를 처리한 뒤에 ACK를 보냄
>	- 중복 처리될 가능성이 존재해 멱등성이 보장되는 서비스인 경우에 적합
>**3. 정확히 한번(exactly once)**
>	- 모든 메시지가 무조건 한 번씩 전송되는 것을 보장
>	- set 등의 추가 자료 구조를 활용하여 이미 처리된 메시지인지 확인하는 것과 같은 추가적인 작업이 필요함

>[!NOTE]
>**메시지 정확히 한번 전달은 가능한가?**
>결론부터 말하자면 '정확히 한번' 메시지 전달은 불가능하다.
>정확히 한번 전달이라는 것은 결국 '정확히 한번' 전달을 흉내 내는 것에 불과하다.
>실제 시스템에선 at least once 전략에 멱등성, 중복 제거와 같은 비즈니스 비용을 통해 보완한다.
>**즉, 정확히 한번 '처리'가 가능한 것이지 정확히 한번 '전달'이 가능한 것은 아니다.**
>https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/

### 메시지 재할당
소비자에게 장애가 발생하고, 복구 되지 않는다면 해당 소비자가 가지고 있는 보류 메시지들을 다른 소비자가 처리해야 한다.
레디스에선 이를 위해 두 가지 방법을 지원한다.
- **자동 재할당**
- **수동 재할당**
