---
플랫폼: 프로그래머스
문제 이름: 쿼드압축 후 개수 세기
알고리즘: 재귀, DFS
tags:
  - 재귀
  - DFS
date: 2025-07-24
aliases:
  - 재귀
복습 풀이: 250724(X), 250727(O), 250802(O), 250809(O), 250816(O), 251017(O)
---
# 1차 풀이
```java
class Solution {
    public int[] solution(int[][] arr) {
        Count count = dfs(0, 0, arr.length, arr);

        return new int[] {count.zeroCount, count.oneCount};
    }

    public Count dfs(int offsetX, int offsetY, int size, int[][] arr) {
        for (int y = offsetY; y < offsetY + size; y++) {
            for (int  x = offsetX; x < offsetX + size; x++) {
                if (arr[offsetY][offsetX] != arr[y][x]) {
                    return dfs(offsetX, offsetY, size / 2, arr)
                            .add(dfs(offsetX + (size / 2), offsetY, size / 2, arr))
                            .add(dfs(offsetX, offsetY + (size / 2), size / 2, arr))
                            .add(dfs(offsetX + (size / 2), offsetY + (size / 2), size / 2, arr));
                }
            }
        }

        return arr[offsetY][offsetX] == 0 ? new Count(1, 0) :  new Count(0, 1);
    }

    static class Count {
        private int zeroCount;
        private int oneCount;

        public Count(int zeroCount, int oneCount) {
            this.zeroCount = zeroCount;
            this.oneCount = oneCount;
        }

        public Count add(Count other) {
            return new Count(this.zeroCount + other.zeroCount, this.oneCount + other.oneCount);
        }
    }
}
```

여전히 어려운 재귀와 DFS.. 계속 반복적으로 풀어야할 듯.
점화식을 세우는 것이 항상 어려움
큰 부분에서 작은 부분으로 수행하며 공통된 식을 세우는 것이 핵심

# 2차 풀이
```java
// 상태 - 시작x, 시작y, 크기
// 종료 조건 - 요소를 더 이상 나눌 수 없을 때
// 점화식 - (x, y, size) + (x + size / 2, y, size) + (x, y + size / 2, size), (x + size / 2, y + size / 2, size)
class Solution {
    public int[] solution(int[][] arr) {
        Count count = dfs(0, 0, arr.length, arr);
        return new int[] {count.zero, count.one};
    }
    
    private Count dfs(int offsetX, int offsetY, int size, int[][] arr) {
        for (int y = offsetY; y < offsetY + size; y++) {
            for (int x = offsetX; x < offsetX + size; x++) {
                if (arr[offsetY][offsetX] != arr[y][x]) {
                    return dfs(offsetX, offsetY, size / 2, arr)
                        .add(dfs(offsetX + size / 2, offsetY, size / 2, arr))
                        .add(dfs(offsetX, offsetY + size / 2, size / 2, arr))
                        .add(dfs(offsetX + size / 2, offsetY + size / 2, size / 2, arr));
                }
            }
        }
        
        return arr[offsetY][offsetX] == 0 ? new Count(1, 0) : new Count(0, 1);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(this.zero + other.zero, this.one + other.one);
        }
    }
}
```
문제가 어렵지 않아 쉽게 풀 수 있었음
다만 식을 세우는 부분은 여전히 어색하고 이 식을 통해 코드로 변환하는 작업은 여전히 어색하고 낯설음
**식을 세우고, 코드로 변환하는 과정을 체계적으로 연습해야 함**

# 3차 풀이
```java
// 가장 큰 부분 문제는 전체 정사각형의 0과 1의 개수를 구하는 것
// 가장 작은 부분 문제는 배열의 길이가 1인 경우
// 상태 (x, y, size) 탐색 시작 x,y 위치, 얼만큼 탐색할지 size
// 종료 조건 배열의 길이가 1이라 더 이상 나눌 수 없을때. 0, 1의 개수를 반환
// 점화식 정사각형을 4등분하여 각 사분면의 0, 1 개수를 더하면됨

class Solution {
    public int[] solution(int[][] arr) {
        Count count = count(arr, 0, 0, arr.length);
        return new int[] {count.zero, count.one};
    }
    
    private Count count(int[][] arr, int startX, int startY, int size) {
        for (int y = startY; y < startY + size; y++) {
            for (int x = startX; x < startX + size; x++) {
                if (arr[startY][startX] == arr[y][x]) {
                    continue;
                }
                
                return count(arr, startX, startY, size / 2)
                    .add(count(arr, startX + size / 2, startY, size / 2))
                    .add(count(arr, startX, startY + size / 2, size / 2))
                    .add(count(arr, startX + size / 2, startY + size / 2, size / 2));
            }
        }
        
        return arr[startY][startX] == 1 ? new Count(0, 1) : new Count(1, 0);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(zero + other.zero, one + other.one);
        }
    }
}
```

완전히 이해했다고 생각했지만 다시 풀어보니 아직 이해가 덜 된 부분들이 나옴
주기적으로 풀어보기

# 4차 풀이
```java
// 1. 가장 큰 문제는 전체 배열에서 0과 1의 개수를 세는 것
// 2. 이를 쪼개 가장 작은 문제로 나누면 배열의 각 원소를 세는 것
// 상태 변수 - 시작 좌표(x, y), 범위(size)
// 종료 조건 - 시작 좌표에서 최대 범위가 1이여서 더 이상 나눠질 수 없을 때
// 점화 방식 - (x, y, size / 2) + (x + size /2, y, size / 2) ...4사분면까지
class Solution {
    public int[] solution(int[][] arr) {
        Count count = count(0, 0, arr.length, arr);
        return new int[] {count.zero , count.one};
    }
    
    private Count count(int startX, int startY, int size, int[][] arr) {
        for (int y = startY; y < startY + size; y++) {
            for (int x = startX; x < startX + size; x++) {
                if (arr[startY][startX] != arr[y][x]) {
                    return count(startX, startY, size / 2, arr)
                        .add(count(startX + size / 2, startY, size / 2, arr))
                        .add(count(startX, startY + size / 2, size / 2, arr))
                        .add(count(startX + size / 2, startY + size / 2, size / 2, arr));
                }
            }
        }
        
        return arr[startY][startX] == 0 ? new Count(1, 0) : new Count(0, 1);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(this.zero + other.zero, this.one + other.one);
        }
    }
}
```
답안을 거의 외운 상태라 풀이 자체는 어렵지 않음
다만 상태, 종료 조건, 점화식을 체계적으로 접근하는 과정이 여전히 어색함
다시 확인하니 종료 조건에 대한 이해도가 부족했음 마지막 한번 더 풀어볼 필요가 있음

# 5차 풀이
가끔 재귀 연습할 때 풀어보기

# 6차 풀이
```java
class Solution {
    public int[] solution(int[][] arr) {
        Count count = count(0, 0, arr.length, arr);
        return new int[] {count.zero, count.one};
    }
    
    private Count count(int x, int y, int size, int[][] arr) {
        for (int i = y; i < y + size; i++) {
            for (int j = x; j < x + size; j++) {
                if (arr[y][x] != arr[i][j]) {
                    return count(x, y, size / 2, arr)
                        .add(count(x + size / 2, y, size / 2, arr))
                        .add(count(x + size / 2, y + size / 2, size / 2, arr))
                        .add(count(x, y + size / 2, size / 2, arr));
                }
            }
        }
        
        return arr[y][x] == 0 ? new Count(0, 1) : new Count(1, 0);
    }
    
    static class Count {
        int one;
        int zero;
        
        public Count(int one, int zero) {
            this.one = one;
            this.zero = zero;
        }
        
        public Count add(Count other) {
            return new Count(this.one + other.one, this.zero + other.zero);
        }
    }
}
```
사실사 예전 풀이를 기억해내서 푼 수준.
재귀에 대한 정확한 이해도가 아직 부족하다고 느껴진다.
재귀가 이렇게 된 방식을 천천히 곱씹으며 풀어볼 것

아래는 클로드가 풀이해준 답안. 내 풀이와 차이점을 비교하며 고민해보기
```java
class Solution {
    public int[] solution(int[][] arr) {
        return compress(arr, 0, 0, arr.length);
    }
    
    // 영역을 압축하고 [0의 개수, 1의 개수]를 반환
    private int[] compress(int[][] arr, int x, int y, int size) {
        // 현재 영역이 모두 같은 값인지 확인
        if (isSame(arr, x, y, size)) {
            // 모두 0이면 [1, 0], 모두 1이면 [0, 1] 반환
            return arr[x][y] == 0 ? new int[]{1, 0} : new int[]{0, 1};
        }
        
        // 4개 영역으로 분할하여 재귀 호출
        int half = size / 2;
        int[] topLeft = compress(arr, x, y, half);                // 왼쪽 위
        int[] topRight = compress(arr, x, y + half, half);        // 오른쪽 위
        int[] bottomLeft = compress(arr, x + half, y, half);      // 왼쪽 아래
        int[] bottomRight = compress(arr, x + half, y + half, half); // 오른쪽 아래
        
        // 4개 영역의 결과를 합산
        return new int[]{
            topLeft[0] + topRight[0] + bottomLeft[0] + bottomRight[0],  // 0의 개수
            topLeft[1] + topRight[1] + bottomLeft[1] + bottomRight[1]   // 1의 개수
        };
    }
    
    // 주어진 영역의 모든 값이 같은지 확인
    private boolean isSame(int[][] arr, int x, int y, int size) {
        int value = arr[x][y];
        
        for (int i = x; i < x + size; i++) {
            for (int j = y; j < y + size; j++) {
                if (arr[i][j] != value) {
                    return false;
                }
            }
        }
        
        return true;
    }
}
```