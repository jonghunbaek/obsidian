# 1. 문제점
데이터를 관리하는 시스템에선 내결함성을 위해 데이터를 여러 서버로 복제한다.
그런데 여러 서버에 데이터를 복제할 경우, **클라이언트가 일관되지 못한 데이터를 응답받을 수**도 있다.
따라서 여러 서버로 데이터가 복제될 때는 **클라이언트가 데이터를 언제 볼 수 있게 할지 결정**해야 한다.

이 문제를 해결하는 데에 과반수 정족수 읽기/쓰기는 충분한 해결책이 아니다. 
개별 서버는 정족수 내 다른 서버의 데이터 상태를 알지 못하기 때문이다.

# 2. 해결책
이를 해결하기 위한 해결책으로 리더-팔로워 모델을 선택할 수 있다.
리더는 전체 **클러스터를 대표해 결정을 내리고, 그 결정을 다른 모든 서버에게 전달할 책임**이 있다.

리더-팔로워 모델에서 리더는 주로 쓰기 요청을 처리하며, 이를 통해 **쓰기 일관성을 보장**할 수 있다.
팔로워는 주로 읽기 요청을 처리하는데, 어떻게 읽기 일관성을 보장할 수 있을까?


그럼 이런 리더를 어떻게 선출할 수 있을까?
### 일반적인 리더 선출(작은 클러스터)
노드가 셋에서 다섯으로 구성된 작은 클러스터에선 별도의 외부 시스템에 의존하지 않고 **자체적으로 리더를 선출**할 수 있다.
리더 선출은 서버를 구동할 때 발생하며, 새로운 리더를 선출할 때마다 세대 번호를 갱신한다.
-> 장애 후 재구동한 경우도 마찬가지

이 방식에서 서버는 다음 세 가지 상태 중 하나로만 존재할 수 있다.
- 리더
- 팔로워
- 리더 탐색

새로운 리더 선출은 동료 서버에게 투표 요청을 보내며 시작한다.
이 때, 리더를 선출하는 가장 중요한 조건은 다음과 같다.
- 가장 최신 상태의 서버만이 합법적으로 리더가될 수 있음
- 모든 서버가 동일한 최신 상태라면 구현체에 따라 다를 수 있음
	- 잽은 특정 기준으로 우선 순위를 나눔
	- 래프트는 한 번에 한 서버만 투표를 하므로, 가장 먼저 선거를 시작한 서버를 리더로 선택
>[!최신 상태]
>여기서 말하는 최신 상태란, **최신의 세대 시계**와 쓰기 전 로그의 **최신 로그 인덱스**를 의미한다.

>[!분리 투표]
>분리 투표는 일종의 Split Brain 문제로 볼 수 있다.
>간단히 말하자면, 여러 노드가 동시에 자신이 리더가 되겠다고 선언하며 서로 다른 서버에게 투표하는 상황을 일컫는다. 
>이는 결국 어느 서버든 과반수의 표를 받지 못하게 되는 문제를 야기한다. 
>이를 해결하기 위한 방법은 다음과 같다.
> - 무작위 지연(래프트 - 선거 시작 전, 랜덤한 타임아웃 설정)
> - 합의 알고리즘(잽 - 모든 서버가 같은 로직으로 리더를 선택)

### 일관성 코어를 이용한 리더 선출
클러스터의 규모가 수천대의 노드로 구성된 경우라면 앞선 방식을 사용하기 어렵다. 
대신 주키퍼나 etcd와 같은 일관성 코어를 사용하는 편이 수월하다. 

일관성 코어는 내부적으로 합의를 사용하며 선형성을 보장한다.
여기서 선형성은 모든 연산이 마치 한 대의 노드에서 수행되는 것처럼 보이도록 보장하는 것을 말한다.

대규모 클러스터에선 일반적으로 마스터 또는 컨트롤러 노드로 지정한 서버를 두는데, 이 서버는 전체 클러스터를 대신해 모든 결정을 내린다. 
이를 구현하기 위해 세 가지가 필요하다.
- 키를 원자적으로 설정하기 위한 CAS(Compare And Swap)명령어