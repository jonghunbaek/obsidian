---
플랫폼: 프로그래머스
알고리즘:
tags:
date: 2026-02-19
복습 풀이: 260219(X)
---
# 1차 풀이
```java
// 배열, 문자열, 완전탐색 문제
// 1. 시간 복잡도 = n2 * m(50 * 50 * 100)
// 2. requests의 원소 길이가 2라면 해당하는 문자열을 replaceAll()을 활용하여 해당 문자를 1로 변경
// 3. 1이라면 bfs 탐색하여 벽끝이 나올때까지 탐색하여 존재하면 1로 대체 아니라면 유지(방문 배열 사용) 시간초과?
import java.util.*;

class Solution {
    public int solution(String[] storage, String[] requests) {
        for (String request : requests) {
            if (request.length() == 2) {
                for (int i = 0; i < storage.length; i++) {
                    storage[i] = storage[i].replaceAll(request.split("")[0], "1");
                }
                continue;
            }

            List<int[]> points = new ArrayList<>();
            for (int i = 0; i < storage.length; i++) {
                for (int j = 0; j < storage[i].length(); j++) {
                    if (storage[i].split("")[j].equals(request)) points.add(new int[] {i, j});
                }
            }

            List<int[]> targets = new ArrayList<>();
            for (int[] point : points) {
                if (isReachable(point, storage)) targets.add(point);
            }

            for (int[] target : targets) {
                char[] temp = storage[target[0]].toCharArray();
                temp[target[1]] = '1';
                storage[target[0]] = String.valueOf(temp);
            }
        }

        int answer = 0;
        for (String s : storage) {
            for (int j = 0; j < s.length(); j++) {
                if (s.charAt(j) != '1') answer++;
            }
        }

        return answer;
    }

    private boolean isReachable(int[] point, String[] storage) {
        Queue<int[]> q = new LinkedList<>();
        q.add(point);
        int[] dx = {1, -1, 0, 0};
        int[] dy = {0, 0, 1, -1};
        while (!q.isEmpty()) {
            int[] current = q.poll();
            if (current[0] == 0 || current[1] == 0 || current[0] == storage.length - 1 || current[1] == storage[current[0]].length() - 1) {
                return true;
            }

            for (int i = 0; i < 4; i++) {
                int nx = dx[i] + current[1];
                int ny = dy[i] + current[0];

                if (storage[ny].charAt(nx) != '1') continue;

                q.add(new int[] {ny, nx});
            }
        }

        return false;
    }
}
```

최초 풀이에선 시간초과
- 예상했지만 어떤 방식으로 해결해야 할지 몰랐음
타겟인 좌표에서부터 외부 벽 도달 가능 여부를 탐색하는 것이 아닌 외부 벽에서부터 탐색하는 것이 핵심

```java
public int solution(String[] storage, String[] requests) {  
    for (String request : requests) {  
        if (request.length() == 2) {  
            for (int i = 0; i < storage.length; i++) {  
                storage[i] = storage[i].replaceAll(request.split("")[0], "1");  
            }  
            continue;  
        }  
  
        boolean[][] isReachable = routeReachable(storage);  
        int[] dx = new int[] {1, -1, 0, 0};  
        int[] dy = new int[] {0, 0, 1, -1};  
        for (int i = 0; i < storage.length; i++) {  
            for (int j = 0; j < storage[i].length(); j++) {  
                if (!String.valueOf(storage[i].charAt(j)).equals(request)) continue;  
                if (i == 0 || j == 0 || i == storage.length - 1 || j == storage[0].length() - 1) {  
                    char[] temp = storage[i].toCharArray();  
                    temp[j] = '1';  
                    storage[i] = String.valueOf(temp);  
                    continue;  
                }  
  
                for (int d = 0; d < 4; d++) {  
                    int nx = dx[d] + j;  
                    int ny = dy[d] + i;  
                    if (!isReachable[ny][nx]) continue;  
  
                    char[] temp = storage[i].toCharArray();  
                    temp[j] = '1';  
                    storage[i] = String.valueOf(temp);  
                }  
            }  
        }  
    }  
  
    int answer = 0;  
    for (String s : storage) {  
        for (int j = 0; j < s.length(); j++) {  
            if (s.charAt(j) != '1') answer++;  
        }  
    }  
  
    return answer;  
}  
  
private boolean[][] routeReachable(String[] storage) {  
    boolean[][] isReachable = new boolean[storage.length][storage[0].length()];  
    Queue<int[]> q = new LinkedList<>();  
    for (int i = 0; i < storage.length; i++) {  
        for (int j = 0; j < storage[i].length(); j++) {  
            if (i == 0 || j == 0 || i == storage.length - 1 || j == storage[0].length() - 1) {  
                if (storage[i].charAt(j) == '1') {  
                    isReachable[i][j] = true;  
                    q.offer(new int[] {i, j});  
                }  
            }  
        }  
    }  
  
    int[] dx = new int[] {1, -1, 0, 0};  
    int[] dy = new int[] {0, 0, 1, -1};  
    while (!q.isEmpty()) {  
        int[] current = q.poll();  
        for (int d = 0; d < 4; d++) {  
            int nx = dx[d] + current[1];  
            int ny = dy[d] + current[0];  
            if (ny < 0 || ny >= storage.length || nx < 0 || nx >= storage[ny].length() || storage[ny].charAt(nx) != '1' || isReachable[ny][nx]) continue;  
  
            isReachable[ny][nx] = true;  
            q.offer(new int[] {ny, nx});  
        }  
    }  
  
    return isReachable;  
}
```