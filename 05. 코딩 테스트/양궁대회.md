---
플랫폼: 프로그래머스
문제 이름: 양궁대회
알고리즘: 완전탐색, 그리디
tags:
  - 완전탐색
  - 그리디
date: 2025-11-20
aliases:
복습 풀이: 251120(X), 251201(X)
---
# 1차 풀이
```java
// 1. 구현 
// 3. 첫째, 라이언이 이길 수 있는 최대 점수 구하기(점수가 같다면 진것)
//  - 비용 구하기 : 10점부터 차례대로 화살을 소모하며 계산, 그 다음 9점부터, 그 다음 8점부터
//  - 이 과정으로 최댓값을 구하기
// 4. 가장 큰 차이로 이길 수 있는 점수 경우의 수가 여러개라면 비교하여 우선 순위가리기
// 5. 결과 반환
// 6. 최댓값을 구한다 한들, 어떤 점수에 맞췄는지 기록은?
import java.util.*;
import java.util.stream.*;

class Solution {
    public int[] solution(int n, int[] info) {
        Map<Integer, List<int[]>> records = new HashMap<>();
        for (int i = 0; i < n; i++) {
            int pointIdx = i;
            int arrow = n;
            int[] lion = new int[11];
            int lionPoint = 0;
            int apeachPoint = 0;
            while(arrow > 0) {
                int shots = info[pointIdx] + 1;
                if (arrow - shots < 0) {
                    apeachPoint += 10 - pointIdx;
                } else {
                    if (pointIdx == info.length - 1) {
                        shots = arrow;
                    }
                    
                    lion[pointIdx] = shots;
                    lionPoint += 10 - pointIdx;    
                }
                
                arrow -= shots;
                pointIdx++;
            }
            
            if (lionPoint == apeachPoint) continue;
            
            List<int[]> record = records.getOrDefault(lionPoint, new ArrayList<>());
            record.add(Arrays.copyOfRange(lion, 0, lion.length));
            records.put(lionPoint, record);
        }
        
        records.entrySet().stream()
            .forEach(entry -> System.out.println(entry.getKey() + ", " + entry.getValue().size()));
        if (records.size() == 0) return new int[] {-1};
        
        int max = records.keySet().stream()
            .mapToInt(Integer::intValue)
            .max()
            .orElse(0);
        if (max == 0) return new int[] {-1};
        List<int[]> record = records.get(max);
        List<int[]> result = record.stream()
            .sorted((r1, r2) -> sortBy(r1, r2))
            .collect(Collectors.toList());
        
        return result.get(0);
    }
    
    private int sortBy(int[] r1, int[] r2) {
        int length = r1.length - 1;
        while (length > -1) {
            if (r1[length] != r2[length]) {
                return r2[length] - r1[length];
            }
            length--;
        }
        
        return 1;
    }
}
```
약 55분동안 풀었지만 결국 못풂
- 단순 구현이라 생각했는데 접근 방식이 잘못됐는지?
- 지문 읽고 이해하는 시간만 20분 정도 걸린듯

# 2차 풀이
```java
class Solution {
    public int[] solution(int n, int[] info) {
        int[] ryan = new int[11];
        Result result = new Result(-1, new int[] {-1});
        shot(0, n, ryan, info, result);
        
        return result.points;
    }
    
    private void shot(int idx, int n, int[] ryan, int[] apeach, Result result) {
        if (idx == ryan.length || n == 0) {
            if (n > 0) ryan[10] = n;

            int point = calculatePoint(ryan, apeach);
            if (point > 0) result.putResult(point, ryan.clone());
            if (n > 0) ryan[10] = 0;
            
            return;
        }
        
        if (n > apeach[idx]) {
            ryan[idx] = apeach[idx] + 1;
            shot(idx + 1, n - ryan[idx], ryan, apeach, result);
            ryan[idx] = 0;
        }
        
        shot(idx + 1, n, ryan, apeach, result);
    }
    
    private int calculatePoint(int[] ryan, int[] apeach) {
        int ryanPoint = 0;
        int apeachPoint = 0;
        for (int i = 0; i < ryan.length; i++) {
            if (ryan[i] == 0 && apeach[i] == 0) continue;
            if (apeach[i] >= ryan[i]) {
                apeachPoint += 10 - i;
            } else {
                ryanPoint += 10 - i;
            }
        }
        
        return ryanPoint - apeachPoint;
    }
    
    static class Result {
        private int maxPoint;
        private int[] points;
        
        public Result(int maxPoint, int[] points) {
            this.maxPoint = maxPoint;
            this.points = points;
        }
        
        public void putResult(int point, int[] points) {
            if (point > maxPoint) {
                this.maxPoint = point;
                this.points = points;
            } else if (point == maxPoint) {
                for (int i = 10; i >= 0; i--) {
                    if (this.points[i] < points[i]) {
                        this.points = points;
                        break;
                    } else if (this.points[i] > points[i]) {
                        break;
                    }
                }
            }
        }
    }
}
```