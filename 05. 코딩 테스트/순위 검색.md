---
플랫폼: 프로그래머스
문제 이름: 순위 검색
알고리즘: 재귀, 이진탐색
tags:
  - 재귀
  - 이진탐색
date: 2025-08-15
aliases:
  - 이진탐색
복습 풀이: 250815(X)
---
# 1차 풀이
### 처음 풀이
```java
public int[] solution(String[] info, String[] query) {  
        Map<String, List<Integer>> scoresByCondition = createAllConditions();  
        putScoreByCondition(info, scoresByCondition);  
  
        scoresByCondition.values().forEach(value -> value.sort(Comparator.naturalOrder()));  
  
        List<Integer> results = new ArrayList<>();  
        for (String s : query) {  
            String[] split = s.split(" ");  
            String key = split[0] + split[2] + split[4] + split[6];  
            List<Integer> scores = scoresByCondition.get(key);  
  
            if (scores.isEmpty()) {  
                results.add(0);  
                continue;  
            }  
  
            int idx = findScoreIndex(scores, Integer.parseInt(split[7]));  
            results.add(scores.size() - idx);  
        }  
  
        return results.stream()  
                .mapToInt(Integer::intValue)  
                .toArray();  
    }  
  
    private Map<String, List<Integer>> createAllConditions() {  
        String[] languages = new String[] {"java", "python", "cpp", "-"};  
        String[] categories = new String[] {"backend", "frontend", "-"};  
        String[] careers = new String[] {"senior", "junior", "-"};  
        String[] soulFoods = new String[] {"pizza", "chicken", "-"};  
  
        Map<String, List<Integer>> scoresByCondition = new HashMap<>();  
        for (String language : languages) {  
            for (String category : categories) {  
                for (String career : careers) {  
                    for (String soulFood : soulFoods) {  
                        String target = language + category + career + soulFood;  
                        scoresByCondition.put(target, new ArrayList<>());  
                    }  
                }  
            }  
        }  
  
        return scoresByCondition;  
    }  
  
    private void putScoreByCondition(String[] info, Map<String, List<Integer>> scoresByCondition) {  
        for (String target : info) {  
            String[] split = target.split(" ");  
            List<String> keys = new ArrayList<>();  
//            createKeys(0, Arrays.copyOfRange(split, 0, 4), "", keys);  
            createKeys(0, Arrays.copyOfRange(split, 0, 4), keys);  
            keys.add(String.join("", Arrays.copyOfRange(split, 0, 4)));  
            for (String key : keys) {  
                scoresByCondition.get(key).add(Integer.parseInt(split[4]));  
            }  
        }  
    }  
  
    private void createKeys(int start, String[] conditions, List<String> keys) {  
        if (start == conditions.length) {  
            String join = String.join("", conditions);  
            keys.add(join);  
            return;  
        }  
  
  
        for (int i = start; i < conditions.length; i++) {  
            String swap = conditions[i];  
            conditions[i] = "-";  
            createKeys(i + 1, conditions, keys);  
            conditions[i] = swap;  
        }  
    }  
  
    private int findScoreIndex(List<Integer> scores, int score) {  
        int start = 0;  // inclusive  
        int end = scores.size() - 1;  // inclusive  
  
        while (end > start) {  
            int mid = (start + end) / 2;  
  
            if (scores.get(mid) >= score) {  
                end = mid;  
            } else {  
                start = mid + 1;  
            }  
        }  
  
        if (scores.get(start) < score) {  
            return scores.size();  
        }  
        return start;  
    }
```

### 정답 풀이
```java
public int[] solution(String[] info, String[] query) {  
    Map<String, List<Integer>> scoresByCondition = createAllConditions();  
    putScoreByCondition(info, scoresByCondition);  
  
    scoresByCondition.values().forEach(value -> value.sort(Comparator.naturalOrder()));  
  
    List<Integer> results = new ArrayList<>();  
    for (String s : query) {  
        String[] split = s.split(" ");  
        String key = split[0] + split[2] + split[4] + split[6];  
        List<Integer> scores = scoresByCondition.get(key);  
  
        if (scores.isEmpty()) {  
            results.add(0);  
            continue;  
        }  
  
        int idx = findScoreIndex(scores, Integer.parseInt(split[7]));  
        results.add(scores.size() - idx);  
    }  
  
    return results.stream()  
            .mapToInt(Integer::intValue)  
            .toArray();  
}  
  
private Map<String, List<Integer>> createAllConditions() {  
    String[] languages = new String[] {"java", "python", "cpp", "-"};  
    String[] categories = new String[] {"backend", "frontend", "-"};  
    String[] careers = new String[] {"senior", "junior", "-"};  
    String[] soulFoods = new String[] {"pizza", "chicken", "-"};  
  
    Map<String, List<Integer>> scoresByCondition = new HashMap<>();  
    for (String language : languages) {  
        for (String category : categories) {  
            for (String career : careers) {  
                for (String soulFood : soulFoods) {  
                    String target = language + category + career + soulFood;  
                    scoresByCondition.put(target, new ArrayList<>());  
                }  
            }  
        }  
    }  
  
    return scoresByCondition;  
}  
  
private void putScoreByCondition(String[] info, Map<String, List<Integer>> scoresByCondition) {  
    for (String target : info) {  
        String[] split = target.split(" ");  
        List<String> keys = new ArrayList<>();  
        createKeys(0, Arrays.copyOfRange(split, 0, 4), "", keys);  
        keys.add(String.join("", Arrays.copyOfRange(split, 0, 4)));  
        for (String key : keys) {  
            scoresByCondition.get(key).add(Integer.parseInt(split[4]));  
        }  
    }  
}  
  
private int findScoreIndex(List<Integer> scores, int score) {  
    int start = 0;  // inclusive  
    int end = scores.size() - 1;  // inclusive  
  
    while (end > start) {  
        int mid = (start + end) / 2;  
  
        if (scores.get(mid) >= score) {  
            end = mid;  
        } else {  
            start = mid + 1;  
        }  
    }  
  
    if (scores.get(start) < score) {  
        return scores.size();  
    }  
    return start;  
}  
  
private void createKeys(int depth, String[] conditions, String currentKey, List<String> keys) {  
    if (depth == 4) {  
        keys.add(currentKey);  
        return;  
    }  
  
    createKeys(depth + 1, conditions, currentKey + "-", keys);  
    createKeys(depth + 1, conditions, currentKey + conditions[depth], keys);  
}
```
재귀와 이진 탐색이 함께 섞인 문제.
재귀 부분에 막혀 이진 탐색은 그냥 답안만 복사함

문제 풀이 과정을 살펴보자.
먼저, 문제를 읽어보면 조건을 만족하는 사람 중 코딩 테스트 점수가 n점 이상 받은 사람이 몇 명인가를 찾는 문제다.
**이 부분에서 조건을 만족하는 지원자들을 찾고 이를 기준으로 n점 이상의 지원자 수를 구하면 된다는 것을 알 수 있다.**

여기서 첫 번째 걸림돌이 등장한다.
조건을 담고 있는 query엔 "-"라는 문자열로 해당 자리의 조건에 어떤 값이든 들어갈 수 있도록 만들고 있다.
일단 조건이 일치하는 지원자를 찾으려면 Map이나 클래스를 사용할 수 있을텐데 Map인 경우 정규 표현식을 활용할 수 없다.
**때문에 info를 활용해 미리 각 자리에 "-"문자가 들어간 key를 미리 만들어야 한다.**

여기서 재귀를 활용하게 되는데 이 부분이 첫 번째 걸림돌이었다.
처음엔 첫번째 풀이처럼 작성했는데 케이스가 8개만 생성되었다. 경우의 수를 따져본다면 16가지가 나오는게 정상이었다.

제미나이를 통해 확인해보니 **해당 재귀는 트리 재귀로 분류**할 수 있었다.
```text
재귀는 호출되는 형태에 따라 분류할 수도 있습니다.

- 선형 재귀 (Linear Recursion): 함수가 자기 자신을 한 번만 호출하는 구조입니다. 팩토리얼 계산이 대표적인 예입니다. 호출 흐름이 하나의 선처럼 이어집니다.
    
- 트리 재귀 (Tree Recursion): 함수가 자기 자신을 여러 번(두 번 이상)** 호출하는 구조입니다. `createKeys`에서는 함수 내에서 `createKeys(...)`를 두 번 호출하고 있습니다.
```
내가 처음 사용했던 방식은 선형 재귀이기에 딱 반쪽만 탐색할 수 있었다.