---
플랫폼: 프로그래머스
문제 이름: 보석쇼핑
알고리즘: 투포인터
tags:
  - 투포인터
date: 2025-09-15
aliases:
  - 투포인터
복습 풀이: 250915(X), 250920(X)
---
# 1차 풀이
```java
public int[] solution(String[] gems) {  
    Map<String, Integer> countByGem = Arrays.stream(gems)  
            .collect(Collectors.toSet()).stream()  
            .collect(Collectors.toMap(  
                    key -> key,  
                    value -> 0  
            ));  
  
    List<int[]> results = new ArrayList<>();  
    int start = 0;  
    int end = 0;  
    while (end < gems.length) {  
        String gem = gems[end];  
        countByGem.put(gem, countByGem.get(gem) + 1);  
        end++;  
  
        while (hasAllGems(countByGem)) {  
            String removed = gems[start];  
            countByGem.put(removed, countByGem.get(removed) - 1);  
            start++;  
            results.add(new int[] {start, end});  
        }  
    }  
  
  
    results.sort((a1, a2) -> {  
        int len1 = a1[1] - a1[0];  
        int len2 = a2[1] - a2[0];  
  
        if (len1 == len2) {  
            return a1[0] - a2[0];  
        }  
        return len1 - len2;  
    });  
  
    return results.get(0);  
}  
  
private boolean hasAllGems(Map<String, Integer> gems) {  
    return gems.values().stream()  
            .noneMatch(value -> value <= 0);  
}
```
방식은 맞았으나 시간 초과인 테케들이 존재해 틀림
예상했던대로, 내부 반복문에서 hasAllGems로 계속 확인하는 부분이 시간복잡도를 증가시키는 요인

```java
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public int[] solution(String[] gems) {
        Map<String, Integer> countByGem = Arrays.stream(gems)
                .collect(Collectors.toSet()).stream()
                .collect(Collectors.toMap(
                        key -> key,
                        value -> 0
                ));

        int totalGemTypes = countByGem.size();
        int currentGemTypes = 0; 

        List<int[]> results = new ArrayList<>();
        int start = 0;
        int end = 0;
        while (end < gems.length) {
            String gem = gems[end];
            int count = countByGem.get(gem);

            if (count == 0) {
                currentGemTypes++;
            }
            
            countByGem.put(gem, count + 1);
            end++;
            
            while (currentGemTypes == totalGemTypes) {
                results.add(new int[] {start + 1, end}); 

                String removed = gems[start];
                int removedCount = countByGem.get(removed);


                if (removedCount == 1) {
                    currentGemTypes--;
                }
                countByGem.put(removed, removedCount - 1);
                start++;
            }
        }

        results.sort((a1, a2) -> {
            int len1 = a1[1] - a1[0];
            int len2 = a2[1] - a2[0];

            if (len1 == len2) {
                return a1[0] - a2[0];
            }
            
            return len1 - len2;
        });

        return results.get(0);
    }
}
```
위 풀이는 내 코드 기반으로 수정한 것인데 아무래도 가독성이 떨어지고, 이해가 어려움.
아래 방식으로 기억하기.

```java
import java.util.*;

class Solution {
    public int[] solution(String[] gems) {
        // 1. 전체 보석 종류의 개수 파악
        Set<String> gemTypes = new HashSet<>(Arrays.asList(gems));
        int totalGemTypes = gemTypes.size();

        // 2. 필요한 변수 초기화
        Map<String, Integer> gemCountMap = new HashMap<>(); // 현재 구간 내 보석 종류별 개수
        int[] answer = new int[2]; // 최종 정답 [시작, 끝]
        int minLength = Integer.MAX_VALUE; // 최소 구간 길이
        int start = 0; // 시작 포인터

        // 3. 슬라이딩 윈도우 시작
        for (int end = 0; end < gems.length; end++) {
            String currentGem = gems[end];

            // end 포인터가 가리키는 보석을 맵에 추가
            gemCountMap.put(currentGem, gemCountMap.getOrDefault(currentGem, 0) + 1);

            // start 포인터를 옮길 조건 확인: 모든 종류의 보석을 포함하는가?
            // (핵심 개선점 1: O(K)의 hasAllGems 대신 O(1)의 map.size() 비교)
            while (gemCountMap.size() == totalGemTypes) {
                // 현재 구간의 길이 계산
                int currentLength = end - start + 1;

                // (핵심 개선점 2: List에 다 담고 정렬하는 대신, 최소 길이를 바로 갱신)
                if (currentLength < minLength) {
                    minLength = currentLength;
                    answer[0] = start + 1; // 문제의 요구사항은 1부터 시작하는 인덱스
                    answer[1] = end + 1;
                }

                // 이제 start 포인터를 오른쪽으로 한 칸 옮겨 구간을 줄인다.
                String startGem = gems[start];
                gemCountMap.put(startGem, gemCountMap.get(startGem) - 1);

                // 만약 start 포인터를 옮기면서 특정 보석이 구간에서 완전히 사라졌다면,
                // map에서 해당 보석을 제거해야 size 비교가 정확해진다.
                if (gemCountMap.get(startGem) == 0) {
                    gemCountMap.remove(startGem);
                }
                
                start++; // 시작 포인터 이동
            }
        }

        return answer;
    }
}
```

# 2차 풀이
```java
public int[] solution(String[] gems) {  
    int size = new HashSet<>(List.of(gems)).size();  
    Map<String, Integer> countByGem = new HashMap<>();  
    int start = 0;  
    int end = 0;  
    List<int[]> results = new ArrayList<>();  
    while (true) {  
        if (countByGem.size() == size) { // 모든 종류의 보석이 있다면 하나 더 빼보기  
            if (countByGem.size() == size) {  
                results.add(new int[] {start + 1, end + 1});  
            }  
  
            start++;  
            String gem = gems[start];  
            int count = countByGem.getOrDefault(gem, 0);  
            if (count <= 1) {  
                countByGem.remove(gem);  
            }  
  
            countByGem.put(gem, count - 1);  
        } else {  
            end++;  
            if (end == gems.length) {  
                break;  
            }  
            String gem = gems[end];  
            int count = countByGem.getOrDefault(gem, 0);  
            countByGem.put(gem, count + 1);  
        }  
    }  
  
    results.sort((r1, r2) -> (r1[1] - r1[0]) - (r2[1] - r2[0]));  
  
    return results.get(0);  
}
```

start를 줄여나가는 과정이 잘못됨 아니면 반복문 조건을 다르게 설정해야 했음

```java
// 1. gems의 중복을 제거해 보석 종류의 개수 구하기
// 2. Map을 활용해 보석 개수를 확인 
// 3. 투포인터로 end가 증가하면 보석이 추가되고, start가 증가하면 보석이 하나 빠지는 것을 Map에 기록

import java.util.*;

class Solution {
    public int[] solution(String[] gems) {  
        int size = new HashSet<>(List.of(gems)).size();  
        Map<String, Integer> countByGem = new HashMap<>();  
        int start = 0;  
        int end = 0;  
        List<int[]> results = new ArrayList<>();  
        
        while (end < gems.length) {  
            if (countByGem.size() == size) { // 모든 종류의 보석이 있다면 하나 더 빼보기  
                results.add(new int[] {start + 1, end});  
 
                String gem = gems[start];  
                int count = countByGem.getOrDefault(gem, 0);  
                if (count <= 1) {  
                    countByGem.remove(gem);  
                } else {
                    countByGem.put(gem, count - 1);      
                } 
                
                start++;  
            } else {  
                String gem = gems[end];  
                int count = countByGem.getOrDefault(gem, 0);  
                countByGem.put(gem, count + 1);  
                end++;  
            }
        }  
        
        while (countByGem.size() == size) {
            results.add(new int[] {start + 1, end});
            
            String gem = gems[start];
            int count = countByGem.get(gem);
            if (count == 1) {
                countByGem.remove(gem);
            } else {
                countByGem.put(gem, count - 1);
            }
            start++;
        }

        results.sort((r1, r2) -> (r1[1] - r1[0]) - (r2[1] - r2[0]));  
  
        return results.get(0);   
    }
}
```