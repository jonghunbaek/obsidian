# 1. 문제점
단일 로그 파일은 점점 커지고, 이를 읽는 과정에서 성능 병목이 생길 수 있다. 
또한 거대한 단일 파일을 지우는 작업은 구현이 쉽지 않다. 

# 2. 해결책
```java
class WriteAheadLog ... {
	...
	public Long writeEntry(WALEntry entry) {
		maybeRoll();
		return openSegment.writeEntry(entry);
	}
	
	private void maybeRoll() {
		if (openSegment.size() >= config.getMaxLogSize()) {
			openSegment.flush();
			sortedSavedSegments.add(openSegment);
			
			long lastId = openSegment.getLastLogEntryIndex();
			openSegment = WALSegement.open(lastId, config.getWalDir());
		}
	}
}
```
단일 로그를 여러 개로 분할한다. 로그 파일을 특정 크기가 되었을 때, 롤링하는 방식으로 구현할 수 있다.
로그 분할 구현시, 논리 로그 오프셋을 로그 분할 파일로 매핑하는 방법은 두 가지다.
- **파일 이름 자체에 오프셋 정보 포함**
	- 로그 분할의 이름을 정해진 방식의 접두사(prefix)와 기본 오프셋(like 시퀀스 번호)으로 생성
	- 가독성이 좋음
- **로그 시퀀스 번호를 두 부분으로 분리**
	- 각 로그 시퀀스 번호를 파일 이름과 트랜잭션 오프셋 두 부분으로 나누기
	- 예를 들어, 64비트 정수로 구성된 시퀀스 번호를 상위 32비트, 하위 32비트로 분리
	- 상위 32비트는 분할 로그 파일 이름을 식별, 하위 32비트는 해당 파일 내에서의 트랜잭션 오프셋(상대적 위치)을 나타냄
	- 첫 번째 방법보다 연산이 빠른 장점

```java
class WALSegment ... {
	...
	
	public static String createFileName(Long startIndex) {
		return logPrefix + "_" + startIndex + logSuffix;
	}
	
	public static Long getBaseOffsetFromFileName(String fileName) {
		String[] nameAndSuffix = fileName.split(logSuffix);
		String[] prefixAndOffset = nameAndSuffix[0].split("_");
		
		if (prefixAndOffset[0].equals(logPrefix)) {
			return Long.parseLong(prefixAndOffset[1]);
		}
		
		return -1L;
	}
}

// 분할 로그 읽기 연산
// 해당 방식에서 트랜잭션 오프셋은 startIndex - walSegment.getBaseOffset()과 같은 방시긍로 찾을 수 있다.
class WriteAheadLog ... {
	...
	
	public List<WALEntry> readFrom(Long startIndex) {
		List<WALSegment> segments = getAllSegmentsContainingLogGreaterThan(startIndex);
		
		return readWalEntriesFrom(startIndex, segments);
	}
	
	private List<WALSegment> getAllSegmentsContainingLogGreaterThan(Long startIndex) {
		List<WALSegment> sements = new ArrayList<>();
		
		for (int i = sortedSavedSegments.size() - 1; i >= 0; i--) {
			WALSegment walSegment = sortedSavedSegments.get(i);
			segments.add(walSegment);
			
			if (walSegment.getBaseOffset() <= startIndex) {
				break;
			}
		}
		
		if (openSegment.getBaseOffset() <= startIndex) {
			segments.add(openSegment);
		}
		
		return segments;
	}
}
```