---
플랫폼: 프로그래머스
문제 이름: 괄호 회전하기
알고리즘: 스택, 큐
tags:
  - 스택
  - 큐
date: 2025-08-29
aliases:
  - 스택, 큐
복습 풀이: 250829(X), 250901(O), 250906(O), 251103(O)
---
# 1차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public int solution(String s) {
        Queue<Character> q = initQueue(s);
        int result = 0;
        for (int size = 0; size < s.length(); size++) {
            if (isCorrect(q)) {
                result++;
            }
            
            q.add(q.poll());
        }
        
        return result;
    }
    
    private Queue<Character> initQueue(String s) {
        Queue<Character> q = new LinkedList<>();
        for (int i = 0; i < s.length(); i++) {
            q.add(s.charAt(i));
        }
        
        return q;
    }
    
    private boolean isCorrect(Queue<Character> q) {
        String target = q.stream()
            .map(c -> String.valueOf(c))
            .collect(Collectors.joining());
        
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < target.length(); i++) {
            char c = target.charAt(i);
            
            if (c == '(' || c == '{' || c == '[') {
                stack.push(c);
                continue;
            }
            
            if (stack.isEmpty()) {
                return false;
            }
            
            char previous = stack.pop();
            
            if (c == ')' && previous != '(') {
                return false;
            }
            
            if (c == '}' && previous != '{') {
                return false;
            }
            
            if (c == ']' && previous != '[') {
                return false;
            }
        }
        
        return stack.isEmpty();
    }
}
```
전체적인 풀이 흐름은 좋았으나 isCorrect()에서 구현을 못함(잠이 덜깨서?)
여튼 답을 보고 나니 이전 [[올바른 괄호]] 구현과 크게 다르지 않은데 이걸 생각 못함


# 2차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public int solution(String s) {
        Queue<Character> q = new LinkedList<>();
        for (char c : s.toCharArray()) {
            q.offer(c);
        }
        
        int result = 0;
        for (int i = 0; i < q.size(); i++) {
            if (isValid(q)) {
                result++;
            }
            q.offer(q.poll());
        }
        
        return result;
    }
    
    private boolean isValid(Queue<Character> q) {
        String target = q.stream()
            .map(c -> String.valueOf(c))
            .collect(Collectors.joining());
        
        Stack<Character> stack = new Stack<>();
        for (int i = 0; i < target.length(); i++) {
            char c = target.charAt(i);
            
            if (c == '[' || c == '{' || c =='(') {
                stack.push(c);
            } else {
                if (stack.isEmpty()) {
                    return false;
                }
                
                char pre = stack.pop();
                if ((pre == '[' && c == ']') || (pre == '{' && c =='}') || pre == '(' && c ==')') {
                    continue;
                }
                
                return false;
            }
        }
        
        return stack.isEmpty();
    }
}
```
익숙해지기 위해 한 번 더 풀어보기

# 3차 풀이
```java
class Solution {
    public int solution(String s) {
        Queue<Character> q = new LinkedList<>();
        for (int i = 0; i < s.length(); i++) {
            q.add(s.charAt(i));
        }
        int result = 0;
        for (int i = 0; i < q.size(); i++) {
            if (isValid(q)) {
                result++;
            }
            
            q.add(q.poll());
        }
        
        return result;
    }
    
    private boolean isValid(Queue<Character> q) {
        String target = q.stream()
            .map(c -> String.valueOf(c))
            .collect(Collectors.joining());
        Stack<Character> stack = new Stack<>();
        
        for (int i = 0; i < target.length(); i++) {
            char c = target.charAt(i);
            if (c == '[' || c == '{' || c == '(') {
                stack.push(c);
                continue;
            }
            
            if (stack.isEmpty()) {
                return false;
            }
            
            char pair = stack.pop();
            if (c == ']' && pair != '[') {
                return false;
            }
            
            if (c == '}' && pair != '{') {
                return false;
            }
            
            if (c == ')' && pair != '(') {
                return false;
            }
        }
        
        return stack.isEmpty();
    }
}
```

# 4차 풀이
```java
import java.util.*;
import java.util.stream.*;

class Solution {
    public int solution(String s) {
        Queue<String> q = new LinkedList<>(List.of(s.split("")));
        int repeat = 0;
        int result = 0;
        while (repeat < s.length()) {
            if (isCorrect(q)) result++;
            q.offer(q.poll());
            repeat++;
        }
            
        return result;
    }
    
    private boolean isCorrect(Queue<String> q) {
        List<String> targets = q.stream()
                .collect(Collectors.toList());
        Stack<String> stack = new Stack<>();
        
        for (int i = 0; i < targets.size(); i++) {
            String target = targets.get(i);
            if (target.equals("]")) {
                if (stack.isEmpty() || !stack.peek().equals("[")) {
                    return false;
                } else {
                    stack.pop();
                }
            } else if (target.equals("}")) {
                if (stack.isEmpty() || !stack.peek().equals("{")) {
                    return false;
                } else {
                    stack.pop();
                }
            } else if (target.equals(")")) {
                if (stack.isEmpty() || !stack.peek().equals("(")) {
                    return false;
                } else {
                    stack.pop();
                }
            } else {
                stack.push(target);    
            }
        }
        
        return stack.isEmpty();
    }
}
```