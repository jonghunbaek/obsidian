---
플랫폼: 프로그래머스
문제 이름: 입국 심사
알고리즘: 이진탐색
tags:
  - 이진탐색
date: 2025-08-15
aliases:
  - 이진탐색
복습 풀이: 250815(X), 250818(X), 250824(O)
---
# 1차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        
        while (end > start) {
            long middle = (start + end) / 2;
            
            if (isShorter(middle, n, times)) {
                end = middle;                            
            } else {
                start = middle + 1;
            }
        }
        
        return start;
    }
    
    private boolean isShorter(long target, int n, int[] times) {
        long temp = 0;
        for (int time : times) {
            temp += target / time;
        }
        
        return temp >= n;
    }
}
```
이진 탐색인 것을 알고 봤지만 여전히 접근법조차 생각이 나지 않았던 문제
이진 탐색을 세우는 방식과 이진 탐색을 구분하는 조건에 대한 생각이 필요함

```java
// 1. 문제의 핵심은 시간을 기준으로 몇명의 심사를 완료했는지다.
// 2. 특정 시간(분)을 심사 시간으로 나누면 해당 심사관이 몇명을 심사할 수 있는지 알 수 있다.
// 3. 심사관의 심사 시간 배열을 순회하며 이 값을 더해 n과 일치하는 경우를 찾는것이 핵심
class Solution {
    public long solution(int n, int[] times) {
        long start = 0;
        long end = 1000000000000000000L;
        
        while (start < end) {
            long mid = (start + end) / 2;
            
            if (isBigger(mid, n, times)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        return start;
    }
    
    private boolean isBigger(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
코드가 간단해 기억나는데로 풀어 맞추긴했으나 제대로 이해하고 푼 것은 아님

# 3차 풀이
```java
class Solution {
    public long solution(int n, int[] times) {
        long start = 1;
        long end = 1000000000000000000L;
        
        while (start < end) {
            long mid = (start + end) / 2;
            
            if (isValid(mid, n, times)) {
                end = mid;
            } else {
                start = mid + 1;
            }
        }
        
        return start;
    }
    
    private boolean isValid(long mid, int n, int[] times) {
        long count = 0;
        for (int time : times) {
            count += mid / time;
        }
        
        return count >= n;
    }
}
```
확실히 저번주보단 이해도가 올라감. 다만 이해보단 공식을 외운 느낌이라 더 풀어보며 이해도를 높이기