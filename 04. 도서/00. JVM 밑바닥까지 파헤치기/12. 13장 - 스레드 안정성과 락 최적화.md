# 1. 스레드 안정성
일반적으로 스레드 안전성의 정의에 대해 다음과 같이 설명한다.
> 어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있다면 그 객체는 스레드 안전하다.

하지만 이는 실제로 적용하는데 필요한 정보가 빠져있다. 좀 더 자세히 정의하자면 다음과 같다.
> 여러 스레드가 한 객체에 동시에 접근할 때, 어떤 런타임 환경에서든 다음 두 조건을 모두 충족하면서
> 객체를 호출하는 행위가 올바른 결과를 얻을 수 있다면, "그 객체는 스레드 안전하다"라고 말한다.
> - 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 없다.
> - 추가적인 동기화 수단이나 호출자 측에서 조율이 필요 없다.

이러한 정의와 함께 자바 언어의 스레드 안정성에 대해 알아보자.
## 1.1 자바의 스레드 안정성
스레드의 안정성은 이분법적 사고에서 벗어나 아래처럼 안전함의 정도에 따라 다섯 단계로 구분할 수 있다.
- **불변**
	- 불변 객체는 객체 자체의 메서드 구현과 호출자 모두에서 아무런 안전장치 없이도 스레드 안전
- **절대적 스레드 안전**
	- 앞선 정의에 따르면 실제로 절대적 스레드 안전을 구현하는 것은 매우 많은 비용이 들거나 비현실적
	- 자바 API에서 스레드 안전하다고 표시된 클래스 대부분이 절대적 스레드 안전을 의미하지 않음
- **조건부 스레드 안전**
	- 일반적으로 스레드 안전하다고 말할 때의 안전 수준을 의미
	- 단일한 작업은 스레드 안전하게 수행되나, 특정 순서로 연달아 호출하는 작업에선 호출자에서 추가 동기화 작업이 필요
- **스레드 호환**
	- 객체 자체는 스레드 안전하지 않으나 호출자가 적절히 조치하면 스레드 안전하게 사용할 수도 있음 
- **스레드 적대적**
	- 호출자가 동기화 조치를 취해도 멀티스레드 환경에서 안전하게 사용할 수 없음

## 1.2 스레드 안전성의 구현
### 상호 배제 동기화
자바에서 상호 배제 동기화를 구현하는 가장 기본적인 수단은 syncronized 키워드다.
syncronized를 통해 락을 얻으면 다른 스레드는 락을 얻은 스레드가 락을 해제할 때까지 블록된다. 
즉, 락을 해제할 때까지 다른 스레드의 진입을 무조건 차단한다. 그러므로 락 소유 스레드가 락을 해제하도록 강제할 방법이 없다.
이 과정에서 스레드를 정지하거나 깨워야 하는데, Java 스레드는 커널 스레드와 매핑된 스레드이기 때문에 비용이 많이 발생한다. 

이러한 문제에 대한 해결책으로 JDK 5부터 Lock인터페이스가 추가되었다.
Lock 인터페이스는 논블록 구조의 상호배제 동기화를 구현하며 대표적인 구현체는 ReentrantLock이 있다.
ReentrantLock은 syncronized와 비슷하지만 몇 가지 더 진보된 기능을 제공한다.
- **대기 중 인터럽트**
	- 락을 소유한 스레드가 오랜시간 락을 해제하지 않을 경우 대기 중인 다른 스레드들이 락을 포기하고 다른 작업을 수행
- **페어 락**
	- 락 획득을 시도한 시간 순서대로 락을 획득
	- 기본은 언페어 락이며, 페어락을 사용할 경우 성능이 급격히 떨어져 처리량에 악영향을 줄 수 있음
- **둘 이상의 조건 지정**
	- 동시에 여러 개의 Condition 객체와 연결해 락 조건을 지정할 수 있음

*** 주의 ***
이상의 이야기는 JDK5까지에서 가능한 이야기다. JDK6부턴 syncronized의 성능이 향상되어 큰 차이가 존재하지 않는다.
때문에 가능하다면 syncronize를 쓰는 것이 다음과 같은 이유로 유리할 수 있다.
- 자바 구문 수준의 동기화 수단이며 매우 간결하고 명확
- Lock은 finally 블록에서 직접 해제해야 하지만 syncronized는 JVM이 예외 발생 시 락 해제를 보장
- 동기화 최적화는 JVM에 맡기는 편이 유리함
### 논블로킹 동기화
JVM에서 상호 배제 동기화를 위해 대부분 블로킹 동기화 방식을 사용한다.
때문에 컨텍스트 스위칭이 일어나 많은 비용을 사용하게 된다.
그리고 이를 문제 해결 방법이라는 관점에서 볼 때, 비관적 동시성 전략이라고 볼 수 있다.

하드웨어 기술이 발전하며 충돌 감지를 기반으로 작동하는 낙관적 동시성 전략이 등장했다.
스레드 경합이 발생하더라도 작업을 수행하고, 만약 충돌이 감지되면 보완 조치를 취한다.
일반적인 보완 조치는 경합하는 공유 데이터가 없을 때까지 계속 재시도하는 것이다. 
이를 논블로킹 동기화라고 부른다. 

이러한 낙관적 동시성 전략엔 하드웨어 명령어 집합의 발전이 필수였다.
작업 진행과 충돌 감지라는 두 단계를 원자적으로 수행해야 하기 때문이다. 
대표적인 예시는 다음과 같다.
- **TAS(Test-and-Set) : 검사와 지정**
- **FAA(Fetch-and-Add) : 페치와 증가**
- **Swap : 교환**
- **CAS(Compare-and-Swap) : 비교와 교환**
- **LL/SC(Load-Linked/Store-Condition) : 적재와 저장**
Java에선 CAS 연산을 이용해 낙관적 동시성 전략을 구현한다.
>[!CAS 연산의 한계]
>CAS 연산이 분명 단순하고 효율적이라는 큰 장점을 가지지만 그 한계 또한 명확하다.
>대표적으로 ABA문제가 존재하고, 경합이 심할 경우 CPU를 낭비하며 무한 반복될 수 있다.
>또한 단일 변수에만 사용 가능하기 때문에 모든 상호 배제 동기화 시나리오를 대신할 수 없다.

### 동기화가 필요 없는 메커니즘
스레드 안정성을 구현하기 위해 반드시 동기화 작업을 할 필요는 없다. 다음은 그 대표적인 예시다.
- **재진입 코드**
	- 
- **스레드 로컬 저장소**


