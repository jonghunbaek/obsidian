---
플랫폼: 프로그래머스
문제 이름: 보석쇼핑
알고리즘: 투포인터
tags:
  - 투포인터
date: 2025-09-15
aliases:
  - 투포인터
복습 풀이: 250915(X), 250920(X), 251004(O), 251011(O)
---
# 1차 풀이
```java
public int[] solution(String[] gems) {  
    Map<String, Integer> countByGem = Arrays.stream(gems)  
            .collect(Collectors.toSet()).stream()  
            .collect(Collectors.toMap(  
                    key -> key,  
                    value -> 0  
            ));  
  
    List<int[]> results = new ArrayList<>();  
    int start = 0;  
    int end = 0;  
    while (end < gems.length) {  
        String gem = gems[end];  
        countByGem.put(gem, countByGem.get(gem) + 1);  
        end++;  
  
        while (hasAllGems(countByGem)) {  
            String removed = gems[start];  
            countByGem.put(removed, countByGem.get(removed) - 1);  
            start++;  
            results.add(new int[] {start, end});  
        }  
    }  
  
  
    results.sort((a1, a2) -> {  
        int len1 = a1[1] - a1[0];  
        int len2 = a2[1] - a2[0];  
  
        if (len1 == len2) {  
            return a1[0] - a2[0];  
        }  
        return len1 - len2;  
    });  
  
    return results.get(0);  
}  
  
private boolean hasAllGems(Map<String, Integer> gems) {  
    return gems.values().stream()  
            .noneMatch(value -> value <= 0);  
}
```
방식은 맞았으나 시간 초과인 테케들이 존재해 틀림
예상했던대로, 내부 반복문에서 hasAllGems로 계속 확인하는 부분이 시간복잡도를 증가시키는 요인

```java
import java.util.*;
import java.util.stream.Collectors;

class Solution {
    public int[] solution(String[] gems) {
        Map<String, Integer> countByGem = Arrays.stream(gems)
                .collect(Collectors.toSet()).stream()
                .collect(Collectors.toMap(
                        key -> key,
                        value -> 0
                ));

        int totalGemTypes = countByGem.size();
        int currentGemTypes = 0; 

        List<int[]> results = new ArrayList<>();
        int start = 0;
        int end = 0;
        while (end < gems.length) {
            String gem = gems[end];
            int count = countByGem.get(gem);

            if (count == 0) {
                currentGemTypes++;
            }
            
            countByGem.put(gem, count + 1);
            end++;
            
            while (currentGemTypes == totalGemTypes) {
                results.add(new int[] {start + 1, end}); 

                String removed = gems[start];
                int removedCount = countByGem.get(removed);


                if (removedCount == 1) {
                    currentGemTypes--;
                }
                countByGem.put(removed, removedCount - 1);
                start++;
            }
        }

        results.sort((a1, a2) -> {
            int len1 = a1[1] - a1[0];
            int len2 = a2[1] - a2[0];

            if (len1 == len2) {
                return a1[0] - a2[0];
            }
            
            return len1 - len2;
        });

        return results.get(0);
    }
}
```
위 풀이는 내 코드 기반으로 수정한 것인데 아무래도 가독성이 떨어지고, 이해가 어려움.
아래 방식으로 기억하기.

```java
import java.util.*;

class Solution {
    public int[] solution(String[] gems) {
        // 1. 전체 보석 종류의 개수 파악
        Set<String> gemTypes = new HashSet<>(Arrays.asList(gems));
        int totalGemTypes = gemTypes.size();

        // 2. 필요한 변수 초기화
        Map<String, Integer> gemCountMap = new HashMap<>(); // 현재 구간 내 보석 종류별 개수
        int[] answer = new int[2]; // 최종 정답 [시작, 끝]
        int minLength = Integer.MAX_VALUE; // 최소 구간 길이
        int start = 0; // 시작 포인터

        // 3. 슬라이딩 윈도우 시작
        for (int end = 0; end < gems.length; end++) {
            String currentGem = gems[end];

            // end 포인터가 가리키는 보석을 맵에 추가
            gemCountMap.put(currentGem, gemCountMap.getOrDefault(currentGem, 0) + 1);

            // start 포인터를 옮길 조건 확인: 모든 종류의 보석을 포함하는가?
            // (핵심 개선점 1: O(K)의 hasAllGems 대신 O(1)의 map.size() 비교)
            while (gemCountMap.size() == totalGemTypes) {
                // 현재 구간의 길이 계산
                int currentLength = end - start + 1;

                // (핵심 개선점 2: List에 다 담고 정렬하는 대신, 최소 길이를 바로 갱신)
                if (currentLength < minLength) {
                    minLength = currentLength;
                    answer[0] = start + 1; // 문제의 요구사항은 1부터 시작하는 인덱스
                    answer[1] = end + 1;
                }

                // 이제 start 포인터를 오른쪽으로 한 칸 옮겨 구간을 줄인다.
                String startGem = gems[start];
                gemCountMap.put(startGem, gemCountMap.get(startGem) - 1);

                // 만약 start 포인터를 옮기면서 특정 보석이 구간에서 완전히 사라졌다면,
                // map에서 해당 보석을 제거해야 size 비교가 정확해진다.
                if (gemCountMap.get(startGem) == 0) {
                    gemCountMap.remove(startGem);
                }
                
                start++; // 시작 포인터 이동
            }
        }

        return answer;
    }
}
```

# 2차 풀이
```java
public int[] solution(String[] gems) {  
    int size = new HashSet<>(List.of(gems)).size();  
    Map<String, Integer> countByGem = new HashMap<>();  
    int start = 0;  
    int end = 0;  
    List<int[]> results = new ArrayList<>();  
    while (true) {  
        if (countByGem.size() == size) { // 모든 종류의 보석이 있다면 하나 더 빼보기  
            if (countByGem.size() == size) {  
                results.add(new int[] {start + 1, end + 1});  
            }  
  
            start++;  
            String gem = gems[start];  
            int count = countByGem.getOrDefault(gem, 0);  
            if (count <= 1) {  
                countByGem.remove(gem);  
            }  
  
            countByGem.put(gem, count - 1);  
        } else {  
            end++;  
            if (end == gems.length) {  
                break;  
            }  
            String gem = gems[end];  
            int count = countByGem.getOrDefault(gem, 0);  
            countByGem.put(gem, count + 1);  
        }  
    }  
  
    results.sort((r1, r2) -> (r1[1] - r1[0]) - (r2[1] - r2[0]));  
  
    return results.get(0);  
}
```

start를 줄여나가는 과정이 잘못됨 아니면 반복문 조건을 다르게 설정해야 했음

```java
// 1. gems의 중복을 제거해 보석 종류의 개수 구하기
// 2. Map을 활용해 보석 개수를 확인 
// 3. 투포인터로 end가 증가하면 보석이 추가되고, start가 증가하면 보석이 하나 빠지는 것을 Map에 기록

import java.util.*;

class Solution {
    public int[] solution(String[] gems) {  
        int size = new HashSet<>(List.of(gems)).size();  
        Map<String, Integer> countByGem = new HashMap<>();  
        int start = 0;  
        int end = 0;  
        List<int[]> results = new ArrayList<>();  
        
        while (end < gems.length) {  
            if (countByGem.size() == size) { // 모든 종류의 보석이 있다면 하나 더 빼보기  
                results.add(new int[] {start + 1, end});  
 
                String gem = gems[start];  
                int count = countByGem.getOrDefault(gem, 0);  
                if (count <= 1) {  
                    countByGem.remove(gem);  
                } else {
                    countByGem.put(gem, count - 1);      
                } 
                
                start++;  
            } else {  
                String gem = gems[end];  
                int count = countByGem.getOrDefault(gem, 0);  
                countByGem.put(gem, count + 1);  
                end++;  
            }
        }  
        
        while (countByGem.size() == size) {
            results.add(new int[] {start + 1, end});
            
            String gem = gems[start];
            int count = countByGem.get(gem);
            if (count == 1) {
                countByGem.remove(gem);
            } else {
                countByGem.put(gem, count - 1);
            }
            start++;
        }

        results.sort((r1, r2) -> (r1[1] - r1[0]) - (r2[1] - r2[0]));  
  
        return results.get(0);   
    }
}
```

# 3차 풀이
```java
// 1. 보석의 중복을 제거해 총 개수 구하기
// 2. start, end 두 개의 포인터를 움직이며 앞서 구한 총 개수와 일치할 경우 정답 List에 넣기
// 3. 정답 목록을 길이가 짧은순으로 정렬, 같다면 앞 번호가 빠른 순으로 정렬
import java.util.*;

class Solution {
    public int[] solution(String[] gems) {
        int size = new HashSet<>(List.of(gems)).size();
        Map<String, Integer> countByGem = new HashMap<>();
        List<int[]> results = new ArrayList<>();
        
        int start = 0;
        int end = 0;
        countByGem.put(gems[end], 1);
        while (end < gems.length) {
            if (countByGem.size() < size) {
                end++;
                if (end >= gems.length) {
                    continue;
                }
                
                String gem = gems[end];
                countByGem.put(gem, countByGem.getOrDefault(gem, 0) + 1);
            } else {
                results.add(new int[] {start + 1, end + 1});

                String gem = gems[start];
                int count = countByGem.getOrDefault(gem, 0);
                if (count <= 1) {
                    countByGem.remove(gem);
                } else {
                    countByGem.put(gem, count - 1);
                }
                
                start++;
            }
        }
        
        results.sort((r1, r2) -> {
            int l1 = r1[1] - r1[0];
            int l2 = r2[1] - r2[0];
            
            if (l1 == l2) {
                return r1[0] - r2[0];
            }
            
            return l1 - l2;
        });
        
        return results.get(0);
    }
}
```

아래 조건문에서 else 블록을 누락해 디버깅에 많은 시간이 소요됨
```java
if (count <= 1) {
	countByGem.remove(gem);
} else {
	countByGem.put(gem, count - 1);
}
```
이번 풀이때는 문제 없었지만 지난번과 같은 end 값의 문제도 주의해야 함

# 4차 풀이
```java
// 1. gems의 종류 개수 구하기
// 2. gems 배열을 순회하며 종류 개수와 일치할 경우 start++, 반대라면 end++
// 3. 일치할 경우엔 정답 후보가 될 수 있음
import java.util.*;

class Solution {
    public int[] solution(String[] gems) {
        int size = new HashSet<>(List.of(gems)).size();
        Map<String, Integer> countByGem = new HashMap<>();
        
        int[] result = new int[] {0, gems.length};
        int start = 0;
        int end = 0;
        while (end <= gems.length) {
            if (size == countByGem.size()) {
                int origin = result[1] - result[0];
                int target = end - start;
                if (target <= origin) {
                    result[0] = start + 1;
                    result[1] = end;
                }
                
                String gem = gems[start];
                int count = countByGem.getOrDefault(gem, 0);
                if (count <= 1) {
                    countByGem.remove(gem);
                } else {
                    countByGem.put(gem, count - 1);
                }
                
                start++;
                continue;
            }
            
            if (end >= gems.length) {
                break;
            }
            
            String gem = gems[end];
            countByGem.put(gem, countByGem.getOrDefault(gem, 0) + 1);
            end++;
        }
        
        return result;
    }
}
```
뭔가 어설프게 맞춘 느낌임
이렇게 느낀 가장 큰 이유는 보석의 개수가 일치할 때, 정답 후보를 계산해서 넣는 부분 때문임
`if (target <= origin)` 여기서 같은 길이일 경우 start 값이 작은 것이 정답이 되어야하는데, 이 경우라면 뒤에 나오는 값이 정답이 되기 때문이다.
근데 다 통과함
하지만 내가 생각한 예외 케이스로 다시 확인해보니 이 풀이가 맞았음. result에 start값을 넣을 때 +1을 해서 넣기 때문에 동일한 사이즈가 나와도 문제될 수 없음

정리하자면 썩 좋은 방법의 풀이는 아니라고 판단됨
- 쉽게 이해하기 어려움
- 조금 더 명확함을 보여주도록 풀이할 수 있음