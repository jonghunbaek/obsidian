---
플랫폼: 프로그래머스
알고리즘: 이진탐색
tags:
  - 이진탐색
date: 2026-02-20
복습 풀이: 260220(O), 260301(O)
---
# 1차 풀이
```java
// 이진 탐색
// n 값 자체가 매우큼. level을 1씩 증가시키며 완전 탐색하는 것은 무리데쓰
// 또한 `정답이 될 수 있는 값 중 가장 작은 값`을 찾는 것이 문제이므로 이진 탐색이 가장 적합할 것으로 보임
// 시간 복잡도는 log(n) - 이진탐색 x 300,000 = 510만(n이 10만일 경우)

class Solution {
    public int solution(int[] diffs, int[] times, long limit) {
        int start = 1;
        int end = 100000;
        int answer = 0;
        while (start <= end) {
            int mid = (start + end) / 2;
            
            if (isValid(mid, diffs, times, limit)) {
                answer = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(int level, int[] diffs, int[] times, long limit) {
        long totalTime = 0;
        for (int i = 0; i < diffs.length; i++) {
            if (diffs[i] <= level) {
                totalTime += times[i];
            } else {
                totalTime += (times[i] + times[i - 1]) * (diffs[i] - level) + times[i];
            }
        }
        
        return totalTime <= limit;
    }
}
```
오랜만에 풀어보는 이진 탐색 문제라 당황
옛기억을 더듬으며 템플릿을 기억해내고 기준 설정을 적합하게 하여 통과
[[이진 탐색]] 내용 복습하기

# 2차 풀이
```java
class Solution {
    public int solution(int[] diffs, int[] times, long limit) {
        int start = 1;
        int end = 100000;
        int answer = 0;
        while (start <= end) {
            int mid = (start + end) / 2;
            if (isValid(mid, diffs, times, limit)) {
                answer = mid;
                end = mid - 1;
            } else {
                start = mid + 1;
            }
        }
        
        return answer;
    }
    
    private boolean isValid(int level, int[] diffs, int[] times, long limit) {
        long value = 0;
        for (int i = 0; i < diffs.length; i++) {
            if (diffs[i] <= level) {
                value += times[i];
            } else {
                value += (times[i - 1] + times[i]) * (diffs[i] - level) + times[i];
            }
        }
        
        return value <= limit;
    }
}
```