---
플랫폼: 프로그래머스
문제 이름: 쿼드압축 후 개수 세기
알고리즘: 재귀, DFS
tags:
  - 재귀
  - DFS
date: 2025-07-24
aliases:
  - 재귀
복습 풀이: 250724(X), 250727(O), 250802(O), 250809(O)
---
# 1차 풀이
```java
class Solution {
    public int[] solution(int[][] arr) {
        Count count = dfs(0, 0, arr.length, arr);

        return new int[] {count.zeroCount, count.oneCount};
    }

    public Count dfs(int offsetX, int offsetY, int size, int[][] arr) {
        for (int y = offsetY; y < offsetY + size; y++) {
            for (int  x = offsetX; x < offsetX + size; x++) {
                if (arr[offsetY][offsetX] != arr[y][x]) {
                    return dfs(offsetX, offsetY, size / 2, arr)
                            .add(dfs(offsetX + (size / 2), offsetY, size / 2, arr))
                            .add(dfs(offsetX, offsetY + (size / 2), size / 2, arr))
                            .add(dfs(offsetX + (size / 2), offsetY + (size / 2), size / 2, arr));
                }
            }
        }

        return arr[offsetY][offsetX] == 0 ? new Count(1, 0) :  new Count(0, 1);
    }

    static class Count {
        private int zeroCount;
        private int oneCount;

        public Count(int zeroCount, int oneCount) {
            this.zeroCount = zeroCount;
            this.oneCount = oneCount;
        }

        public Count add(Count other) {
            return new Count(this.zeroCount + other.zeroCount, this.oneCount + other.oneCount);
        }
    }
}
```

여전히 어려운 재귀와 DFS.. 계속 반복적으로 풀어야할 듯.
점화식을 세우는 것이 항상 어려움
큰 부분에서 작은 부분으로 수행하며 공통된 식을 세우는 것이 핵심

# 2차 풀이
```java
// 상태 - 시작x, 시작y, 크기
// 종료 조건 - 요소를 더 이상 나눌 수 없을 때
// 점화식 - (x, y, size) + (x + size / 2, y, size) + (x, y + size / 2, size), (x + size / 2, y + size / 2, size)
class Solution {
    public int[] solution(int[][] arr) {
        Count count = dfs(0, 0, arr.length, arr);
        return new int[] {count.zero, count.one};
    }
    
    private Count dfs(int offsetX, int offsetY, int size, int[][] arr) {
        for (int y = offsetY; y < offsetY + size; y++) {
            for (int x = offsetX; x < offsetX + size; x++) {
                if (arr[offsetY][offsetX] != arr[y][x]) {
                    return dfs(offsetX, offsetY, size / 2, arr)
                        .add(dfs(offsetX + size / 2, offsetY, size / 2, arr))
                        .add(dfs(offsetX, offsetY + size / 2, size / 2, arr))
                        .add(dfs(offsetX + size / 2, offsetY + size / 2, size / 2, arr));
                }
            }
        }
        
        return arr[offsetY][offsetX] == 0 ? new Count(1, 0) : new Count(0, 1);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(this.zero + other.zero, this.one + other.one);
        }
    }
}
```
문제가 어렵지 않아 쉽게 풀 수 있었음
다만 식을 세우는 부분은 여전히 어색하고 이 식을 통해 코드로 변환하는 작업은 여전히 어색하고 낯설음
**식을 세우고, 코드로 변환하는 과정을 체계적으로 연습해야 함**

# 3차 풀이
```java
// 가장 큰 부분 문제는 전체 정사각형의 0과 1의 개수를 구하는 것
// 가장 작은 부분 문제는 배열의 길이가 1인 경우
// 상태 (x, y, size) 탐색 시작 x,y 위치, 얼만큼 탐색할지 size
// 종료 조건 배열의 길이가 1이라 더 이상 나눌 수 없을때. 0, 1의 개수를 반환
// 점화식 정사각형을 4등분하여 각 사분면의 0, 1 개수를 더하면됨

class Solution {
    public int[] solution(int[][] arr) {
        Count count = count(arr, 0, 0, arr.length);
        return new int[] {count.zero, count.one};
    }
    
    private Count count(int[][] arr, int startX, int startY, int size) {
        for (int y = startY; y < startY + size; y++) {
            for (int x = startX; x < startX + size; x++) {
                if (arr[startY][startX] == arr[y][x]) {
                    continue;
                }
                
                return count(arr, startX, startY, size / 2)
                    .add(count(arr, startX + size / 2, startY, size / 2))
                    .add(count(arr, startX, startY + size / 2, size / 2))
                    .add(count(arr, startX + size / 2, startY + size / 2, size / 2));
            }
        }
        
        return arr[startY][startX] == 1 ? new Count(0, 1) : new Count(1, 0);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(zero + other.zero, one + other.one);
        }
    }
}
```

완전히 이해했다고 생각했지만 다시 풀어보니 아직 이해가 덜 된 부분들이 나옴
주기적으로 풀어보기

# 4차 풀이
```java
// 1. 가장 큰 문제는 전체 배열에서 0과 1의 개수를 세는 것
// 2. 이를 쪼개 가장 작은 문제로 나누면 배열의 각 원소를 세는 것
// 상태 변수 - 시작 좌표(x, y), 범위(size)
// 종료 조건 - 시작 좌표에서 최대 범위가 1이여서 더 이상 나눠질 수 없을 때
// 점화 방식 - (x, y, size / 2) + (x + size /2, y, size / 2) ...4사분면까지
class Solution {
    public int[] solution(int[][] arr) {
        Count count = count(0, 0, arr.length, arr);
        return new int[] {count.zero , count.one};
    }
    
    private Count count(int startX, int startY, int size, int[][] arr) {
        for (int y = startY; y < startY + size; y++) {
            for (int x = startX; x < startX + size; x++) {
                if (arr[startY][startX] != arr[y][x]) {
                    return count(startX, startY, size / 2, arr)
                        .add(count(startX + size / 2, startY, size / 2, arr))
                        .add(count(startX, startY + size / 2, size / 2, arr))
                        .add(count(startX + size / 2, startY + size / 2, size / 2, arr));
                }
            }
        }
        
        return arr[startY][startX] == 0 ? new Count(1, 0) : new Count(0, 1);
    }
    
    static class Count {
        int zero;
        int one;
        
        public Count(int zero, int one) {
            this.zero = zero;
            this.one = one;
        }
        
        public Count add(Count other) {
            return new Count(this.zero + other.zero, this.one + other.one);
        }
    }
}
```
답안을 거의 외운 상태라 풀이 자체는 어렵지 않음
다만 상태, 종료 조건, 점화식을 체계적으로 접근하는 과정이 여전히 어색함
다시 확인하니 종료 조건에 대한 이해도가 부족했음 마지막 한번 더 풀어볼 필요가 있음