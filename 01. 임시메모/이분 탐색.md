이분 탐색은 크게 세 가지 경우로 나눠 풀이할 수 있다.
- **Exact Match**: 정확한 값 찾기
- **Lower Bound**: `k` 이상이 되는 첫 위치 찾기
- **Upper Bound:** `k`  를 초과하는 첫 위치 찾기

# 1. 종류별 이분 탐색
### Exact Match
- **목표** : 배열 내 특정 값 k의 존재 여부를 확인하고, 존재한다면 해당 인덱스를 반환
- **핵심** : mid값과 k값을 비교하며 같은 경우, 작은 경우, 큰 경우 세 가지로 나눔
- **예시**
```java
int binarySearch(int[] arr, int k) {
    int start = 0;
    int end = arr.length - 1;

    while (start <= end) {
        int mid = (start + end) / 2;
        if (arr[mid] == k) {
            return mid; // 성공
        } else if (arr[mid] < k) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1; // 실패
}
```
### Lower Bound
- **목표** : 정렬된 배열에서 k값 이상인 원소 중 가장 첫 번째 원소의 인덱스 찾기
- **핵심** : mid값과 k값을 비교해 두 가지 경우로 나눔
	- arr\[mid] < k : mid값이 k보다 작은 경우, mid와 그 이전의 모든 값은 답이 될 수 없으므로 탐색 범위를 \[mid + 1, end)로 좁힘
	- arr\[mid] >= k : mid 값이 k보다 크거나 같은 경우, mid는 정답 후보가 될수 있으며 더 앞쪽에 답이 존재할 수 있으므로 탐색 범위를 \[start, mid)로 좁힘
- **예시**
```java
int lowerBound(int[] arr, int k) {
    int start = 0;
    int end = arr.length; // 범위는 [start, end)

    while (start < end) {
        int mid = (start + end) / 2;
        if (arr[mid] < k) {
            start = mid + 1;
        } else {
            end = mid;
        }
    }
    return start;
}
```

### Upper Bound
- **목표** : 정렬된 배열에서 k값을 초과하는 원소 중 가장 첫 번째 원소의 인덱스 찾기
- **핵심** : mid값과 k값을 비교해 두 가지 경우로 나눔. arr\[mid] == k인 경우를 어떻게 처리하는지가 Lower Bound와 유일한 차이
	- arr\[mid] <= k : mid값이 k값 보다 작거나 같음. mid와 그 이전의 모든 값은 k를 초과하지 않으므로 탐색 범위를 \[mid + 1, end)로 좁힘
	- arr\[mid] > k : mid값이 k값을 초과함. mid는 정답이 될 수 있으며, 더 앞쪽에 다른 답이 존재할 수 있으므로 탐색 범위를 \[start, mid)로 좁힘
- **예시**
```java
int upperBound(int[] arr, int k) {
    int start = 0;
    int end = arr.length; // 범위는 [start, end)

    while (start < end) {
        int mid = start + (end - start) / 2;
        if (arr[mid] <= k) { // Lower Bound와의 유일한 차이
            start = mid + 1;
        } else {
            end = mid;
        }
    }
    return start;
}
```
# 번외
###  정답 조건을 만족하는 값 중 가장 큰 값 구하기
- \[start, end)표기법을 사용
- 중간 값 검사 시 정답을 만족해도 더 큰 값이 있는지 찾아야 하므로 큰 쪽으로 범위를 좁히며, 중간 값을 포함
- 원소 개수가 end - start이므로 이것이 1보다 크면 반복
### 정답 조건을 만족하는 값중 가장 작은 값 구하기
- \[start, end]표기법을 사용
- 중간 값 검사 시 정답을 만족해도 더 작은 값이 있는지 찾아야 하므로 작은 쪽으로 범위를 좁히며, 중간 값을 포함
- 원소 개수가 end - start + 1이므로 이것이 1보다 크면 반복