1. 프로그래머스 - 게임 맵 최단거리(BFS, lv2), 250108
2. 프로그래머스 - 124 나라(구현, 규칙, lv2), 250108
3. 프로그래머스 - 퍼즐 게임 챌린지(이진 탐색, lv2), 250109 - 못품
	1. 마지막까지 못 푼이유는 이분 탐색 구현이 어색함
	2. 두 번째는 소요 시간을 계산할 때, times배열이 아닌 diffs 배열을 사용해 계산함
4. 프로그래머스 - 충돌 위험 찾기(구현, lv2) 250111 - 못품
	1. 최초에 BFS 알고리즘을 사용해야 한다고 판단(최단 거리를 찾아야 하기 때문)
	2. 문제 조건에 따르면 굳이 사용할 필요도 없었고, Y축을 우선해야 하는 조건 때문에 최단 거리를 구하는 코드를 구현하는데 어려움이 존재
	3. 해당 부분을 다른 코드를 참고하여 작성 후 다시 문제 풀기
	4. 처음 Zone 객체의 내부 필드를 Set을 사용하고 boolean값을 통해 충돌 여부를 판단.
	5. 같은 좌표에서 시간마다 충돌이 발생할 수 있기 때문에 해당 구현은 적합하지 않음
	6. Map을 사용해서 해결
	7. 이 과정에서 반례를 찾지 못해 다른 사람의 반례를 참고함
5. 프로그래머스 - 석유 시추(dfs, 노드, lv2), 250114
	1. 시추관을 설치할 때마다 전체 개수를 세는 것은 시간 초과
	2. 각 석유 덩어리를 하나의 노드로 보고, 미리 개수를 산정
	3. 배열을 순회하며, 석유 발견 시 전체 덩어리의 개수를 미리 산정
	4. 이후, 각 열마다 겹치는 석유 덩어리(노드 번호)를 파악하고 개수를 산정
6. 프로그래머스 - 아날로그 시계(구현, lv2) 250115
	1. 문제의 접근 방식은 좋았으나 시계에서 알람이 울리는 구간을 구하지 못함
	2. 시계의 각도에 따라 알림 구간을 구하는게 주 목적인 문제이니 알고리즘 공부엔 썩 좋지 않은 듯, 나중에 시간 여유가 될 때 다시 풀어보기
7. 프로그래머스 - 요격 시스템(그리디, lv2), 250120 - 못품(2회차)
	1. 두 번째 풀었지만 또 틀린 문제, 그리디에 약한듯
	2. 문제의 핵심과 풀이는 매우 간단함
	3. 정렬의 기준을 잡기가 중요함
	4. 미사일이 끝나는 지점에 요격 미사일을 발사해야 최대한 많은 폭격 미사일을 격추할 수 있음
	5. 이를 확인하기 위한 조건은 요격 미사일 위치와 폭격 미사일 위치의 관계
8. 프로그래머스 - 두 원 사이의 정수 쌍( ,lv2), 250121