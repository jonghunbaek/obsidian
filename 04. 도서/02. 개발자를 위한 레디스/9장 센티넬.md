레디스 복제는 고가용성을 반쪽만 보장한다.
마스터가 다운되더라도 바로 복제본에게 요청을 보낼 수 없다. (복제본의 정보를 알 수 없기 때문)
또한 마스터-슬레이브 관계에 있는 레디스들은 자체적으로 자동 페일 오버를 수행할 수 없다.
이 부족한 부분을 메꿔주는 기술이 바로 센티넬이다.

# 1. 센티넬 개요
센티넬은 레디스 인스턴스와는 다른 별도의 프로그램이다. 

센티넬의 주요 기능은 다음과 같다.
- **모니터링**
	- 마스터, 복제본의 인스턴스 상태 실시간 모니터링
- **자동 페일 오버**
	- 마스터의 비정상 상태를 감지해 복제본을 새로운 마스터로 승격시킴
	- 기존 마스터에 연결되어 있던 복제본을 새로운 마스터로 연결
- **인스턴스 구성 정보 안내**
	- 클라이언트에게 현재 구성에서의 마스터 정보 알려줌
	- 페일 오버가 발생해도 레디스의 엔드포인트 정보를 변경할 필요가 없음

센티넬은 다음과 같은 특징을 가진다.
- 최소 3대 이상일 때 정상적으로 동작할 수 있도록 설계됨
- 오탐을 줄이기 위해 쿼럼을 사용(쿼럼을 만족하면 페일오버를 시작)
- 레디스와 함께 배치하지 않아도 괜찮으며, 센티널만 실행된다면 최저 스펙으루 구성해도 괜찮음
	- 일반적으론 레디스 1, 센티널 1로 인스턴스에 구성하며 3대로 구성
### 센티널에서 페일오버 시 클라이언트에서 새로운 마스터 주소를 얻는 방법
기본적으로 get-master-addr-by-name를 직접 호출해서 새로운 마스터의 주소를 가져와야 한다.
즉, 센티널에서 페일오버 이후 **새로운 마스터의 주소를 직접 클라이언트에게 전달하는 것이 아닌 직접 요청을 해야한다.**
다만 레디스 클라이언트에 따라 방식이 다를 수 있다.
- **Jedis 센티널 모드**
	- Sentinel에게 직접 질의
	- 일반적으로 재접속 시 질의
- **Lettuce 센티널 모드**
	- pub/sub 방식으로 센티널 이벤트 감지
	- 이벤트 기반이므로 주기적 질의 없음
- **Redisson 센티널 모드**
	- get-master-addr-by-name을 요청해 주기적으로 주소를 polling(기본 1000ms)

# 2. 센티널 실행하기
센티널 프로세스를 실행하려면 sentinel.conf라는 별도의 구성 파일이 필요하다.
이 때, 복제본 정보는 입력하지 않아도 센티널 실행 이후 자동으로 복제본 정보를 찾아낸다. 
```text
port 26379
sentinel monitor master-test 192.168.0.11 6379 2
# sentinel moniter - 모니터링할 마스터 이름 지정 및 마스터에 이름 부여
# 이후 마스터의 정보 그리고 쿼럼 값을 입력
```
파일 작성 후, redis-sentinel 또는 redis-server를 입력하여 실행한다.

센티널 인스턴스에 접속하는 방법은 다음과 같다.
```text
redis-cli -p <센티널 port>
```

센티널이 모니터링하는 마스터, 복제본 노드의 정보 등은 다음 명령어드로 확인할 수 있다.
```text
SENTINEL master <master-name>
SENTINEL replicas <master-name>
SENTINEL sentinels #센티넬 정보
```

# 3. 센티널 운영하기
모든 레디스는 replica-priority라는 파라미터를 가지고 있고, 이 값이 가장 작은 노드가 마스터로 선출된다.
기본 값은 100이며, 0인 경우는 선출 대상에서 제외된다.

운영 중에 마스터를 추가/제거/변경할 수 있다. 하지만 **센티널이 여러 대라면 각각에 모두 설정을 적용해야** 한다.
```text
SENTINEL MONITOR <master-name> <ip> <port> <quorum>
SENTINEL REMOVE <master-name>
SENTINEL SET <name> [<option> <value> ...]
```
### 센티널 초기화
센티널은 비정상적이라 판단한 복제본 노드에 대해서도 임의로 모니터링을 멈추지 않는다. 
이 경우 다음 명령어로 센티널 인스턴스의 상태 정볼르 초기화해야 ㅎ나다.
```text
SENTINEL RESET <master-name>
```

### 센티널의 자동 페일오버 과정
- **마스터의 장애 상황 감지**
	- down-after-milliseconds의 값 이상동안 유효한 응답을 받지 못하면 마스터가 다운됐다고 판단
- **sdown, odown 실패 상태 전환**
	- 응답을 늦게 받게 되면 해당 센티널은 마스터의 상태를 우선 sdown으로 플래깅(주관적 다운 상태)
	- 이후 다른 센티널 노드들에게 장애 사실을 전파
	- 다른 센티널 노드들은 요청을 받으면 마스터 서버의 장애를 인지했는지 여부를 응답
	- 쿼럼 값 이상의 응답을 받으면 상태를 odown으로 변경(객관적 다운 상태)
	- 이 때, odown의 상태 값은 마스터 노드만 얻을 수 있음(복제본은 sdown 상태만 가짐)
- **에포크 증가**
	- 에포크 값을 통해 페일오버 버전을 관리
	- 센티널은 페일오버 전에 에포크 값을 하나 증가
- **센티널 리더 선출**
	- 다른 센티널 노드에게 센티널 리더를 선출 투표를 하라고 메시지를 보냄
	- 에포크 값을 같이 보내며, 전달 받은 에포크 값이 큰 경우 자신의 에포크를 증가시킨 뒤 투표하겠다는 응답을 보냄
	- 만약 에포크 값이 동일했다면 이미 리더로 선출한 센티널의 아이디를 응답
- **복제본 선정 후 마스터로 승격**
	- 과반수 이상의 센티널이 페일오버에 동의했다면 리더 센티널은 페일오버를 시도
	- 이 때, 복제본 선출 기준은 다음과 같음
		- 마스터로부터 긴 시간 연결이 끊겼던 복제본은 대상에서 제외
		- redis.conf에 명시된 replica-priority가 낮은 복제본
		- 마스터로부터 더 많은 데이터를 수신한 복제본
		- 2번까지 동일하다면 runID가 사전 순으로 작은 복제본 선택
- **복제 연결 변경**
	- 기존 마스터에서 새로운 마스터로 복제 연결을 변경
- **장애조치 완료**

센티널 리더를 선출하는 과정은 스플릿 브레인 현상을 방지하기 위함이다.
➡️리더가 없다면 센티널 각각이 서로 다른 복제본을 마스터로 승격시킬 수 있기 때문
>[!스플릿 브레인 현상]
>네트워크 파티션 이슈로 인해 분산 환경의 데이터 저장소가 끊어지고, 끊긴 두 부분이 각각을 정상적인 서비스라고 인식하는 현상
>

